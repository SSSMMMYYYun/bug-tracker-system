"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CountOpenMsgSceneGroupsResponseBody = exports.CountOpenMsgSceneGroupsRequest = exports.CountOpenMsgSceneGroupsHeaders = exports.CopyUnfurlingRegisterResponse = exports.CopyUnfurlingRegisterResponseBody = exports.CopyUnfurlingRegisterRequest = exports.CopyUnfurlingRegisterHeaders = exports.CheckUserIsGroupMemberResponse = exports.CheckUserIsGroupMemberResponseBody = exports.CheckUserIsGroupMemberRequest = exports.CheckUserIsGroupMemberHeaders = exports.ChatSubAdminUpdateResponse = exports.ChatSubAdminUpdateResponseBody = exports.ChatSubAdminUpdateRequest = exports.ChatSubAdminUpdateHeaders = exports.ChatIdToOpenConversationIdResponse = exports.ChatIdToOpenConversationIdResponseBody = exports.ChatIdToOpenConversationIdHeaders = exports.ChangeGroupOwnerResponse = exports.ChangeGroupOwnerResponseBody = exports.ChangeGroupOwnerRequest = exports.ChangeGroupOwnerHeaders = exports.CardTemplateBuildActionResponse = exports.CardTemplateBuildActionResponseBody = exports.CardTemplateBuildActionRequest = exports.CardTemplateBuildActionHeaders = exports.BatchQueryGroupMemberResponse = exports.BatchQueryGroupMemberResponseBody = exports.BatchQueryGroupMemberRequest = exports.BatchQueryGroupMemberHeaders = exports.BatchQueryFamilySchoolMessageResponse = exports.BatchQueryFamilySchoolMessageResponseBody = exports.BatchQueryFamilySchoolMessageRequest = exports.BatchQueryFamilySchoolMessageHeaders = exports.AutoOpenDingTalkConnectResponse = exports.AutoOpenDingTalkConnectResponseBody = exports.AutoOpenDingTalkConnectHeaders = exports.AddUnfurlingRegisterResponse = exports.AddUnfurlingRegisterResponseBody = exports.AddUnfurlingRegisterRequest = exports.AddUnfurlingRegisterHeaders = exports.AddRobotToConversationResponse = exports.AddRobotToConversationResponseBody = exports.AddRobotToConversationRequest = exports.AddRobotToConversationHeaders = exports.AddOrgTextEmotionResponse = exports.AddOrgTextEmotionResponseBody = exports.AddOrgTextEmotionRequest = exports.AddOrgTextEmotionHeaders = exports.PrivateDataValue = void 0;
exports.GetFamilySchoolConversationsResponseBody = exports.GetFamilySchoolConversationsRequest = exports.GetFamilySchoolConversationsHeaders = exports.GetFamilySchoolConversationMsgResponse = exports.GetFamilySchoolConversationMsgResponseBody = exports.GetFamilySchoolConversationMsgRequest = exports.GetFamilySchoolConversationMsgHeaders = exports.GetConversationUrlResponse = exports.GetConversationUrlResponseBody = exports.GetConversationUrlRequest = exports.GetConversationUrlHeaders = exports.DismissGroupConversationResponse = exports.DismissGroupConversationResponseBody = exports.DismissGroupConversationRequest = exports.DismissGroupConversationHeaders = exports.DeleteOrgTextEmotionResponse = exports.DeleteOrgTextEmotionResponseBody = exports.DeleteOrgTextEmotionRequest = exports.DeleteOrgTextEmotionHeaders = exports.DebugUnfurlingRegisterResponse = exports.DebugUnfurlingRegisterResponseBody = exports.DebugUnfurlingRegisterRequest = exports.DebugUnfurlingRegisterHeaders = exports.CreateStoreGroupConversationResponse = exports.CreateStoreGroupConversationResponseBody = exports.CreateStoreGroupConversationRequest = exports.CreateStoreGroupConversationHeaders = exports.CreateSceneGroupConversationResponse = exports.CreateSceneGroupConversationResponseBody = exports.CreateSceneGroupConversationRequest = exports.CreateSceneGroupConversationHeaders = exports.CreateInterconnectionResponse = exports.CreateInterconnectionResponseBody = exports.CreateInterconnectionRequest = exports.CreateInterconnectionHeaders = exports.CreateGroupConversationResponse = exports.CreateGroupConversationResponseBody = exports.CreateGroupConversationRequest = exports.CreateGroupConversationHeaders = exports.CreateCoupleGroupConversationResponse = exports.CreateCoupleGroupConversationResponseBody = exports.CreateCoupleGroupConversationRequest = exports.CreateCoupleGroupConversationHeaders = exports.CountSceneGroupsByTemplateIdResponse = exports.CountSceneGroupsByTemplateIdResponseBody = exports.CountSceneGroupsByTemplateIdHeaders = exports.CountOrgMessageOpenSceneGroupsResponse = exports.CountOrgMessageOpenSceneGroupsResponseBody = exports.CountOrgMessageOpenSceneGroupsHeaders = exports.CountOpenMsgSceneGroupsResponse = void 0;
exports.InstallRobotToOrgResponse = exports.InstallRobotToOrgResponseBody = exports.InstallRobotToOrgRequest = exports.InstallRobotToOrgHeaders = exports.GroupManageReduceResponse = exports.GroupManageReduceRequest = exports.GroupManageReduceHeaders = exports.GroupManageQueryResponse = exports.GroupManageQueryResponseBody = exports.GroupManageQueryRequest = exports.GroupManageQueryHeaders = exports.GroupCapacityOrderPlaceResponse = exports.GroupCapacityOrderPlaceResponseBody = exports.GroupCapacityOrderPlaceRequest = exports.GroupCapacityOrderPlaceHeaders = exports.GroupCapacityOrderConfirmResponse = exports.GroupCapacityOrderConfirmResponseBody = exports.GroupCapacityOrderConfirmRequest = exports.GroupCapacityOrderConfirmHeaders = exports.GroupCapacityInquiryResponse = exports.GroupCapacityInquiryResponseBody = exports.GroupCapacityInquiryRequest = exports.GroupCapacityInquiryHeaders = exports.GroupBanWordsResponse = exports.GroupBanWordsRequest = exports.GroupBanWordsHeaders = exports.GetSceneGroupTemplateMessageOpenStatusResponse = exports.GetSceneGroupTemplateMessageOpenStatusResponseBody = exports.GetSceneGroupTemplateMessageOpenStatusHeaders = exports.GetSceneGroupMembersResponse = exports.GetSceneGroupMembersResponseBody = exports.GetSceneGroupMembersRequest = exports.GetSceneGroupMembersHeaders = exports.GetSceneGroupInfoResponse = exports.GetSceneGroupInfoResponseBody = exports.GetSceneGroupInfoRequest = exports.GetSceneGroupInfoHeaders = exports.GetNewestInnerGroupsResponse = exports.GetNewestInnerGroupsResponseBody = exports.GetNewestInnerGroupsRequest = exports.GetNewestInnerGroupsHeaders = exports.GetInterconnectionUrlResponse = exports.GetInterconnectionUrlResponseBody = exports.GetInterconnectionUrlRequest = exports.GetInterconnectionUrlHeaders = exports.GetInnerGroupMembersResponse = exports.GetInnerGroupMembersResponseBody = exports.GetInnerGroupMembersRequest = exports.GetInnerGroupMembersHeaders = exports.GetFamilySchoolConversationsResponse = void 0;
exports.OpenUserSendCardMessageResponseBody = exports.OpenUserSendCardMessageRequest = exports.OpenUserSendCardMessageHeaders = exports.OpenSearchGroupListResponse = exports.OpenSearchGroupListResponseBody = exports.OpenSearchGroupListRequest = exports.OpenSearchGroupListHeaders = exports.OpenInnerGroupTransferToDeptGroupResponse = exports.OpenInnerGroupTransferToDeptGroupResponseBody = exports.OpenInnerGroupTransferToDeptGroupRequest = exports.OpenInnerGroupTransferToDeptGroupHeaders = exports.OpenGroupUserRoleQueryResponse = exports.OpenGroupUserRoleQueryResponseBody = exports.OpenGroupUserRoleQueryRequest = exports.OpenGroupUserRoleQueryHeaders = exports.OpenGroupRoleUpdateResponse = exports.OpenGroupRoleUpdateResponseBody = exports.OpenGroupRoleUpdateRequest = exports.OpenGroupRoleUpdateHeaders = exports.OpenGroupRoleRemoveResponse = exports.OpenGroupRoleRemoveResponseBody = exports.OpenGroupRoleRemoveRequest = exports.OpenGroupRoleRemoveHeaders = exports.OpenGroupRoleQueryResponse = exports.OpenGroupRoleQueryResponseBody = exports.OpenGroupRoleQueryRequest = exports.OpenGroupRoleQueryHeaders = exports.OpenGroupRoleAddResponse = exports.OpenGroupRoleAddResponseBody = exports.OpenGroupRoleAddRequest = exports.OpenGroupRoleAddHeaders = exports.OfflineUnfurlingRegisterResponse = exports.OfflineUnfurlingRegisterResponseBody = exports.OfflineUnfurlingRegisterRequest = exports.OfflineUnfurlingRegisterHeaders = exports.ListSceneGroupsByTemplateIdResponse = exports.ListSceneGroupsByTemplateIdResponseBody = exports.ListSceneGroupsByTemplateIdRequest = exports.ListSceneGroupsByTemplateIdHeaders = exports.ListOrgTextEmotionResponse = exports.ListOrgTextEmotionResponseBody = exports.ListOrgTextEmotionHeaders = exports.ListGroupTemplatesByOrgIdResponse = exports.ListGroupTemplatesByOrgIdResponseBody = exports.ListGroupTemplatesByOrgIdRequest = exports.ListGroupTemplatesByOrgIdHeaders = exports.InteractiveCardCreateInstanceResponse = exports.InteractiveCardCreateInstanceResponseBody = exports.InteractiveCardCreateInstanceRequest = exports.InteractiveCardCreateInstanceHeaders = void 0;
exports.QueryRecentConversationsHeaders = exports.QueryPersonalMessageReadStatusResponse = exports.QueryPersonalMessageReadStatusResponseBody = exports.QueryPersonalMessageReadStatusRequest = exports.QueryPersonalMessageReadStatusHeaders = exports.QueryOpenGroupBaseInfoResponse = exports.QueryOpenGroupBaseInfoResponseBody = exports.QueryOpenGroupBaseInfoRequest = exports.QueryOpenGroupBaseInfoHeaders = exports.QueryOpenConversationReceiveUserResponse = exports.QueryOpenConversationReceiveUserResponseBody = exports.QueryOpenConversationReceiveUserRequest = exports.QueryOpenConversationReceiveUserHeaders = exports.QueryMessageSendResultResponse = exports.QueryMessageSendResultResponseBody = exports.QueryMessageSendResultRequest = exports.QueryMessageSendResultHeaders = exports.QueryMembersOfGroupRoleResponse = exports.QueryMembersOfGroupRoleResponseBody = exports.QueryMembersOfGroupRoleRequest = exports.QueryMembersOfGroupRoleHeaders = exports.QueryInnerGroupRecentListResponse = exports.QueryInnerGroupRecentListResponseBody = exports.QueryInnerGroupRecentListRequest = exports.QueryInnerGroupRecentListHeaders = exports.QueryInnerGroupMemberListResponse = exports.QueryInnerGroupMemberListResponseBody = exports.QueryInnerGroupMemberListRequest = exports.QueryInnerGroupMemberListHeaders = exports.QueryGroupMuteStatusResponse = exports.QueryGroupMuteStatusResponseBody = exports.QueryGroupMuteStatusRequest = exports.QueryGroupMuteStatusHeaders = exports.QueryGroupMemberByMemberAuthResponse = exports.QueryGroupMemberByMemberAuthResponseBody = exports.QueryGroupMemberByMemberAuthRequest = exports.QueryGroupMemberByMemberAuthHeaders = exports.QueryGroupMemberResponse = exports.QueryGroupMemberResponseBody = exports.QueryGroupMemberRequest = exports.QueryGroupMemberHeaders = exports.QueryGroupInfoByMemberAuthResponse = exports.QueryGroupInfoByMemberAuthResponseBody = exports.QueryGroupInfoByMemberAuthRequest = exports.QueryGroupInfoByMemberAuthHeaders = exports.PersonalSendCardMessageResponse = exports.PersonalSendCardMessageResponseBody = exports.PersonalSendCardMessageRequest = exports.PersonalSendCardMessageHeaders = exports.OpenUserSendCardMessageResponse = void 0;
exports.SendRobotInteractiveCardResponseBody = exports.SendRobotInteractiveCardRequest = exports.SendRobotInteractiveCardHeaders = exports.SendPersonalMessageResponse = exports.SendPersonalMessageResponseBody = exports.SendPersonalMessageRequest = exports.SendPersonalMessageHeaders = exports.SendOTOInteractiveCardResponse = exports.SendOTOInteractiveCardResponseBody = exports.SendOTOInteractiveCardRequest = exports.SendOTOInteractiveCardHeaders = exports.SendInteractiveCardResponse = exports.SendInteractiveCardResponseBody = exports.SendInteractiveCardRequest = exports.SendInteractiveCardHeaders = exports.SearchInnerGroupsResponse = exports.SearchInnerGroupsResponseBody = exports.SearchInnerGroupsRequest = exports.SearchInnerGroupsHeaders = exports.RemoveRobotFromConversationResponse = exports.RemoveRobotFromConversationResponseBody = exports.RemoveRobotFromConversationRequest = exports.RemoveRobotFromConversationHeaders = exports.ReleaseUnfurlingRegisterResponse = exports.ReleaseUnfurlingRegisterResponseBody = exports.ReleaseUnfurlingRegisterRequest = exports.ReleaseUnfurlingRegisterHeaders = exports.QueryUnfurlingRegisterInfoResponse = exports.QueryUnfurlingRegisterInfoResponseBody = exports.QueryUnfurlingRegisterInfoRequest = exports.QueryUnfurlingRegisterInfoHeaders = exports.QueryUnfurlingRegisterCreatorResponse = exports.QueryUnfurlingRegisterCreatorResponseBody = exports.QueryUnfurlingRegisterCreatorRequest = exports.QueryUnfurlingRegisterCreatorHeaders = exports.QueryUnReadMessageResponse = exports.QueryUnReadMessageResponseBody = exports.QueryUnReadMessageRequest = exports.QueryUnReadMessageHeaders = exports.QuerySingleGroupResponse = exports.QuerySingleGroupResponseBody = exports.QuerySingleGroupRequest = exports.QuerySingleGroupHeaders = exports.QuerySceneGroupTemplateRobotResponse = exports.QuerySceneGroupTemplateRobotResponseBody = exports.QuerySceneGroupTemplateRobotRequest = exports.QuerySceneGroupTemplateRobotHeaders = exports.QueryRecentConversationsResponse = exports.QueryRecentConversationsResponseBody = exports.QueryRecentConversationsRequest = void 0;
exports.UpdateRobotInOrgResponse = exports.UpdateRobotInOrgResponseBody = exports.UpdateRobotInOrgRequest = exports.UpdateRobotInOrgHeaders = exports.UpdateMemberGroupNickResponse = exports.UpdateMemberGroupNickResponseBody = exports.UpdateMemberGroupNickRequest = exports.UpdateMemberGroupNickHeaders = exports.UpdateMemberBanWordsResponse = exports.UpdateMemberBanWordsRequest = exports.UpdateMemberBanWordsHeaders = exports.UpdateInteractiveCardResponse = exports.UpdateInteractiveCardResponseBody = exports.UpdateInteractiveCardRequest = exports.UpdateInteractiveCardHeaders = exports.UpdateGroupSubAdminResponse = exports.UpdateGroupSubAdminResponseBody = exports.UpdateGroupSubAdminRequest = exports.UpdateGroupSubAdminHeaders = exports.UpdateGroupPermissionResponse = exports.UpdateGroupPermissionResponseBody = exports.UpdateGroupPermissionRequest = exports.UpdateGroupPermissionHeaders = exports.UpdateGroupNameResponse = exports.UpdateGroupNameResponseBody = exports.UpdateGroupNameRequest = exports.UpdateGroupNameHeaders = exports.UpdateGroupAvatarResponse = exports.UpdateGroupAvatarResponseBody = exports.UpdateGroupAvatarRequest = exports.UpdateGroupAvatarHeaders = exports.TopboxOpenResponse = exports.TopboxOpenRequest = exports.TopboxOpenHeaders = exports.TopboxCloseResponse = exports.TopboxCloseRequest = exports.TopboxCloseHeaders = exports.SetRightPanelResponse = exports.SetRightPanelResponseBody = exports.SetRightPanelRequest = exports.SetRightPanelHeaders = exports.SendTemplateInteractiveCardResponse = exports.SendTemplateInteractiveCardResponseBody = exports.SendTemplateInteractiveCardRequest = exports.SendTemplateInteractiveCardHeaders = exports.SendRobotMessageResponse = exports.SendRobotMessageResponseBody = exports.SendRobotMessageRequest = exports.SendRobotMessageHeaders = exports.SendRobotInteractiveCardResponse = void 0;
exports.ListGroupTemplatesByOrgIdResponseBodySceneGroupDetailModels = exports.InteractiveCardCreateInstanceRequestCardData = exports.GroupManageQueryResponseBodyGroupInfoList = exports.GetNewestInnerGroupsResponseBodyGroupInfos = exports.GetFamilySchoolConversationsResponseBodyGroupInfoList = exports.GetFamilySchoolConversationMsgResponseBodyMessages = exports.GetFamilySchoolConversationMsgResponseBodyMessagesMediaModels = exports.CreateSceneGroupConversationRequestManagementOptions = exports.CreateInterconnectionResponseBodyResults = exports.CreateInterconnectionRequestInterconnections = exports.CountOpenMsgSceneGroupsResponseBodyResult = exports.BatchQueryFamilySchoolMessageResponseBodyMessages = exports.BatchQueryFamilySchoolMessageResponseBodyMessagesMediaModels = exports.AddOrgTextEmotionResponseBodyResult = exports.SendMessageResponse = exports.SendMessageResponseBody = exports.SendMessageRequest = exports.SendMessageHeaders = exports.SendDingMessageResponse = exports.SendDingMessageResponseBody = exports.SendDingMessageRequest = exports.SendDingMessageHeaders = exports.RemoveGroupMemberResponse = exports.RemoveGroupMemberResponseBody = exports.RemoveGroupMemberRequest = exports.RemoveGroupMemberHeaders = exports.AddGroupMemberResponse = exports.AddGroupMemberResponseBody = exports.AddGroupMemberRequest = exports.AddGroupMemberHeaders = exports.UpdateUnfurlingRegisterStatusResponse = exports.UpdateUnfurlingRegisterStatusResponseBody = exports.UpdateUnfurlingRegisterStatusRequest = exports.UpdateUnfurlingRegisterStatusHeaders = exports.UpdateUnfurlingRegisterResponse = exports.UpdateUnfurlingRegisterResponseBody = exports.UpdateUnfurlingRegisterRequest = exports.UpdateUnfurlingRegisterHeaders = exports.UpdateTheGroupRolesOfGroupMemberResponse = exports.UpdateTheGroupRolesOfGroupMemberResponseBody = exports.UpdateTheGroupRolesOfGroupMemberRequest = exports.UpdateTheGroupRolesOfGroupMemberHeaders = exports.UpdateSceneGroupTemplateMessageOpenStatusResponse = exports.UpdateSceneGroupTemplateMessageOpenStatusResponseBody = exports.UpdateSceneGroupTemplateMessageOpenStatusRequest = exports.UpdateSceneGroupTemplateMessageOpenStatusHeaders = exports.UpdateRobotInteractiveCardResponse = exports.UpdateRobotInteractiveCardResponseBody = exports.UpdateRobotInteractiveCardRequest = exports.UpdateRobotInteractiveCardHeaders = void 0;
exports.UpdateRobotInteractiveCardRequestUpdateOptions = exports.UpdateInteractiveCardRequestCardOptions = exports.UpdateInteractiveCardRequestCardData = exports.SetRightPanelRequestWebWndParams = exports.SendTemplateInteractiveCardRequestSendOptions = exports.SendRobotInteractiveCardRequestSendOptions = exports.SendPersonalMessageResponseBodyResult = exports.SendOTOInteractiveCardResponseBodyResult = exports.SendOTOInteractiveCardRequestCardOptions = exports.SendOTOInteractiveCardRequestCardData = exports.SendInteractiveCardResponseBodyResult = exports.SendInteractiveCardRequestCardOptions = exports.SendInteractiveCardRequestCardData = exports.SearchInnerGroupsResponseBodyGroupInfos = exports.QueryUnfurlingRegisterInfoResponseBodyList = exports.QueryUnfurlingRegisterCreatorResponseBodyData = exports.QueryUnReadMessageResponseBodyUnReadItems = exports.QuerySingleGroupResponseBodyOpenConversations = exports.QuerySingleGroupRequestGroupMembers = exports.QuerySceneGroupTemplateRobotResponseBodyResult = exports.QueryRecentConversationsResponseBodyResult = exports.QueryRecentConversationsResponseBodyResultConversationList = exports.QueryPersonalMessageReadStatusResponseBodyResult = exports.QueryPersonalMessageReadStatusResponseBodyResultMessageReadInfoList = exports.QueryOpenGroupBaseInfoResponseBodyResult = exports.QueryOpenConversationReceiveUserResponseBodyResult = exports.QueryOpenConversationReceiveUserResponseBodyResultReceiveUser = exports.QueryMessageSendResultResponseBodyResult = exports.QueryInnerGroupRecentListResponseBodyGroupInfos = exports.QueryInnerGroupMemberListResponseBodyList = exports.QueryGroupMuteStatusResponseBodyUserMuteResult = exports.QueryGroupMemberByMemberAuthResponseBodyGroupMemberList = exports.QueryGroupMemberResponseBodyGroupMembers = exports.PersonalSendCardMessageResponseBodyResult = exports.PersonalSendCardMessageRequestCardContent = exports.OpenUserSendCardMessageResponseBodyResult = exports.OpenUserSendCardMessageRequestCardContent = exports.OpenSearchGroupListResponseBodyResult = exports.OpenSearchGroupListResponseBodyResultGroupList = exports.OpenGroupUserRoleQueryResponseBodyResult = exports.OpenGroupUserRoleQueryResponseBodyResultGroupRoles = exports.OpenGroupRoleQueryResponseBodyResult = exports.OpenGroupRoleQueryResponseBodyResultGroupRoles = exports.OpenGroupRoleAddResponseBodyResult = exports.ListOrgTextEmotionResponseBodyResult = exports.ListOrgTextEmotionResponseBodyResultEmotions = void 0;
// This file is auto-generated, don't edit it
/**
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class PrivateDataValue extends $tea.Model {
    static names() {
        return {
            cardParamMap: 'cardParamMap',
            cardMediaIdParamMap: 'cardMediaIdParamMap',
        };
    }
    static types() {
        return {
            cardParamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            cardMediaIdParamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PrivateDataValue = PrivateDataValue;
class AddOrgTextEmotionHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOrgTextEmotionHeaders = AddOrgTextEmotionHeaders;
class AddOrgTextEmotionRequest extends $tea.Model {
    static names() {
        return {
            backgroundMediaId: 'backgroundMediaId',
            backgroundMediaIdForPanel: 'backgroundMediaIdForPanel',
            deptId: 'deptId',
            emotionName: 'emotionName',
        };
    }
    static types() {
        return {
            backgroundMediaId: 'string',
            backgroundMediaIdForPanel: 'string',
            deptId: 'number',
            emotionName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOrgTextEmotionRequest = AddOrgTextEmotionRequest;
class AddOrgTextEmotionResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: AddOrgTextEmotionResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOrgTextEmotionResponseBody = AddOrgTextEmotionResponseBody;
class AddOrgTextEmotionResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddOrgTextEmotionResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOrgTextEmotionResponse = AddOrgTextEmotionResponse;
class AddRobotToConversationHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddRobotToConversationHeaders = AddRobotToConversationHeaders;
class AddRobotToConversationRequest extends $tea.Model {
    static names() {
        return {
            icon: 'icon',
            name: 'name',
            openConversationId: 'openConversationId',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            icon: 'string',
            name: 'string',
            openConversationId: 'string',
            robotCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddRobotToConversationRequest = AddRobotToConversationRequest;
class AddRobotToConversationResponseBody extends $tea.Model {
    static names() {
        return {
            chatBotUserId: 'chatBotUserId',
        };
    }
    static types() {
        return {
            chatBotUserId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddRobotToConversationResponseBody = AddRobotToConversationResponseBody;
class AddRobotToConversationResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddRobotToConversationResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddRobotToConversationResponse = AddRobotToConversationResponse;
class AddUnfurlingRegisterHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddUnfurlingRegisterHeaders = AddUnfurlingRegisterHeaders;
class AddUnfurlingRegisterRequest extends $tea.Model {
    static names() {
        return {
            apiSecret: 'apiSecret',
            appId: 'appId',
            callbackUrl: 'callbackUrl',
            cardTemplateId: 'cardTemplateId',
            domain: 'domain',
            path: 'path',
            ruleDesc: 'ruleDesc',
            ruleMatchType: 'ruleMatchType',
            userId: 'userId',
        };
    }
    static types() {
        return {
            apiSecret: 'string',
            appId: 'string',
            callbackUrl: 'string',
            cardTemplateId: 'string',
            domain: 'string',
            path: 'string',
            ruleDesc: 'string',
            ruleMatchType: 'number',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddUnfurlingRegisterRequest = AddUnfurlingRegisterRequest;
class AddUnfurlingRegisterResponseBody extends $tea.Model {
    static names() {
        return {
            id: 'id',
            success: 'success',
        };
    }
    static types() {
        return {
            id: 'number',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddUnfurlingRegisterResponseBody = AddUnfurlingRegisterResponseBody;
class AddUnfurlingRegisterResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddUnfurlingRegisterResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddUnfurlingRegisterResponse = AddUnfurlingRegisterResponse;
class AutoOpenDingTalkConnectHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AutoOpenDingTalkConnectHeaders = AutoOpenDingTalkConnectHeaders;
class AutoOpenDingTalkConnectResponseBody extends $tea.Model {
    static names() {
        return {
            message: 'message',
        };
    }
    static types() {
        return {
            message: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AutoOpenDingTalkConnectResponseBody = AutoOpenDingTalkConnectResponseBody;
class AutoOpenDingTalkConnectResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AutoOpenDingTalkConnectResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AutoOpenDingTalkConnectResponse = AutoOpenDingTalkConnectResponse;
class BatchQueryFamilySchoolMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryFamilySchoolMessageHeaders = BatchQueryFamilySchoolMessageHeaders;
class BatchQueryFamilySchoolMessageRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            openMessageIds: 'openMessageIds',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            openMessageIds: { 'type': 'array', 'itemType': 'string' },
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryFamilySchoolMessageRequest = BatchQueryFamilySchoolMessageRequest;
class BatchQueryFamilySchoolMessageResponseBody extends $tea.Model {
    static names() {
        return {
            messages: 'messages',
        };
    }
    static types() {
        return {
            messages: { 'type': 'array', 'itemType': BatchQueryFamilySchoolMessageResponseBodyMessages },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryFamilySchoolMessageResponseBody = BatchQueryFamilySchoolMessageResponseBody;
class BatchQueryFamilySchoolMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchQueryFamilySchoolMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryFamilySchoolMessageResponse = BatchQueryFamilySchoolMessageResponse;
class BatchQueryGroupMemberHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryGroupMemberHeaders = BatchQueryGroupMemberHeaders;
class BatchQueryGroupMemberRequest extends $tea.Model {
    static names() {
        return {
            coolAppCode: 'coolAppCode',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            coolAppCode: 'string',
            maxResults: 'number',
            nextToken: 'string',
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryGroupMemberRequest = BatchQueryGroupMemberRequest;
class BatchQueryGroupMemberResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            memberUserIds: 'memberUserIds',
            nextToken: 'nextToken',
            success: 'success',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            memberUserIds: { 'type': 'array', 'itemType': 'string' },
            nextToken: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryGroupMemberResponseBody = BatchQueryGroupMemberResponseBody;
class BatchQueryGroupMemberResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchQueryGroupMemberResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryGroupMemberResponse = BatchQueryGroupMemberResponse;
class CardTemplateBuildActionHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CardTemplateBuildActionHeaders = CardTemplateBuildActionHeaders;
class CardTemplateBuildActionRequest extends $tea.Model {
    static names() {
        return {
            action: 'action',
            cardTemplateJson: 'cardTemplateJson',
        };
    }
    static types() {
        return {
            action: 'string',
            cardTemplateJson: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CardTemplateBuildActionRequest = CardTemplateBuildActionRequest;
class CardTemplateBuildActionResponseBody extends $tea.Model {
    static names() {
        return {
            cardTemplateJson: 'cardTemplateJson',
        };
    }
    static types() {
        return {
            cardTemplateJson: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CardTemplateBuildActionResponseBody = CardTemplateBuildActionResponseBody;
class CardTemplateBuildActionResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CardTemplateBuildActionResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CardTemplateBuildActionResponse = CardTemplateBuildActionResponse;
class ChangeGroupOwnerHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ChangeGroupOwnerHeaders = ChangeGroupOwnerHeaders;
class ChangeGroupOwnerRequest extends $tea.Model {
    static names() {
        return {
            groupOwnerId: 'groupOwnerId',
            groupOwnerType: 'groupOwnerType',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            groupOwnerId: 'string',
            groupOwnerType: 'number',
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ChangeGroupOwnerRequest = ChangeGroupOwnerRequest;
class ChangeGroupOwnerResponseBody extends $tea.Model {
    static names() {
        return {
            newGroupOwnerId: 'newGroupOwnerId',
            newGroupOwnerType: 'newGroupOwnerType',
        };
    }
    static types() {
        return {
            newGroupOwnerId: 'string',
            newGroupOwnerType: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ChangeGroupOwnerResponseBody = ChangeGroupOwnerResponseBody;
class ChangeGroupOwnerResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ChangeGroupOwnerResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ChangeGroupOwnerResponse = ChangeGroupOwnerResponse;
class ChatIdToOpenConversationIdHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ChatIdToOpenConversationIdHeaders = ChatIdToOpenConversationIdHeaders;
class ChatIdToOpenConversationIdResponseBody extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ChatIdToOpenConversationIdResponseBody = ChatIdToOpenConversationIdResponseBody;
class ChatIdToOpenConversationIdResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ChatIdToOpenConversationIdResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ChatIdToOpenConversationIdResponse = ChatIdToOpenConversationIdResponse;
class ChatSubAdminUpdateHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ChatSubAdminUpdateHeaders = ChatSubAdminUpdateHeaders;
class ChatSubAdminUpdateRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            role: 'role',
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            role: 'number',
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ChatSubAdminUpdateRequest = ChatSubAdminUpdateRequest;
class ChatSubAdminUpdateResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ChatSubAdminUpdateResponseBody = ChatSubAdminUpdateResponseBody;
class ChatSubAdminUpdateResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ChatSubAdminUpdateResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ChatSubAdminUpdateResponse = ChatSubAdminUpdateResponse;
class CheckUserIsGroupMemberHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CheckUserIsGroupMemberHeaders = CheckUserIsGroupMemberHeaders;
class CheckUserIsGroupMemberRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CheckUserIsGroupMemberRequest = CheckUserIsGroupMemberRequest;
class CheckUserIsGroupMemberResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CheckUserIsGroupMemberResponseBody = CheckUserIsGroupMemberResponseBody;
class CheckUserIsGroupMemberResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CheckUserIsGroupMemberResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CheckUserIsGroupMemberResponse = CheckUserIsGroupMemberResponse;
class CopyUnfurlingRegisterHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CopyUnfurlingRegisterHeaders = CopyUnfurlingRegisterHeaders;
class CopyUnfurlingRegisterRequest extends $tea.Model {
    static names() {
        return {
            appId: 'appId',
            id: 'id',
            userId: 'userId',
        };
    }
    static types() {
        return {
            appId: 'string',
            id: 'number',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CopyUnfurlingRegisterRequest = CopyUnfurlingRegisterRequest;
class CopyUnfurlingRegisterResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: 'number',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CopyUnfurlingRegisterResponseBody = CopyUnfurlingRegisterResponseBody;
class CopyUnfurlingRegisterResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CopyUnfurlingRegisterResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CopyUnfurlingRegisterResponse = CopyUnfurlingRegisterResponse;
class CountOpenMsgSceneGroupsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CountOpenMsgSceneGroupsHeaders = CountOpenMsgSceneGroupsHeaders;
class CountOpenMsgSceneGroupsRequest extends $tea.Model {
    static names() {
        return {
            templateId: 'templateId',
        };
    }
    static types() {
        return {
            templateId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CountOpenMsgSceneGroupsRequest = CountOpenMsgSceneGroupsRequest;
class CountOpenMsgSceneGroupsResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: CountOpenMsgSceneGroupsResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CountOpenMsgSceneGroupsResponseBody = CountOpenMsgSceneGroupsResponseBody;
class CountOpenMsgSceneGroupsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CountOpenMsgSceneGroupsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CountOpenMsgSceneGroupsResponse = CountOpenMsgSceneGroupsResponse;
class CountOrgMessageOpenSceneGroupsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CountOrgMessageOpenSceneGroupsHeaders = CountOrgMessageOpenSceneGroupsHeaders;
class CountOrgMessageOpenSceneGroupsResponseBody extends $tea.Model {
    static names() {
        return {
            count: 'count',
            success: 'success',
        };
    }
    static types() {
        return {
            count: 'number',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CountOrgMessageOpenSceneGroupsResponseBody = CountOrgMessageOpenSceneGroupsResponseBody;
class CountOrgMessageOpenSceneGroupsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CountOrgMessageOpenSceneGroupsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CountOrgMessageOpenSceneGroupsResponse = CountOrgMessageOpenSceneGroupsResponse;
class CountSceneGroupsByTemplateIdHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CountSceneGroupsByTemplateIdHeaders = CountSceneGroupsByTemplateIdHeaders;
class CountSceneGroupsByTemplateIdResponseBody extends $tea.Model {
    static names() {
        return {
            count: 'count',
            success: 'success',
        };
    }
    static types() {
        return {
            count: 'number',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CountSceneGroupsByTemplateIdResponseBody = CountSceneGroupsByTemplateIdResponseBody;
class CountSceneGroupsByTemplateIdResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CountSceneGroupsByTemplateIdResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CountSceneGroupsByTemplateIdResponse = CountSceneGroupsByTemplateIdResponse;
class CreateCoupleGroupConversationHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateCoupleGroupConversationHeaders = CreateCoupleGroupConversationHeaders;
class CreateCoupleGroupConversationRequest extends $tea.Model {
    static names() {
        return {
            appUserId: 'appUserId',
            groupAvatar: 'groupAvatar',
            groupName: 'groupName',
            groupOwnerId: 'groupOwnerId',
            groupTemplateId: 'groupTemplateId',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            appUserId: 'string',
            groupAvatar: 'string',
            groupName: 'string',
            groupOwnerId: 'string',
            groupTemplateId: 'string',
            operatorId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateCoupleGroupConversationRequest = CreateCoupleGroupConversationRequest;
class CreateCoupleGroupConversationResponseBody extends $tea.Model {
    static names() {
        return {
            conversationId: 'conversationId',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            conversationId: 'string',
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateCoupleGroupConversationResponseBody = CreateCoupleGroupConversationResponseBody;
class CreateCoupleGroupConversationResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateCoupleGroupConversationResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateCoupleGroupConversationResponse = CreateCoupleGroupConversationResponse;
class CreateGroupConversationHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateGroupConversationHeaders = CreateGroupConversationHeaders;
class CreateGroupConversationRequest extends $tea.Model {
    static names() {
        return {
            appUserIds: 'appUserIds',
            groupAvatar: 'groupAvatar',
            groupName: 'groupName',
            groupOwnerId: 'groupOwnerId',
            groupOwnerType: 'groupOwnerType',
            groupTemplateId: 'groupTemplateId',
            operatorId: 'operatorId',
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            appUserIds: { 'type': 'array', 'itemType': 'string' },
            groupAvatar: 'string',
            groupName: 'string',
            groupOwnerId: 'string',
            groupOwnerType: 'number',
            groupTemplateId: 'string',
            operatorId: 'string',
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateGroupConversationRequest = CreateGroupConversationRequest;
class CreateGroupConversationResponseBody extends $tea.Model {
    static names() {
        return {
            appUserIds: 'appUserIds',
            conversationId: 'conversationId',
            openConversationId: 'openConversationId',
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            appUserIds: { 'type': 'array', 'itemType': 'string' },
            conversationId: 'string',
            openConversationId: 'string',
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateGroupConversationResponseBody = CreateGroupConversationResponseBody;
class CreateGroupConversationResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateGroupConversationResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateGroupConversationResponse = CreateGroupConversationResponse;
class CreateInterconnectionHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateInterconnectionHeaders = CreateInterconnectionHeaders;
class CreateInterconnectionRequest extends $tea.Model {
    static names() {
        return {
            interconnections: 'interconnections',
        };
    }
    static types() {
        return {
            interconnections: { 'type': 'array', 'itemType': CreateInterconnectionRequestInterconnections },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateInterconnectionRequest = CreateInterconnectionRequest;
class CreateInterconnectionResponseBody extends $tea.Model {
    static names() {
        return {
            results: 'results',
        };
    }
    static types() {
        return {
            results: { 'type': 'array', 'itemType': CreateInterconnectionResponseBodyResults },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateInterconnectionResponseBody = CreateInterconnectionResponseBody;
class CreateInterconnectionResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateInterconnectionResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateInterconnectionResponse = CreateInterconnectionResponse;
class CreateSceneGroupConversationHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSceneGroupConversationHeaders = CreateSceneGroupConversationHeaders;
class CreateSceneGroupConversationRequest extends $tea.Model {
    static names() {
        return {
            features: 'features',
            groupName: 'groupName',
            groupOwnerId: 'groupOwnerId',
            icon: 'icon',
            managementOptions: 'managementOptions',
            templateId: 'templateId',
            userIdList: 'userIdList',
            uuid: 'uuid',
        };
    }
    static types() {
        return {
            features: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            groupName: 'string',
            groupOwnerId: 'string',
            icon: 'string',
            managementOptions: CreateSceneGroupConversationRequestManagementOptions,
            templateId: 'string',
            userIdList: { 'type': 'array', 'itemType': 'string' },
            uuid: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSceneGroupConversationRequest = CreateSceneGroupConversationRequest;
class CreateSceneGroupConversationResponseBody extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSceneGroupConversationResponseBody = CreateSceneGroupConversationResponseBody;
class CreateSceneGroupConversationResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateSceneGroupConversationResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSceneGroupConversationResponse = CreateSceneGroupConversationResponse;
class CreateStoreGroupConversationHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateStoreGroupConversationHeaders = CreateStoreGroupConversationHeaders;
class CreateStoreGroupConversationRequest extends $tea.Model {
    static names() {
        return {
            appUserId: 'appUserId',
            businessUniqueKey: 'businessUniqueKey',
            groupAvatar: 'groupAvatar',
            groupName: 'groupName',
            groupTemplateId: 'groupTemplateId',
            operatorId: 'operatorId',
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            appUserId: 'string',
            businessUniqueKey: 'string',
            groupAvatar: 'string',
            groupName: 'string',
            groupTemplateId: 'string',
            operatorId: 'string',
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateStoreGroupConversationRequest = CreateStoreGroupConversationRequest;
class CreateStoreGroupConversationResponseBody extends $tea.Model {
    static names() {
        return {
            conversationId: 'conversationId',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            conversationId: 'string',
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateStoreGroupConversationResponseBody = CreateStoreGroupConversationResponseBody;
class CreateStoreGroupConversationResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateStoreGroupConversationResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateStoreGroupConversationResponse = CreateStoreGroupConversationResponse;
class DebugUnfurlingRegisterHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DebugUnfurlingRegisterHeaders = DebugUnfurlingRegisterHeaders;
class DebugUnfurlingRegisterRequest extends $tea.Model {
    static names() {
        return {
            appId: 'appId',
            grayGroupIdList: 'grayGroupIdList',
            grayUserIdList: 'grayUserIdList',
            id: 'id',
            userId: 'userId',
        };
    }
    static types() {
        return {
            appId: 'string',
            grayGroupIdList: { 'type': 'array', 'itemType': 'string' },
            grayUserIdList: { 'type': 'array', 'itemType': 'string' },
            id: 'number',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DebugUnfurlingRegisterRequest = DebugUnfurlingRegisterRequest;
class DebugUnfurlingRegisterResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DebugUnfurlingRegisterResponseBody = DebugUnfurlingRegisterResponseBody;
class DebugUnfurlingRegisterResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DebugUnfurlingRegisterResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DebugUnfurlingRegisterResponse = DebugUnfurlingRegisterResponse;
class DeleteOrgTextEmotionHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteOrgTextEmotionHeaders = DeleteOrgTextEmotionHeaders;
class DeleteOrgTextEmotionRequest extends $tea.Model {
    static names() {
        return {
            deptId: 'deptId',
            emotionIds: 'emotionIds',
        };
    }
    static types() {
        return {
            deptId: 'number',
            emotionIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteOrgTextEmotionRequest = DeleteOrgTextEmotionRequest;
class DeleteOrgTextEmotionResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteOrgTextEmotionResponseBody = DeleteOrgTextEmotionResponseBody;
class DeleteOrgTextEmotionResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteOrgTextEmotionResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteOrgTextEmotionResponse = DeleteOrgTextEmotionResponse;
class DismissGroupConversationHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DismissGroupConversationHeaders = DismissGroupConversationHeaders;
class DismissGroupConversationRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DismissGroupConversationRequest = DismissGroupConversationRequest;
class DismissGroupConversationResponseBody extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DismissGroupConversationResponseBody = DismissGroupConversationResponseBody;
class DismissGroupConversationResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DismissGroupConversationResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DismissGroupConversationResponse = DismissGroupConversationResponse;
class GetConversationUrlHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConversationUrlHeaders = GetConversationUrlHeaders;
class GetConversationUrlRequest extends $tea.Model {
    static names() {
        return {
            appUserId: 'appUserId',
            channelCode: 'channelCode',
            deviceId: 'deviceId',
            openConversationId: 'openConversationId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            appUserId: 'string',
            channelCode: 'string',
            deviceId: 'string',
            openConversationId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConversationUrlRequest = GetConversationUrlRequest;
class GetConversationUrlResponseBody extends $tea.Model {
    static names() {
        return {
            url: 'url',
        };
    }
    static types() {
        return {
            url: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConversationUrlResponseBody = GetConversationUrlResponseBody;
class GetConversationUrlResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetConversationUrlResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConversationUrlResponse = GetConversationUrlResponse;
class GetFamilySchoolConversationMsgHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFamilySchoolConversationMsgHeaders = GetFamilySchoolConversationMsgHeaders;
class GetFamilySchoolConversationMsgRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            msgTypes: 'msgTypes',
            nextToken: 'nextToken',
            openConversationId: 'openConversationId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            msgTypes: { 'type': 'array', 'itemType': 'number' },
            nextToken: 'number',
            openConversationId: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFamilySchoolConversationMsgRequest = GetFamilySchoolConversationMsgRequest;
class GetFamilySchoolConversationMsgResponseBody extends $tea.Model {
    static names() {
        return {
            corpId: 'corpId',
            hasMore: 'hasMore',
            messages: 'messages',
            nextToken: 'nextToken',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            corpId: 'string',
            hasMore: 'string',
            messages: { 'type': 'array', 'itemType': GetFamilySchoolConversationMsgResponseBodyMessages },
            nextToken: 'string',
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFamilySchoolConversationMsgResponseBody = GetFamilySchoolConversationMsgResponseBody;
class GetFamilySchoolConversationMsgResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetFamilySchoolConversationMsgResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFamilySchoolConversationMsgResponse = GetFamilySchoolConversationMsgResponse;
class GetFamilySchoolConversationsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFamilySchoolConversationsHeaders = GetFamilySchoolConversationsHeaders;
class GetFamilySchoolConversationsRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'number',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFamilySchoolConversationsRequest = GetFamilySchoolConversationsRequest;
class GetFamilySchoolConversationsResponseBody extends $tea.Model {
    static names() {
        return {
            groupInfoList: 'groupInfoList',
            hasMore: 'hasMore',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            groupInfoList: { 'type': 'array', 'itemType': GetFamilySchoolConversationsResponseBodyGroupInfoList },
            hasMore: 'string',
            nextToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFamilySchoolConversationsResponseBody = GetFamilySchoolConversationsResponseBody;
class GetFamilySchoolConversationsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetFamilySchoolConversationsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFamilySchoolConversationsResponse = GetFamilySchoolConversationsResponse;
class GetInnerGroupMembersHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetInnerGroupMembersHeaders = GetInnerGroupMembersHeaders;
class GetInnerGroupMembersRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            openConversationId: 'openConversationId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            openConversationId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetInnerGroupMembersRequest = GetInnerGroupMembersRequest;
class GetInnerGroupMembersResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'string',
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetInnerGroupMembersResponseBody = GetInnerGroupMembersResponseBody;
class GetInnerGroupMembersResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetInnerGroupMembersResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetInnerGroupMembersResponse = GetInnerGroupMembersResponse;
class GetInterconnectionUrlHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetInterconnectionUrlHeaders = GetInterconnectionUrlHeaders;
class GetInterconnectionUrlRequest extends $tea.Model {
    static names() {
        return {
            appUserAvatar: 'appUserAvatar',
            appUserAvatarType: 'appUserAvatarType',
            appUserId: 'appUserId',
            appUserMobileNumber: 'appUserMobileNumber',
            appUserName: 'appUserName',
            msgPageType: 'msgPageType',
            qrCode: 'qrCode',
            signature: 'signature',
            sourceCode: 'sourceCode',
            sourceType: 'sourceType',
            userId: 'userId',
        };
    }
    static types() {
        return {
            appUserAvatar: 'string',
            appUserAvatarType: 'number',
            appUserId: 'string',
            appUserMobileNumber: 'string',
            appUserName: 'string',
            msgPageType: 'number',
            qrCode: 'string',
            signature: 'string',
            sourceCode: 'string',
            sourceType: 'number',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetInterconnectionUrlRequest = GetInterconnectionUrlRequest;
class GetInterconnectionUrlResponseBody extends $tea.Model {
    static names() {
        return {
            url: 'url',
        };
    }
    static types() {
        return {
            url: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetInterconnectionUrlResponseBody = GetInterconnectionUrlResponseBody;
class GetInterconnectionUrlResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetInterconnectionUrlResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetInterconnectionUrlResponse = GetInterconnectionUrlResponse;
class GetNewestInnerGroupsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNewestInnerGroupsHeaders = GetNewestInnerGroupsHeaders;
class GetNewestInnerGroupsRequest extends $tea.Model {
    static names() {
        return {
            userId: 'userId',
        };
    }
    static types() {
        return {
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNewestInnerGroupsRequest = GetNewestInnerGroupsRequest;
class GetNewestInnerGroupsResponseBody extends $tea.Model {
    static names() {
        return {
            groupInfos: 'groupInfos',
        };
    }
    static types() {
        return {
            groupInfos: { 'type': 'array', 'itemType': GetNewestInnerGroupsResponseBodyGroupInfos },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNewestInnerGroupsResponseBody = GetNewestInnerGroupsResponseBody;
class GetNewestInnerGroupsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetNewestInnerGroupsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNewestInnerGroupsResponse = GetNewestInnerGroupsResponse;
class GetSceneGroupInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSceneGroupInfoHeaders = GetSceneGroupInfoHeaders;
class GetSceneGroupInfoRequest extends $tea.Model {
    static names() {
        return {
            coolAppCode: 'coolAppCode',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            coolAppCode: 'string',
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSceneGroupInfoRequest = GetSceneGroupInfoRequest;
class GetSceneGroupInfoResponseBody extends $tea.Model {
    static names() {
        return {
            groupUrl: 'groupUrl',
            icon: 'icon',
            openConversationId: 'openConversationId',
            ownerUserId: 'ownerUserId',
            status: 'status',
            success: 'success',
            templateId: 'templateId',
            title: 'title',
        };
    }
    static types() {
        return {
            groupUrl: 'string',
            icon: 'string',
            openConversationId: 'string',
            ownerUserId: 'string',
            status: 'number',
            success: 'boolean',
            templateId: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSceneGroupInfoResponseBody = GetSceneGroupInfoResponseBody;
class GetSceneGroupInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSceneGroupInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSceneGroupInfoResponse = GetSceneGroupInfoResponse;
class GetSceneGroupMembersHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSceneGroupMembersHeaders = GetSceneGroupMembersHeaders;
class GetSceneGroupMembersRequest extends $tea.Model {
    static names() {
        return {
            coolAppCode: 'coolAppCode',
            cursor: 'cursor',
            openConversationId: 'openConversationId',
            size: 'size',
        };
    }
    static types() {
        return {
            coolAppCode: 'string',
            cursor: 'string',
            openConversationId: 'string',
            size: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSceneGroupMembersRequest = GetSceneGroupMembersRequest;
class GetSceneGroupMembersResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            memberUserIds: 'memberUserIds',
            nextCursor: 'nextCursor',
            success: 'success',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            memberUserIds: { 'type': 'array', 'itemType': 'string' },
            nextCursor: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSceneGroupMembersResponseBody = GetSceneGroupMembersResponseBody;
class GetSceneGroupMembersResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSceneGroupMembersResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSceneGroupMembersResponse = GetSceneGroupMembersResponse;
class GetSceneGroupTemplateMessageOpenStatusHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSceneGroupTemplateMessageOpenStatusHeaders = GetSceneGroupTemplateMessageOpenStatusHeaders;
class GetSceneGroupTemplateMessageOpenStatusResponseBody extends $tea.Model {
    static names() {
        return {
            status: 'status',
            success: 'success',
        };
    }
    static types() {
        return {
            status: 'number',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSceneGroupTemplateMessageOpenStatusResponseBody = GetSceneGroupTemplateMessageOpenStatusResponseBody;
class GetSceneGroupTemplateMessageOpenStatusResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSceneGroupTemplateMessageOpenStatusResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetSceneGroupTemplateMessageOpenStatusResponse = GetSceneGroupTemplateMessageOpenStatusResponse;
class GroupBanWordsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupBanWordsHeaders = GroupBanWordsHeaders;
class GroupBanWordsRequest extends $tea.Model {
    static names() {
        return {
            banWordsMode: 'banWordsMode',
            openConversationId: 'openConversationId',
            options: 'options',
        };
    }
    static types() {
        return {
            banWordsMode: 'number',
            openConversationId: 'string',
            options: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupBanWordsRequest = GroupBanWordsRequest;
class GroupBanWordsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupBanWordsResponse = GroupBanWordsResponse;
class GroupCapacityInquiryHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupCapacityInquiryHeaders = GroupCapacityInquiryHeaders;
class GroupCapacityInquiryRequest extends $tea.Model {
    static names() {
        return {
            effectiveDuration: 'effectiveDuration',
            openConversationId: 'openConversationId',
            operator: 'operator',
            options: 'options',
            targetCapacity: 'targetCapacity',
        };
    }
    static types() {
        return {
            effectiveDuration: 'string',
            openConversationId: 'string',
            operator: 'string',
            options: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            targetCapacity: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupCapacityInquiryRequest = GroupCapacityInquiryRequest;
class GroupCapacityInquiryResponseBody extends $tea.Model {
    static names() {
        return {
            actualPrice: 'actualPrice',
            createdAt: 'createdAt',
            currentCapacity: 'currentCapacity',
            currentEffectUntil: 'currentEffectUntil',
            discount: 'discount',
            extInfo: 'extInfo',
            groupOwner: 'groupOwner',
            groupTitle: 'groupTitle',
            markedPrice: 'markedPrice',
            memberCount: 'memberCount',
            openConversationId: 'openConversationId',
            operator: 'operator',
            targetCapacity: 'targetCapacity',
            targetEffectUntil: 'targetEffectUntil',
            token: 'token',
        };
    }
    static types() {
        return {
            actualPrice: 'number',
            createdAt: 'number',
            currentCapacity: 'number',
            currentEffectUntil: 'number',
            discount: 'number',
            extInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            groupOwner: 'string',
            groupTitle: 'string',
            markedPrice: 'number',
            memberCount: 'number',
            openConversationId: 'string',
            operator: 'string',
            targetCapacity: 'number',
            targetEffectUntil: 'number',
            token: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupCapacityInquiryResponseBody = GroupCapacityInquiryResponseBody;
class GroupCapacityInquiryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GroupCapacityInquiryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupCapacityInquiryResponse = GroupCapacityInquiryResponse;
class GroupCapacityOrderConfirmHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupCapacityOrderConfirmHeaders = GroupCapacityOrderConfirmHeaders;
class GroupCapacityOrderConfirmRequest extends $tea.Model {
    static names() {
        return {
            operator: 'operator',
            orderId: 'orderId',
        };
    }
    static types() {
        return {
            operator: 'string',
            orderId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupCapacityOrderConfirmRequest = GroupCapacityOrderConfirmRequest;
class GroupCapacityOrderConfirmResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupCapacityOrderConfirmResponseBody = GroupCapacityOrderConfirmResponseBody;
class GroupCapacityOrderConfirmResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GroupCapacityOrderConfirmResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupCapacityOrderConfirmResponse = GroupCapacityOrderConfirmResponse;
class GroupCapacityOrderPlaceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupCapacityOrderPlaceHeaders = GroupCapacityOrderPlaceHeaders;
class GroupCapacityOrderPlaceRequest extends $tea.Model {
    static names() {
        return {
            actualPrice: 'actualPrice',
            currentCapacity: 'currentCapacity',
            currentEffectUntil: 'currentEffectUntil',
            discount: 'discount',
            extInfo: 'extInfo',
            markedPrice: 'markedPrice',
            openConversationId: 'openConversationId',
            operator: 'operator',
            targetCapacity: 'targetCapacity',
            targetEffectUntil: 'targetEffectUntil',
            token: 'token',
        };
    }
    static types() {
        return {
            actualPrice: 'number',
            currentCapacity: 'number',
            currentEffectUntil: 'number',
            discount: 'number',
            extInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            markedPrice: 'number',
            openConversationId: 'string',
            operator: 'string',
            targetCapacity: 'number',
            targetEffectUntil: 'number',
            token: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupCapacityOrderPlaceRequest = GroupCapacityOrderPlaceRequest;
class GroupCapacityOrderPlaceResponseBody extends $tea.Model {
    static names() {
        return {
            actualPrice: 'actualPrice',
            currentCapacity: 'currentCapacity',
            currentEffectUntil: 'currentEffectUntil',
            discount: 'discount',
            extInfo: 'extInfo',
            markedPrice: 'markedPrice',
            openConversationId: 'openConversationId',
            operator: 'operator',
            orderId: 'orderId',
            targetCapacity: 'targetCapacity',
            targetEffectUntil: 'targetEffectUntil',
            token: 'token',
        };
    }
    static types() {
        return {
            actualPrice: 'number',
            currentCapacity: 'number',
            currentEffectUntil: 'number',
            discount: 'number',
            extInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            markedPrice: 'number',
            openConversationId: 'string',
            operator: 'string',
            orderId: 'string',
            targetCapacity: 'number',
            targetEffectUntil: 'number',
            token: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupCapacityOrderPlaceResponseBody = GroupCapacityOrderPlaceResponseBody;
class GroupCapacityOrderPlaceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GroupCapacityOrderPlaceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupCapacityOrderPlaceResponse = GroupCapacityOrderPlaceResponse;
class GroupManageQueryHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupManageQueryHeaders = GroupManageQueryHeaders;
class GroupManageQueryRequest extends $tea.Model {
    static names() {
        return {
            createdAfter: 'createdAfter',
            groupId: 'groupId',
            groupMemberSamples: 'groupMemberSamples',
            groupOwner: 'groupOwner',
            groupTitleKeywords: 'groupTitleKeywords',
            groupUrl: 'groupUrl',
            maxResults: 'maxResults',
            membersOver: 'membersOver',
            nextToken: 'nextToken',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            createdAfter: 'number',
            groupId: 'string',
            groupMemberSamples: { 'type': 'array', 'itemType': 'string' },
            groupOwner: 'string',
            groupTitleKeywords: { 'type': 'array', 'itemType': 'string' },
            groupUrl: 'string',
            maxResults: 'number',
            membersOver: 'number',
            nextToken: 'string',
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupManageQueryRequest = GroupManageQueryRequest;
class GroupManageQueryResponseBody extends $tea.Model {
    static names() {
        return {
            groupInfoList: 'groupInfoList',
            hasMore: 'hasMore',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            groupInfoList: { 'type': 'array', 'itemType': GroupManageQueryResponseBodyGroupInfoList },
            hasMore: 'boolean',
            nextToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupManageQueryResponseBody = GroupManageQueryResponseBody;
class GroupManageQueryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GroupManageQueryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupManageQueryResponse = GroupManageQueryResponse;
class GroupManageReduceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupManageReduceHeaders = GroupManageReduceHeaders;
class GroupManageReduceRequest extends $tea.Model {
    static names() {
        return {
            capacityLimit: 'capacityLimit',
            openConversationId: 'openConversationId',
            options: 'options',
        };
    }
    static types() {
        return {
            capacityLimit: 'number',
            openConversationId: 'string',
            options: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupManageReduceRequest = GroupManageReduceRequest;
class GroupManageReduceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupManageReduceResponse = GroupManageReduceResponse;
class InstallRobotToOrgHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InstallRobotToOrgHeaders = InstallRobotToOrgHeaders;
class InstallRobotToOrgRequest extends $tea.Model {
    static names() {
        return {
            brief: 'brief',
            description: 'description',
            icon: 'icon',
            name: 'name',
            outgoingToken: 'outgoingToken',
            outgoingUrl: 'outgoingUrl',
            previewMediaId: 'previewMediaId',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            brief: 'string',
            description: 'string',
            icon: 'string',
            name: 'string',
            outgoingToken: 'string',
            outgoingUrl: 'string',
            previewMediaId: 'string',
            robotCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InstallRobotToOrgRequest = InstallRobotToOrgRequest;
class InstallRobotToOrgResponseBody extends $tea.Model {
    static names() {
        return {
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            robotCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InstallRobotToOrgResponseBody = InstallRobotToOrgResponseBody;
class InstallRobotToOrgResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: InstallRobotToOrgResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InstallRobotToOrgResponse = InstallRobotToOrgResponse;
class InteractiveCardCreateInstanceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InteractiveCardCreateInstanceHeaders = InteractiveCardCreateInstanceHeaders;
class InteractiveCardCreateInstanceRequest extends $tea.Model {
    static names() {
        return {
            callbackRouteKey: 'callbackRouteKey',
            cardData: 'cardData',
            cardTemplateId: 'cardTemplateId',
            chatBotId: 'chatBotId',
            conversationType: 'conversationType',
            openConversationId: 'openConversationId',
            outTrackId: 'outTrackId',
            privateData: 'privateData',
            pullStrategy: 'pullStrategy',
            receiverUserIdList: 'receiverUserIdList',
            robotCode: 'robotCode',
            userIdType: 'userIdType',
        };
    }
    static types() {
        return {
            callbackRouteKey: 'string',
            cardData: InteractiveCardCreateInstanceRequestCardData,
            cardTemplateId: 'string',
            chatBotId: 'string',
            conversationType: 'number',
            openConversationId: 'string',
            outTrackId: 'string',
            privateData: { 'type': 'map', 'keyType': 'string', 'valueType': PrivateDataValue },
            pullStrategy: 'boolean',
            receiverUserIdList: { 'type': 'array', 'itemType': 'string' },
            robotCode: 'string',
            userIdType: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InteractiveCardCreateInstanceRequest = InteractiveCardCreateInstanceRequest;
class InteractiveCardCreateInstanceResponseBody extends $tea.Model {
    static names() {
        return {
            processQueryKey: 'processQueryKey',
        };
    }
    static types() {
        return {
            processQueryKey: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InteractiveCardCreateInstanceResponseBody = InteractiveCardCreateInstanceResponseBody;
class InteractiveCardCreateInstanceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: InteractiveCardCreateInstanceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InteractiveCardCreateInstanceResponse = InteractiveCardCreateInstanceResponse;
class ListGroupTemplatesByOrgIdHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListGroupTemplatesByOrgIdHeaders = ListGroupTemplatesByOrgIdHeaders;
class ListGroupTemplatesByOrgIdRequest extends $tea.Model {
    static names() {
        return {
            pageNumber: 'pageNumber',
            pageSize: 'pageSize',
        };
    }
    static types() {
        return {
            pageNumber: 'number',
            pageSize: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListGroupTemplatesByOrgIdRequest = ListGroupTemplatesByOrgIdRequest;
class ListGroupTemplatesByOrgIdResponseBody extends $tea.Model {
    static names() {
        return {
            count: 'count',
            sceneGroupDetailModels: 'sceneGroupDetailModels',
            success: 'success',
        };
    }
    static types() {
        return {
            count: 'number',
            sceneGroupDetailModels: { 'type': 'array', 'itemType': ListGroupTemplatesByOrgIdResponseBodySceneGroupDetailModels },
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListGroupTemplatesByOrgIdResponseBody = ListGroupTemplatesByOrgIdResponseBody;
class ListGroupTemplatesByOrgIdResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListGroupTemplatesByOrgIdResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListGroupTemplatesByOrgIdResponse = ListGroupTemplatesByOrgIdResponse;
class ListOrgTextEmotionHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListOrgTextEmotionHeaders = ListOrgTextEmotionHeaders;
class ListOrgTextEmotionResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: ListOrgTextEmotionResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListOrgTextEmotionResponseBody = ListOrgTextEmotionResponseBody;
class ListOrgTextEmotionResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListOrgTextEmotionResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListOrgTextEmotionResponse = ListOrgTextEmotionResponse;
class ListSceneGroupsByTemplateIdHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListSceneGroupsByTemplateIdHeaders = ListSceneGroupsByTemplateIdHeaders;
class ListSceneGroupsByTemplateIdRequest extends $tea.Model {
    static names() {
        return {
            pageNumber: 'pageNumber',
            pageSize: 'pageSize',
        };
    }
    static types() {
        return {
            pageNumber: 'number',
            pageSize: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListSceneGroupsByTemplateIdRequest = ListSceneGroupsByTemplateIdRequest;
class ListSceneGroupsByTemplateIdResponseBody extends $tea.Model {
    static names() {
        return {
            openConversationIds: 'openConversationIds',
            success: 'success',
        };
    }
    static types() {
        return {
            openConversationIds: { 'type': 'array', 'itemType': 'string' },
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListSceneGroupsByTemplateIdResponseBody = ListSceneGroupsByTemplateIdResponseBody;
class ListSceneGroupsByTemplateIdResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListSceneGroupsByTemplateIdResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListSceneGroupsByTemplateIdResponse = ListSceneGroupsByTemplateIdResponse;
class OfflineUnfurlingRegisterHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OfflineUnfurlingRegisterHeaders = OfflineUnfurlingRegisterHeaders;
class OfflineUnfurlingRegisterRequest extends $tea.Model {
    static names() {
        return {
            appId: 'appId',
            id: 'id',
            userId: 'userId',
        };
    }
    static types() {
        return {
            appId: 'string',
            id: 'number',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OfflineUnfurlingRegisterRequest = OfflineUnfurlingRegisterRequest;
class OfflineUnfurlingRegisterResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OfflineUnfurlingRegisterResponseBody = OfflineUnfurlingRegisterResponseBody;
class OfflineUnfurlingRegisterResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: OfflineUnfurlingRegisterResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OfflineUnfurlingRegisterResponse = OfflineUnfurlingRegisterResponse;
class OpenGroupRoleAddHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupRoleAddHeaders = OpenGroupRoleAddHeaders;
class OpenGroupRoleAddRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            roleName: 'roleName',
            userId: 'userId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            roleName: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupRoleAddRequest = OpenGroupRoleAddRequest;
class OpenGroupRoleAddResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: OpenGroupRoleAddResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupRoleAddResponseBody = OpenGroupRoleAddResponseBody;
class OpenGroupRoleAddResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: OpenGroupRoleAddResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupRoleAddResponse = OpenGroupRoleAddResponse;
class OpenGroupRoleQueryHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupRoleQueryHeaders = OpenGroupRoleQueryHeaders;
class OpenGroupRoleQueryRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupRoleQueryRequest = OpenGroupRoleQueryRequest;
class OpenGroupRoleQueryResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: OpenGroupRoleQueryResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupRoleQueryResponseBody = OpenGroupRoleQueryResponseBody;
class OpenGroupRoleQueryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: OpenGroupRoleQueryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupRoleQueryResponse = OpenGroupRoleQueryResponse;
class OpenGroupRoleRemoveHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupRoleRemoveHeaders = OpenGroupRoleRemoveHeaders;
class OpenGroupRoleRemoveRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            openRoleId: 'openRoleId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            openRoleId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupRoleRemoveRequest = OpenGroupRoleRemoveRequest;
class OpenGroupRoleRemoveResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupRoleRemoveResponseBody = OpenGroupRoleRemoveResponseBody;
class OpenGroupRoleRemoveResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: OpenGroupRoleRemoveResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupRoleRemoveResponse = OpenGroupRoleRemoveResponse;
class OpenGroupRoleUpdateHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupRoleUpdateHeaders = OpenGroupRoleUpdateHeaders;
class OpenGroupRoleUpdateRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            openRoleId: 'openRoleId',
            roleName: 'roleName',
            userId: 'userId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            openRoleId: 'string',
            roleName: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupRoleUpdateRequest = OpenGroupRoleUpdateRequest;
class OpenGroupRoleUpdateResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: 'boolean',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupRoleUpdateResponseBody = OpenGroupRoleUpdateResponseBody;
class OpenGroupRoleUpdateResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: OpenGroupRoleUpdateResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupRoleUpdateResponse = OpenGroupRoleUpdateResponse;
class OpenGroupUserRoleQueryHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupUserRoleQueryHeaders = OpenGroupUserRoleQueryHeaders;
class OpenGroupUserRoleQueryRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            userId: 'userId',
            viewedUserId: 'viewedUserId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            userId: 'string',
            viewedUserId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupUserRoleQueryRequest = OpenGroupUserRoleQueryRequest;
class OpenGroupUserRoleQueryResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: OpenGroupUserRoleQueryResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupUserRoleQueryResponseBody = OpenGroupUserRoleQueryResponseBody;
class OpenGroupUserRoleQueryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: OpenGroupUserRoleQueryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupUserRoleQueryResponse = OpenGroupUserRoleQueryResponse;
class OpenInnerGroupTransferToDeptGroupHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenInnerGroupTransferToDeptGroupHeaders = OpenInnerGroupTransferToDeptGroupHeaders;
class OpenInnerGroupTransferToDeptGroupRequest extends $tea.Model {
    static names() {
        return {
            deptId: 'deptId',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            deptId: 'number',
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenInnerGroupTransferToDeptGroupRequest = OpenInnerGroupTransferToDeptGroupRequest;
class OpenInnerGroupTransferToDeptGroupResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenInnerGroupTransferToDeptGroupResponseBody = OpenInnerGroupTransferToDeptGroupResponseBody;
class OpenInnerGroupTransferToDeptGroupResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: OpenInnerGroupTransferToDeptGroupResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenInnerGroupTransferToDeptGroupResponse = OpenInnerGroupTransferToDeptGroupResponse;
class OpenSearchGroupListHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenSearchGroupListHeaders = OpenSearchGroupListHeaders;
class OpenSearchGroupListRequest extends $tea.Model {
    static names() {
        return {
            keyword: 'keyword',
            userId: 'userId',
        };
    }
    static types() {
        return {
            keyword: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenSearchGroupListRequest = OpenSearchGroupListRequest;
class OpenSearchGroupListResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: OpenSearchGroupListResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenSearchGroupListResponseBody = OpenSearchGroupListResponseBody;
class OpenSearchGroupListResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: OpenSearchGroupListResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenSearchGroupListResponse = OpenSearchGroupListResponse;
class OpenUserSendCardMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenUserSendCardMessageHeaders = OpenUserSendCardMessageHeaders;
class OpenUserSendCardMessageRequest extends $tea.Model {
    static names() {
        return {
            cardContent: 'cardContent',
            openConversationId: 'openConversationId',
            receiveUserId: 'receiveUserId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            cardContent: OpenUserSendCardMessageRequestCardContent,
            openConversationId: 'string',
            receiveUserId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenUserSendCardMessageRequest = OpenUserSendCardMessageRequest;
class OpenUserSendCardMessageResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: OpenUserSendCardMessageResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenUserSendCardMessageResponseBody = OpenUserSendCardMessageResponseBody;
class OpenUserSendCardMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: OpenUserSendCardMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenUserSendCardMessageResponse = OpenUserSendCardMessageResponse;
class PersonalSendCardMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PersonalSendCardMessageHeaders = PersonalSendCardMessageHeaders;
class PersonalSendCardMessageRequest extends $tea.Model {
    static names() {
        return {
            atUserIds: 'atUserIds',
            cardContent: 'cardContent',
            openConversationId: 'openConversationId',
            receiveUserId: 'receiveUserId',
        };
    }
    static types() {
        return {
            atUserIds: { 'type': 'array', 'itemType': 'string' },
            cardContent: PersonalSendCardMessageRequestCardContent,
            openConversationId: 'string',
            receiveUserId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PersonalSendCardMessageRequest = PersonalSendCardMessageRequest;
class PersonalSendCardMessageResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: PersonalSendCardMessageResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PersonalSendCardMessageResponseBody = PersonalSendCardMessageResponseBody;
class PersonalSendCardMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PersonalSendCardMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PersonalSendCardMessageResponse = PersonalSendCardMessageResponse;
class QueryGroupInfoByMemberAuthHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupInfoByMemberAuthHeaders = QueryGroupInfoByMemberAuthHeaders;
class QueryGroupInfoByMemberAuthRequest extends $tea.Model {
    static names() {
        return {
            coolAppCode: 'coolAppCode',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            coolAppCode: 'string',
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupInfoByMemberAuthRequest = QueryGroupInfoByMemberAuthRequest;
class QueryGroupInfoByMemberAuthResponseBody extends $tea.Model {
    static names() {
        return {
            memberCount: 'memberCount',
        };
    }
    static types() {
        return {
            memberCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupInfoByMemberAuthResponseBody = QueryGroupInfoByMemberAuthResponseBody;
class QueryGroupInfoByMemberAuthResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryGroupInfoByMemberAuthResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupInfoByMemberAuthResponse = QueryGroupInfoByMemberAuthResponse;
class QueryGroupMemberHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMemberHeaders = QueryGroupMemberHeaders;
class QueryGroupMemberRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMemberRequest = QueryGroupMemberRequest;
class QueryGroupMemberResponseBody extends $tea.Model {
    static names() {
        return {
            groupMembers: 'groupMembers',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            groupMembers: { 'type': 'array', 'itemType': QueryGroupMemberResponseBodyGroupMembers },
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMemberResponseBody = QueryGroupMemberResponseBody;
class QueryGroupMemberResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryGroupMemberResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMemberResponse = QueryGroupMemberResponse;
class QueryGroupMemberByMemberAuthHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMemberByMemberAuthHeaders = QueryGroupMemberByMemberAuthHeaders;
class QueryGroupMemberByMemberAuthRequest extends $tea.Model {
    static names() {
        return {
            coolAppCode: 'coolAppCode',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            coolAppCode: 'string',
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMemberByMemberAuthRequest = QueryGroupMemberByMemberAuthRequest;
class QueryGroupMemberByMemberAuthResponseBody extends $tea.Model {
    static names() {
        return {
            groupMemberList: 'groupMemberList',
        };
    }
    static types() {
        return {
            groupMemberList: { 'type': 'array', 'itemType': QueryGroupMemberByMemberAuthResponseBodyGroupMemberList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMemberByMemberAuthResponseBody = QueryGroupMemberByMemberAuthResponseBody;
class QueryGroupMemberByMemberAuthResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryGroupMemberByMemberAuthResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMemberByMemberAuthResponse = QueryGroupMemberByMemberAuthResponse;
class QueryGroupMuteStatusHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMuteStatusHeaders = QueryGroupMuteStatusHeaders;
class QueryGroupMuteStatusRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMuteStatusRequest = QueryGroupMuteStatusRequest;
class QueryGroupMuteStatusResponseBody extends $tea.Model {
    static names() {
        return {
            groupMuteMode: 'groupMuteMode',
            userMuteResult: 'userMuteResult',
        };
    }
    static types() {
        return {
            groupMuteMode: 'boolean',
            userMuteResult: QueryGroupMuteStatusResponseBodyUserMuteResult,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMuteStatusResponseBody = QueryGroupMuteStatusResponseBody;
class QueryGroupMuteStatusResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryGroupMuteStatusResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMuteStatusResponse = QueryGroupMuteStatusResponse;
class QueryInnerGroupMemberListHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryInnerGroupMemberListHeaders = QueryInnerGroupMemberListHeaders;
class QueryInnerGroupMemberListRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            openConversationId: 'openConversationId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'number',
            openConversationId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryInnerGroupMemberListRequest = QueryInnerGroupMemberListRequest;
class QueryInnerGroupMemberListResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            list: 'list',
            nextToken: 'nextToken',
            success: 'success',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            list: { 'type': 'array', 'itemType': QueryInnerGroupMemberListResponseBodyList },
            nextToken: 'number',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryInnerGroupMemberListResponseBody = QueryInnerGroupMemberListResponseBody;
class QueryInnerGroupMemberListResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryInnerGroupMemberListResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryInnerGroupMemberListResponse = QueryInnerGroupMemberListResponse;
class QueryInnerGroupRecentListHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryInnerGroupRecentListHeaders = QueryInnerGroupRecentListHeaders;
class QueryInnerGroupRecentListRequest extends $tea.Model {
    static names() {
        return {
            userId: 'userId',
        };
    }
    static types() {
        return {
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryInnerGroupRecentListRequest = QueryInnerGroupRecentListRequest;
class QueryInnerGroupRecentListResponseBody extends $tea.Model {
    static names() {
        return {
            groupInfos: 'groupInfos',
            success: 'success',
        };
    }
    static types() {
        return {
            groupInfos: { 'type': 'array', 'itemType': QueryInnerGroupRecentListResponseBodyGroupInfos },
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryInnerGroupRecentListResponseBody = QueryInnerGroupRecentListResponseBody;
class QueryInnerGroupRecentListResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryInnerGroupRecentListResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryInnerGroupRecentListResponse = QueryInnerGroupRecentListResponse;
class QueryMembersOfGroupRoleHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMembersOfGroupRoleHeaders = QueryMembersOfGroupRoleHeaders;
class QueryMembersOfGroupRoleRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            openRoleId: 'openRoleId',
            timestamp: 'timestamp',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            openRoleId: 'string',
            timestamp: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMembersOfGroupRoleRequest = QueryMembersOfGroupRoleRequest;
class QueryMembersOfGroupRoleResponseBody extends $tea.Model {
    static names() {
        return {
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMembersOfGroupRoleResponseBody = QueryMembersOfGroupRoleResponseBody;
class QueryMembersOfGroupRoleResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryMembersOfGroupRoleResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMembersOfGroupRoleResponse = QueryMembersOfGroupRoleResponse;
class QueryMessageSendResultHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMessageSendResultHeaders = QueryMessageSendResultHeaders;
class QueryMessageSendResultRequest extends $tea.Model {
    static names() {
        return {
            openTaskId: 'openTaskId',
        };
    }
    static types() {
        return {
            openTaskId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMessageSendResultRequest = QueryMessageSendResultRequest;
class QueryMessageSendResultResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: QueryMessageSendResultResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMessageSendResultResponseBody = QueryMessageSendResultResponseBody;
class QueryMessageSendResultResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryMessageSendResultResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMessageSendResultResponse = QueryMessageSendResultResponse;
class QueryOpenConversationReceiveUserHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryOpenConversationReceiveUserHeaders = QueryOpenConversationReceiveUserHeaders;
class QueryOpenConversationReceiveUserRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            sendUserId: 'sendUserId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            sendUserId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryOpenConversationReceiveUserRequest = QueryOpenConversationReceiveUserRequest;
class QueryOpenConversationReceiveUserResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: QueryOpenConversationReceiveUserResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryOpenConversationReceiveUserResponseBody = QueryOpenConversationReceiveUserResponseBody;
class QueryOpenConversationReceiveUserResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryOpenConversationReceiveUserResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryOpenConversationReceiveUserResponse = QueryOpenConversationReceiveUserResponse;
class QueryOpenGroupBaseInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryOpenGroupBaseInfoHeaders = QueryOpenGroupBaseInfoHeaders;
class QueryOpenGroupBaseInfoRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryOpenGroupBaseInfoRequest = QueryOpenGroupBaseInfoRequest;
class QueryOpenGroupBaseInfoResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: QueryOpenGroupBaseInfoResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryOpenGroupBaseInfoResponseBody = QueryOpenGroupBaseInfoResponseBody;
class QueryOpenGroupBaseInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryOpenGroupBaseInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryOpenGroupBaseInfoResponse = QueryOpenGroupBaseInfoResponse;
class QueryPersonalMessageReadStatusHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryPersonalMessageReadStatusHeaders = QueryPersonalMessageReadStatusHeaders;
class QueryPersonalMessageReadStatusRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            openMessageId: 'openMessageId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            openMessageId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryPersonalMessageReadStatusRequest = QueryPersonalMessageReadStatusRequest;
class QueryPersonalMessageReadStatusResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: QueryPersonalMessageReadStatusResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryPersonalMessageReadStatusResponseBody = QueryPersonalMessageReadStatusResponseBody;
class QueryPersonalMessageReadStatusResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryPersonalMessageReadStatusResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryPersonalMessageReadStatusResponse = QueryPersonalMessageReadStatusResponse;
class QueryRecentConversationsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryRecentConversationsHeaders = QueryRecentConversationsHeaders;
class QueryRecentConversationsRequest extends $tea.Model {
    static names() {
        return {
            onlyHuman: 'onlyHuman',
            onlyInnerGroup: 'onlyInnerGroup',
            userId: 'userId',
        };
    }
    static types() {
        return {
            onlyHuman: 'boolean',
            onlyInnerGroup: 'boolean',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryRecentConversationsRequest = QueryRecentConversationsRequest;
class QueryRecentConversationsResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: QueryRecentConversationsResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryRecentConversationsResponseBody = QueryRecentConversationsResponseBody;
class QueryRecentConversationsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryRecentConversationsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryRecentConversationsResponse = QueryRecentConversationsResponse;
class QuerySceneGroupTemplateRobotHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySceneGroupTemplateRobotHeaders = QuerySceneGroupTemplateRobotHeaders;
class QuerySceneGroupTemplateRobotRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            robotCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySceneGroupTemplateRobotRequest = QuerySceneGroupTemplateRobotRequest;
class QuerySceneGroupTemplateRobotResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: QuerySceneGroupTemplateRobotResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySceneGroupTemplateRobotResponseBody = QuerySceneGroupTemplateRobotResponseBody;
class QuerySceneGroupTemplateRobotResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySceneGroupTemplateRobotResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySceneGroupTemplateRobotResponse = QuerySceneGroupTemplateRobotResponse;
class QuerySingleGroupHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySingleGroupHeaders = QuerySingleGroupHeaders;
class QuerySingleGroupRequest extends $tea.Model {
    static names() {
        return {
            groupMembers: 'groupMembers',
            groupTemplateId: 'groupTemplateId',
        };
    }
    static types() {
        return {
            groupMembers: { 'type': 'array', 'itemType': QuerySingleGroupRequestGroupMembers },
            groupTemplateId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySingleGroupRequest = QuerySingleGroupRequest;
class QuerySingleGroupResponseBody extends $tea.Model {
    static names() {
        return {
            openConversations: 'openConversations',
        };
    }
    static types() {
        return {
            openConversations: { 'type': 'array', 'itemType': QuerySingleGroupResponseBodyOpenConversations },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySingleGroupResponseBody = QuerySingleGroupResponseBody;
class QuerySingleGroupResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QuerySingleGroupResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySingleGroupResponse = QuerySingleGroupResponse;
class QueryUnReadMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUnReadMessageHeaders = QueryUnReadMessageHeaders;
class QueryUnReadMessageRequest extends $tea.Model {
    static names() {
        return {
            appUserId: 'appUserId',
            openConversationIds: 'openConversationIds',
        };
    }
    static types() {
        return {
            appUserId: 'string',
            openConversationIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUnReadMessageRequest = QueryUnReadMessageRequest;
class QueryUnReadMessageResponseBody extends $tea.Model {
    static names() {
        return {
            unReadCount: 'unReadCount',
            unReadItems: 'unReadItems',
        };
    }
    static types() {
        return {
            unReadCount: 'number',
            unReadItems: { 'type': 'array', 'itemType': QueryUnReadMessageResponseBodyUnReadItems },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUnReadMessageResponseBody = QueryUnReadMessageResponseBody;
class QueryUnReadMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryUnReadMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUnReadMessageResponse = QueryUnReadMessageResponse;
class QueryUnfurlingRegisterCreatorHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUnfurlingRegisterCreatorHeaders = QueryUnfurlingRegisterCreatorHeaders;
class QueryUnfurlingRegisterCreatorRequest extends $tea.Model {
    static names() {
        return {
            domain: 'domain',
            path: 'path',
        };
    }
    static types() {
        return {
            domain: 'string',
            path: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUnfurlingRegisterCreatorRequest = QueryUnfurlingRegisterCreatorRequest;
class QueryUnfurlingRegisterCreatorResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            success: 'success',
        };
    }
    static types() {
        return {
            data: QueryUnfurlingRegisterCreatorResponseBodyData,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUnfurlingRegisterCreatorResponseBody = QueryUnfurlingRegisterCreatorResponseBody;
class QueryUnfurlingRegisterCreatorResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryUnfurlingRegisterCreatorResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUnfurlingRegisterCreatorResponse = QueryUnfurlingRegisterCreatorResponse;
class QueryUnfurlingRegisterInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUnfurlingRegisterInfoHeaders = QueryUnfurlingRegisterInfoHeaders;
class QueryUnfurlingRegisterInfoRequest extends $tea.Model {
    static names() {
        return {
            appId: 'appId',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            appId: 'string',
            maxResults: 'number',
            nextToken: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUnfurlingRegisterInfoRequest = QueryUnfurlingRegisterInfoRequest;
class QueryUnfurlingRegisterInfoResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            list: 'list',
            nextToken: 'nextToken',
            success: 'success',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            list: { 'type': 'array', 'itemType': QueryUnfurlingRegisterInfoResponseBodyList },
            nextToken: 'number',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUnfurlingRegisterInfoResponseBody = QueryUnfurlingRegisterInfoResponseBody;
class QueryUnfurlingRegisterInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryUnfurlingRegisterInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUnfurlingRegisterInfoResponse = QueryUnfurlingRegisterInfoResponse;
class ReleaseUnfurlingRegisterHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ReleaseUnfurlingRegisterHeaders = ReleaseUnfurlingRegisterHeaders;
class ReleaseUnfurlingRegisterRequest extends $tea.Model {
    static names() {
        return {
            appId: 'appId',
            id: 'id',
            userId: 'userId',
        };
    }
    static types() {
        return {
            appId: 'string',
            id: 'number',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ReleaseUnfurlingRegisterRequest = ReleaseUnfurlingRegisterRequest;
class ReleaseUnfurlingRegisterResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ReleaseUnfurlingRegisterResponseBody = ReleaseUnfurlingRegisterResponseBody;
class ReleaseUnfurlingRegisterResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ReleaseUnfurlingRegisterResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ReleaseUnfurlingRegisterResponse = ReleaseUnfurlingRegisterResponse;
class RemoveRobotFromConversationHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RemoveRobotFromConversationHeaders = RemoveRobotFromConversationHeaders;
class RemoveRobotFromConversationRequest extends $tea.Model {
    static names() {
        return {
            chatBotUserId: 'chatBotUserId',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            chatBotUserId: 'string',
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RemoveRobotFromConversationRequest = RemoveRobotFromConversationRequest;
class RemoveRobotFromConversationResponseBody extends $tea.Model {
    static names() {
        return {
            chatBotUserId: 'chatBotUserId',
        };
    }
    static types() {
        return {
            chatBotUserId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RemoveRobotFromConversationResponseBody = RemoveRobotFromConversationResponseBody;
class RemoveRobotFromConversationResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RemoveRobotFromConversationResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RemoveRobotFromConversationResponse = RemoveRobotFromConversationResponse;
class SearchInnerGroupsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SearchInnerGroupsHeaders = SearchInnerGroupsHeaders;
class SearchInnerGroupsRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            searchKey: 'searchKey',
            userId: 'userId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            searchKey: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SearchInnerGroupsRequest = SearchInnerGroupsRequest;
class SearchInnerGroupsResponseBody extends $tea.Model {
    static names() {
        return {
            groupInfos: 'groupInfos',
        };
    }
    static types() {
        return {
            groupInfos: { 'type': 'array', 'itemType': SearchInnerGroupsResponseBodyGroupInfos },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SearchInnerGroupsResponseBody = SearchInnerGroupsResponseBody;
class SearchInnerGroupsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SearchInnerGroupsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SearchInnerGroupsResponse = SearchInnerGroupsResponse;
class SendInteractiveCardHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendInteractiveCardHeaders = SendInteractiveCardHeaders;
class SendInteractiveCardRequest extends $tea.Model {
    static names() {
        return {
            atOpenIds: 'atOpenIds',
            callbackRouteKey: 'callbackRouteKey',
            cardData: 'cardData',
            cardOptions: 'cardOptions',
            cardTemplateId: 'cardTemplateId',
            chatBotId: 'chatBotId',
            conversationType: 'conversationType',
            digitalWorkerCode: 'digitalWorkerCode',
            openConversationId: 'openConversationId',
            outTrackId: 'outTrackId',
            privateData: 'privateData',
            pullStrategy: 'pullStrategy',
            receiverUserIdList: 'receiverUserIdList',
            robotCode: 'robotCode',
            userIdType: 'userIdType',
        };
    }
    static types() {
        return {
            atOpenIds: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            callbackRouteKey: 'string',
            cardData: SendInteractiveCardRequestCardData,
            cardOptions: SendInteractiveCardRequestCardOptions,
            cardTemplateId: 'string',
            chatBotId: 'string',
            conversationType: 'number',
            digitalWorkerCode: 'string',
            openConversationId: 'string',
            outTrackId: 'string',
            privateData: { 'type': 'map', 'keyType': 'string', 'valueType': PrivateDataValue },
            pullStrategy: 'boolean',
            receiverUserIdList: { 'type': 'array', 'itemType': 'string' },
            robotCode: 'string',
            userIdType: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendInteractiveCardRequest = SendInteractiveCardRequest;
class SendInteractiveCardResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: SendInteractiveCardResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendInteractiveCardResponseBody = SendInteractiveCardResponseBody;
class SendInteractiveCardResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendInteractiveCardResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendInteractiveCardResponse = SendInteractiveCardResponse;
class SendOTOInteractiveCardHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendOTOInteractiveCardHeaders = SendOTOInteractiveCardHeaders;
class SendOTOInteractiveCardRequest extends $tea.Model {
    static names() {
        return {
            atOpenIds: 'atOpenIds',
            callbackRouteKey: 'callbackRouteKey',
            cardData: 'cardData',
            cardOptions: 'cardOptions',
            cardTemplateId: 'cardTemplateId',
            openConversationId: 'openConversationId',
            outTrackId: 'outTrackId',
            privateData: 'privateData',
            pullStrategy: 'pullStrategy',
            receiverUserIdList: 'receiverUserIdList',
            robotCode: 'robotCode',
            userIdType: 'userIdType',
        };
    }
    static types() {
        return {
            atOpenIds: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            callbackRouteKey: 'string',
            cardData: SendOTOInteractiveCardRequestCardData,
            cardOptions: SendOTOInteractiveCardRequestCardOptions,
            cardTemplateId: 'string',
            openConversationId: 'string',
            outTrackId: 'string',
            privateData: { 'type': 'map', 'keyType': 'string', 'valueType': PrivateDataValue },
            pullStrategy: 'boolean',
            receiverUserIdList: { 'type': 'array', 'itemType': 'string' },
            robotCode: 'string',
            userIdType: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendOTOInteractiveCardRequest = SendOTOInteractiveCardRequest;
class SendOTOInteractiveCardResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: SendOTOInteractiveCardResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendOTOInteractiveCardResponseBody = SendOTOInteractiveCardResponseBody;
class SendOTOInteractiveCardResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendOTOInteractiveCardResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendOTOInteractiveCardResponse = SendOTOInteractiveCardResponse;
class SendPersonalMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendPersonalMessageHeaders = SendPersonalMessageHeaders;
class SendPersonalMessageRequest extends $tea.Model {
    static names() {
        return {
            content: 'content',
            msgType: 'msgType',
            openConversationId: 'openConversationId',
            receiverUid: 'receiverUid',
        };
    }
    static types() {
        return {
            content: 'string',
            msgType: 'string',
            openConversationId: 'string',
            receiverUid: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendPersonalMessageRequest = SendPersonalMessageRequest;
class SendPersonalMessageResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: SendPersonalMessageResponseBodyResult,
            success: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendPersonalMessageResponseBody = SendPersonalMessageResponseBody;
class SendPersonalMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendPersonalMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendPersonalMessageResponse = SendPersonalMessageResponse;
class SendRobotInteractiveCardHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendRobotInteractiveCardHeaders = SendRobotInteractiveCardHeaders;
class SendRobotInteractiveCardRequest extends $tea.Model {
    static names() {
        return {
            callbackUrl: 'callbackUrl',
            cardBizId: 'cardBizId',
            cardData: 'cardData',
            cardTemplateId: 'cardTemplateId',
            openConversationId: 'openConversationId',
            pullStrategy: 'pullStrategy',
            robotCode: 'robotCode',
            sendOptions: 'sendOptions',
            singleChatReceiver: 'singleChatReceiver',
            unionIdPrivateDataMap: 'unionIdPrivateDataMap',
            userIdPrivateDataMap: 'userIdPrivateDataMap',
        };
    }
    static types() {
        return {
            callbackUrl: 'string',
            cardBizId: 'string',
            cardData: 'string',
            cardTemplateId: 'string',
            openConversationId: 'string',
            pullStrategy: 'boolean',
            robotCode: 'string',
            sendOptions: SendRobotInteractiveCardRequestSendOptions,
            singleChatReceiver: 'string',
            unionIdPrivateDataMap: 'string',
            userIdPrivateDataMap: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendRobotInteractiveCardRequest = SendRobotInteractiveCardRequest;
class SendRobotInteractiveCardResponseBody extends $tea.Model {
    static names() {
        return {
            processQueryKey: 'processQueryKey',
        };
    }
    static types() {
        return {
            processQueryKey: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendRobotInteractiveCardResponseBody = SendRobotInteractiveCardResponseBody;
class SendRobotInteractiveCardResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendRobotInteractiveCardResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendRobotInteractiveCardResponse = SendRobotInteractiveCardResponse;
class SendRobotMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendRobotMessageHeaders = SendRobotMessageHeaders;
class SendRobotMessageRequest extends $tea.Model {
    static names() {
        return {
            atAll: 'atAll',
            atAppUserId: 'atAppUserId',
            atDingUserId: 'atDingUserId',
            msgContent: 'msgContent',
            msgType: 'msgType',
            openConversationIds: 'openConversationIds',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            atAll: 'boolean',
            atAppUserId: 'string',
            atDingUserId: 'string',
            msgContent: 'string',
            msgType: 'string',
            openConversationIds: { 'type': 'array', 'itemType': 'string' },
            robotCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendRobotMessageRequest = SendRobotMessageRequest;
class SendRobotMessageResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendRobotMessageResponseBody = SendRobotMessageResponseBody;
class SendRobotMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendRobotMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendRobotMessageResponse = SendRobotMessageResponse;
class SendTemplateInteractiveCardHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendTemplateInteractiveCardHeaders = SendTemplateInteractiveCardHeaders;
class SendTemplateInteractiveCardRequest extends $tea.Model {
    static names() {
        return {
            callbackUrl: 'callbackUrl',
            cardData: 'cardData',
            cardTemplateId: 'cardTemplateId',
            openConversationId: 'openConversationId',
            outTrackId: 'outTrackId',
            robotCode: 'robotCode',
            sendOptions: 'sendOptions',
            singleChatReceiver: 'singleChatReceiver',
        };
    }
    static types() {
        return {
            callbackUrl: 'string',
            cardData: 'string',
            cardTemplateId: 'string',
            openConversationId: 'string',
            outTrackId: 'string',
            robotCode: 'string',
            sendOptions: SendTemplateInteractiveCardRequestSendOptions,
            singleChatReceiver: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendTemplateInteractiveCardRequest = SendTemplateInteractiveCardRequest;
class SendTemplateInteractiveCardResponseBody extends $tea.Model {
    static names() {
        return {
            processQueryKey: 'processQueryKey',
        };
    }
    static types() {
        return {
            processQueryKey: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendTemplateInteractiveCardResponseBody = SendTemplateInteractiveCardResponseBody;
class SendTemplateInteractiveCardResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendTemplateInteractiveCardResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendTemplateInteractiveCardResponse = SendTemplateInteractiveCardResponse;
class SetRightPanelHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetRightPanelHeaders = SetRightPanelHeaders;
class SetRightPanelRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            rightPanelClosePermitted: 'rightPanelClosePermitted',
            rightPanelOpenStatus: 'rightPanelOpenStatus',
            title: 'title',
            webWndParams: 'webWndParams',
            width: 'width',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            rightPanelClosePermitted: 'boolean',
            rightPanelOpenStatus: 'number',
            title: 'string',
            webWndParams: SetRightPanelRequestWebWndParams,
            width: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetRightPanelRequest = SetRightPanelRequest;
class SetRightPanelResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetRightPanelResponseBody = SetRightPanelResponseBody;
class SetRightPanelResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetRightPanelResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetRightPanelResponse = SetRightPanelResponse;
class TopboxCloseHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TopboxCloseHeaders = TopboxCloseHeaders;
class TopboxCloseRequest extends $tea.Model {
    static names() {
        return {
            conversationType: 'conversationType',
            coolAppCode: 'coolAppCode',
            openConversationId: 'openConversationId',
            outTrackId: 'outTrackId',
            receiverUserIdList: 'receiverUserIdList',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            conversationType: 'number',
            coolAppCode: 'string',
            openConversationId: 'string',
            outTrackId: 'string',
            receiverUserIdList: { 'type': 'array', 'itemType': 'string' },
            robotCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TopboxCloseRequest = TopboxCloseRequest;
class TopboxCloseResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TopboxCloseResponse = TopboxCloseResponse;
class TopboxOpenHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TopboxOpenHeaders = TopboxOpenHeaders;
class TopboxOpenRequest extends $tea.Model {
    static names() {
        return {
            conversationType: 'conversationType',
            coolAppCode: 'coolAppCode',
            expiredTime: 'expiredTime',
            openConversationId: 'openConversationId',
            outTrackId: 'outTrackId',
            platforms: 'platforms',
            receiverUserIdList: 'receiverUserIdList',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            conversationType: 'number',
            coolAppCode: 'string',
            expiredTime: 'number',
            openConversationId: 'string',
            outTrackId: 'string',
            platforms: 'string',
            receiverUserIdList: { 'type': 'array', 'itemType': 'string' },
            robotCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TopboxOpenRequest = TopboxOpenRequest;
class TopboxOpenResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.TopboxOpenResponse = TopboxOpenResponse;
class UpdateGroupAvatarHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupAvatarHeaders = UpdateGroupAvatarHeaders;
class UpdateGroupAvatarRequest extends $tea.Model {
    static names() {
        return {
            groupAvatar: 'groupAvatar',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            groupAvatar: 'string',
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupAvatarRequest = UpdateGroupAvatarRequest;
class UpdateGroupAvatarResponseBody extends $tea.Model {
    static names() {
        return {
            newGroupAvatar: 'newGroupAvatar',
        };
    }
    static types() {
        return {
            newGroupAvatar: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupAvatarResponseBody = UpdateGroupAvatarResponseBody;
class UpdateGroupAvatarResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateGroupAvatarResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupAvatarResponse = UpdateGroupAvatarResponse;
class UpdateGroupNameHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupNameHeaders = UpdateGroupNameHeaders;
class UpdateGroupNameRequest extends $tea.Model {
    static names() {
        return {
            groupName: 'groupName',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            groupName: 'string',
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupNameRequest = UpdateGroupNameRequest;
class UpdateGroupNameResponseBody extends $tea.Model {
    static names() {
        return {
            newGroupName: 'newGroupName',
        };
    }
    static types() {
        return {
            newGroupName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupNameResponseBody = UpdateGroupNameResponseBody;
class UpdateGroupNameResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateGroupNameResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupNameResponse = UpdateGroupNameResponse;
class UpdateGroupPermissionHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupPermissionHeaders = UpdateGroupPermissionHeaders;
class UpdateGroupPermissionRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            permissionGroup: 'permissionGroup',
            status: 'status',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            permissionGroup: 'string',
            status: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupPermissionRequest = UpdateGroupPermissionRequest;
class UpdateGroupPermissionResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupPermissionResponseBody = UpdateGroupPermissionResponseBody;
class UpdateGroupPermissionResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateGroupPermissionResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupPermissionResponse = UpdateGroupPermissionResponse;
class UpdateGroupSubAdminHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupSubAdminHeaders = UpdateGroupSubAdminHeaders;
class UpdateGroupSubAdminRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            role: 'role',
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            role: 'number',
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupSubAdminRequest = UpdateGroupSubAdminRequest;
class UpdateGroupSubAdminResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupSubAdminResponseBody = UpdateGroupSubAdminResponseBody;
class UpdateGroupSubAdminResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateGroupSubAdminResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateGroupSubAdminResponse = UpdateGroupSubAdminResponse;
class UpdateInteractiveCardHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateInteractiveCardHeaders = UpdateInteractiveCardHeaders;
class UpdateInteractiveCardRequest extends $tea.Model {
    static names() {
        return {
            cardData: 'cardData',
            cardOptions: 'cardOptions',
            outTrackId: 'outTrackId',
            privateData: 'privateData',
            userIdType: 'userIdType',
        };
    }
    static types() {
        return {
            cardData: UpdateInteractiveCardRequestCardData,
            cardOptions: UpdateInteractiveCardRequestCardOptions,
            outTrackId: 'string',
            privateData: { 'type': 'map', 'keyType': 'string', 'valueType': PrivateDataValue },
            userIdType: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateInteractiveCardRequest = UpdateInteractiveCardRequest;
class UpdateInteractiveCardResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateInteractiveCardResponseBody = UpdateInteractiveCardResponseBody;
class UpdateInteractiveCardResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateInteractiveCardResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateInteractiveCardResponse = UpdateInteractiveCardResponse;
class UpdateMemberBanWordsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateMemberBanWordsHeaders = UpdateMemberBanWordsHeaders;
class UpdateMemberBanWordsRequest extends $tea.Model {
    static names() {
        return {
            muteDuration: 'muteDuration',
            muteStatus: 'muteStatus',
            openConversationId: 'openConversationId',
            userIdList: 'userIdList',
        };
    }
    static types() {
        return {
            muteDuration: 'number',
            muteStatus: 'number',
            openConversationId: 'string',
            userIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateMemberBanWordsRequest = UpdateMemberBanWordsRequest;
class UpdateMemberBanWordsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateMemberBanWordsResponse = UpdateMemberBanWordsResponse;
class UpdateMemberGroupNickHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateMemberGroupNickHeaders = UpdateMemberGroupNickHeaders;
class UpdateMemberGroupNickRequest extends $tea.Model {
    static names() {
        return {
            groupNick: 'groupNick',
            openConversationId: 'openConversationId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            groupNick: 'string',
            openConversationId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateMemberGroupNickRequest = UpdateMemberGroupNickRequest;
class UpdateMemberGroupNickResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateMemberGroupNickResponseBody = UpdateMemberGroupNickResponseBody;
class UpdateMemberGroupNickResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateMemberGroupNickResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateMemberGroupNickResponse = UpdateMemberGroupNickResponse;
class UpdateRobotInOrgHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateRobotInOrgHeaders = UpdateRobotInOrgHeaders;
class UpdateRobotInOrgRequest extends $tea.Model {
    static names() {
        return {
            brief: 'brief',
            description: 'description',
            icon: 'icon',
            name: 'name',
            outgoingToken: 'outgoingToken',
            outgoingUrl: 'outgoingUrl',
            previewMediaId: 'previewMediaId',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            brief: 'string',
            description: 'string',
            icon: 'string',
            name: 'string',
            outgoingToken: 'string',
            outgoingUrl: 'string',
            previewMediaId: 'string',
            robotCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateRobotInOrgRequest = UpdateRobotInOrgRequest;
class UpdateRobotInOrgResponseBody extends $tea.Model {
    static names() {
        return {
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            robotCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateRobotInOrgResponseBody = UpdateRobotInOrgResponseBody;
class UpdateRobotInOrgResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateRobotInOrgResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateRobotInOrgResponse = UpdateRobotInOrgResponse;
class UpdateRobotInteractiveCardHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateRobotInteractiveCardHeaders = UpdateRobotInteractiveCardHeaders;
class UpdateRobotInteractiveCardRequest extends $tea.Model {
    static names() {
        return {
            cardBizId: 'cardBizId',
            cardData: 'cardData',
            unionIdPrivateDataMap: 'unionIdPrivateDataMap',
            updateOptions: 'updateOptions',
            userIdPrivateDataMap: 'userIdPrivateDataMap',
        };
    }
    static types() {
        return {
            cardBizId: 'string',
            cardData: 'string',
            unionIdPrivateDataMap: 'string',
            updateOptions: UpdateRobotInteractiveCardRequestUpdateOptions,
            userIdPrivateDataMap: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateRobotInteractiveCardRequest = UpdateRobotInteractiveCardRequest;
class UpdateRobotInteractiveCardResponseBody extends $tea.Model {
    static names() {
        return {
            processQueryKey: 'processQueryKey',
        };
    }
    static types() {
        return {
            processQueryKey: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateRobotInteractiveCardResponseBody = UpdateRobotInteractiveCardResponseBody;
class UpdateRobotInteractiveCardResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateRobotInteractiveCardResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateRobotInteractiveCardResponse = UpdateRobotInteractiveCardResponse;
class UpdateSceneGroupTemplateMessageOpenStatusHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSceneGroupTemplateMessageOpenStatusHeaders = UpdateSceneGroupTemplateMessageOpenStatusHeaders;
class UpdateSceneGroupTemplateMessageOpenStatusRequest extends $tea.Model {
    static names() {
        return {
            status: 'status',
            templateIdList: 'templateIdList',
            userId: 'userId',
        };
    }
    static types() {
        return {
            status: 'number',
            templateIdList: { 'type': 'array', 'itemType': 'string' },
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSceneGroupTemplateMessageOpenStatusRequest = UpdateSceneGroupTemplateMessageOpenStatusRequest;
class UpdateSceneGroupTemplateMessageOpenStatusResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSceneGroupTemplateMessageOpenStatusResponseBody = UpdateSceneGroupTemplateMessageOpenStatusResponseBody;
class UpdateSceneGroupTemplateMessageOpenStatusResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateSceneGroupTemplateMessageOpenStatusResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateSceneGroupTemplateMessageOpenStatusResponse = UpdateSceneGroupTemplateMessageOpenStatusResponse;
class UpdateTheGroupRolesOfGroupMemberHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateTheGroupRolesOfGroupMemberHeaders = UpdateTheGroupRolesOfGroupMemberHeaders;
class UpdateTheGroupRolesOfGroupMemberRequest extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            openRoleIds: 'openRoleIds',
            userId: 'userId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            openRoleIds: { 'type': 'array', 'itemType': 'string' },
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateTheGroupRolesOfGroupMemberRequest = UpdateTheGroupRolesOfGroupMemberRequest;
class UpdateTheGroupRolesOfGroupMemberResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateTheGroupRolesOfGroupMemberResponseBody = UpdateTheGroupRolesOfGroupMemberResponseBody;
class UpdateTheGroupRolesOfGroupMemberResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateTheGroupRolesOfGroupMemberResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateTheGroupRolesOfGroupMemberResponse = UpdateTheGroupRolesOfGroupMemberResponse;
class UpdateUnfurlingRegisterHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateUnfurlingRegisterHeaders = UpdateUnfurlingRegisterHeaders;
class UpdateUnfurlingRegisterRequest extends $tea.Model {
    static names() {
        return {
            apiSecret: 'apiSecret',
            appId: 'appId',
            callbackUrl: 'callbackUrl',
            cardTemplateId: 'cardTemplateId',
            domain: 'domain',
            id: 'id',
            path: 'path',
            ruleDesc: 'ruleDesc',
            ruleMatchType: 'ruleMatchType',
            userId: 'userId',
        };
    }
    static types() {
        return {
            apiSecret: 'string',
            appId: 'string',
            callbackUrl: 'string',
            cardTemplateId: 'string',
            domain: 'string',
            id: 'number',
            path: 'string',
            ruleDesc: 'string',
            ruleMatchType: 'number',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateUnfurlingRegisterRequest = UpdateUnfurlingRegisterRequest;
class UpdateUnfurlingRegisterResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateUnfurlingRegisterResponseBody = UpdateUnfurlingRegisterResponseBody;
class UpdateUnfurlingRegisterResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateUnfurlingRegisterResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateUnfurlingRegisterResponse = UpdateUnfurlingRegisterResponse;
class UpdateUnfurlingRegisterStatusHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateUnfurlingRegisterStatusHeaders = UpdateUnfurlingRegisterStatusHeaders;
class UpdateUnfurlingRegisterStatusRequest extends $tea.Model {
    static names() {
        return {
            appId: 'appId',
            id: 'id',
            status: 'status',
            userId: 'userId',
        };
    }
    static types() {
        return {
            appId: 'string',
            id: 'number',
            status: 'number',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateUnfurlingRegisterStatusRequest = UpdateUnfurlingRegisterStatusRequest;
class UpdateUnfurlingRegisterStatusResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateUnfurlingRegisterStatusResponseBody = UpdateUnfurlingRegisterStatusResponseBody;
class UpdateUnfurlingRegisterStatusResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateUnfurlingRegisterStatusResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateUnfurlingRegisterStatusResponse = UpdateUnfurlingRegisterStatusResponse;
class AddGroupMemberHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddGroupMemberHeaders = AddGroupMemberHeaders;
class AddGroupMemberRequest extends $tea.Model {
    static names() {
        return {
            appUserIds: 'appUserIds',
            openConversationId: 'openConversationId',
            operatorId: 'operatorId',
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            appUserIds: { 'type': 'array', 'itemType': 'string' },
            openConversationId: 'string',
            operatorId: 'string',
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddGroupMemberRequest = AddGroupMemberRequest;
class AddGroupMemberResponseBody extends $tea.Model {
    static names() {
        return {
            appUserIds: 'appUserIds',
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            appUserIds: { 'type': 'array', 'itemType': 'string' },
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddGroupMemberResponseBody = AddGroupMemberResponseBody;
class AddGroupMemberResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddGroupMemberResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddGroupMemberResponse = AddGroupMemberResponse;
class RemoveGroupMemberHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RemoveGroupMemberHeaders = RemoveGroupMemberHeaders;
class RemoveGroupMemberRequest extends $tea.Model {
    static names() {
        return {
            appUserIds: 'appUserIds',
            openConversationId: 'openConversationId',
            operatorId: 'operatorId',
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            appUserIds: { 'type': 'array', 'itemType': 'string' },
            openConversationId: 'string',
            operatorId: 'string',
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RemoveGroupMemberRequest = RemoveGroupMemberRequest;
class RemoveGroupMemberResponseBody extends $tea.Model {
    static names() {
        return {
            message: 'message',
        };
    }
    static types() {
        return {
            message: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RemoveGroupMemberResponseBody = RemoveGroupMemberResponseBody;
class RemoveGroupMemberResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RemoveGroupMemberResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RemoveGroupMemberResponse = RemoveGroupMemberResponse;
class SendDingMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendDingMessageHeaders = SendDingMessageHeaders;
class SendDingMessageRequest extends $tea.Model {
    static names() {
        return {
            code: 'code',
            message: 'message',
            messageType: 'messageType',
            openConversationId: 'openConversationId',
            receiverId: 'receiverId',
            senderId: 'senderId',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            messageType: 'string',
            openConversationId: 'string',
            receiverId: 'string',
            senderId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendDingMessageRequest = SendDingMessageRequest;
class SendDingMessageResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendDingMessageResponseBody = SendDingMessageResponseBody;
class SendDingMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendDingMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendDingMessageResponse = SendDingMessageResponse;
class SendMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendMessageHeaders = SendMessageHeaders;
class SendMessageRequest extends $tea.Model {
    static names() {
        return {
            message: 'message',
            messageType: 'messageType',
            openConversationId: 'openConversationId',
            receiverId: 'receiverId',
            senderId: 'senderId',
            sourceInfos: 'sourceInfos',
        };
    }
    static types() {
        return {
            message: 'string',
            messageType: 'string',
            openConversationId: 'string',
            receiverId: 'string',
            senderId: 'string',
            sourceInfos: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendMessageRequest = SendMessageRequest;
class SendMessageResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendMessageResponseBody = SendMessageResponseBody;
class SendMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendMessageResponse = SendMessageResponse;
class AddOrgTextEmotionResponseBodyResult extends $tea.Model {
    static names() {
        return {
            emotionId: 'emotionId',
        };
    }
    static types() {
        return {
            emotionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddOrgTextEmotionResponseBodyResult = AddOrgTextEmotionResponseBodyResult;
class BatchQueryFamilySchoolMessageResponseBodyMessagesMediaModels extends $tea.Model {
    static names() {
        return {
            fileName: 'fileName',
            fileType: 'fileType',
            mediaId: 'mediaId',
            size: 'size',
            url: 'url',
            videoPicMediaId: 'videoPicMediaId',
        };
    }
    static types() {
        return {
            fileName: 'string',
            fileType: 'string',
            mediaId: 'string',
            size: 'string',
            url: 'string',
            videoPicMediaId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryFamilySchoolMessageResponseBodyMessagesMediaModels = BatchQueryFamilySchoolMessageResponseBodyMessagesMediaModels;
class BatchQueryFamilySchoolMessageResponseBodyMessages extends $tea.Model {
    static names() {
        return {
            contentType: 'contentType',
            createAt: 'createAt',
            mediaModels: 'mediaModels',
            openMsgId: 'openMsgId',
        };
    }
    static types() {
        return {
            contentType: 'number',
            createAt: 'number',
            mediaModels: { 'type': 'array', 'itemType': BatchQueryFamilySchoolMessageResponseBodyMessagesMediaModels },
            openMsgId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.BatchQueryFamilySchoolMessageResponseBodyMessages = BatchQueryFamilySchoolMessageResponseBodyMessages;
class CountOpenMsgSceneGroupsResponseBodyResult extends $tea.Model {
    static names() {
        return {
            count: 'count',
        };
    }
    static types() {
        return {
            count: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CountOpenMsgSceneGroupsResponseBodyResult = CountOpenMsgSceneGroupsResponseBodyResult;
class CreateInterconnectionRequestInterconnections extends $tea.Model {
    static names() {
        return {
            appUserAvatar: 'appUserAvatar',
            appUserAvatarMediaType: 'appUserAvatarMediaType',
            appUserDynamics: 'appUserDynamics',
            appUserId: 'appUserId',
            appUserMobile: 'appUserMobile',
            appUserName: 'appUserName',
            channelCode: 'channelCode',
            userId: 'userId',
        };
    }
    static types() {
        return {
            appUserAvatar: 'string',
            appUserAvatarMediaType: 'number',
            appUserDynamics: 'string',
            appUserId: 'string',
            appUserMobile: 'string',
            appUserName: 'string',
            channelCode: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateInterconnectionRequestInterconnections = CreateInterconnectionRequestInterconnections;
class CreateInterconnectionResponseBodyResults extends $tea.Model {
    static names() {
        return {
            appUserId: 'appUserId',
            message: 'message',
            userId: 'userId',
        };
    }
    static types() {
        return {
            appUserId: 'string',
            message: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateInterconnectionResponseBodyResults = CreateInterconnectionResponseBodyResults;
class CreateSceneGroupConversationRequestManagementOptions extends $tea.Model {
    static names() {
        return {
            chatBannedType: 'chatBannedType',
            managementType: 'managementType',
            mentionAllAuthority: 'mentionAllAuthority',
            searchable: 'searchable',
            showHistoryType: 'showHistoryType',
            validationType: 'validationType',
        };
    }
    static types() {
        return {
            chatBannedType: 'number',
            managementType: 'number',
            mentionAllAuthority: 'number',
            searchable: 'number',
            showHistoryType: 'number',
            validationType: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateSceneGroupConversationRequestManagementOptions = CreateSceneGroupConversationRequestManagementOptions;
class GetFamilySchoolConversationMsgResponseBodyMessagesMediaModels extends $tea.Model {
    static names() {
        return {
            fileName: 'fileName',
            fileType: 'fileType',
            mediaId: 'mediaId',
            size: 'size',
            url: 'url',
            videoPicMediaId: 'videoPicMediaId',
        };
    }
    static types() {
        return {
            fileName: 'string',
            fileType: 'string',
            mediaId: 'string',
            size: 'string',
            url: 'string',
            videoPicMediaId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFamilySchoolConversationMsgResponseBodyMessagesMediaModels = GetFamilySchoolConversationMsgResponseBodyMessagesMediaModels;
class GetFamilySchoolConversationMsgResponseBodyMessages extends $tea.Model {
    static names() {
        return {
            contentType: 'contentType',
            createAt: 'createAt',
            mediaModels: 'mediaModels',
            openMsgId: 'openMsgId',
        };
    }
    static types() {
        return {
            contentType: 'number',
            createAt: 'number',
            mediaModels: { 'type': 'array', 'itemType': GetFamilySchoolConversationMsgResponseBodyMessagesMediaModels },
            openMsgId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFamilySchoolConversationMsgResponseBodyMessages = GetFamilySchoolConversationMsgResponseBodyMessages;
class GetFamilySchoolConversationsResponseBodyGroupInfoList extends $tea.Model {
    static names() {
        return {
            corpId: 'corpId',
            deptNameChain: 'deptNameChain',
            groupName: 'groupName',
            groupType: 'groupType',
            joinGroupTime: 'joinGroupTime',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            corpId: 'string',
            deptNameChain: { 'type': 'array', 'itemType': 'string' },
            groupName: 'string',
            groupType: 'string',
            joinGroupTime: 'number',
            openConversationId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetFamilySchoolConversationsResponseBodyGroupInfoList = GetFamilySchoolConversationsResponseBodyGroupInfoList;
class GetNewestInnerGroupsResponseBodyGroupInfos extends $tea.Model {
    static names() {
        return {
            icon: 'icon',
            memberAmount: 'memberAmount',
            openConversationId: 'openConversationId',
            title: 'title',
        };
    }
    static types() {
        return {
            icon: 'string',
            memberAmount: 'string',
            openConversationId: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetNewestInnerGroupsResponseBodyGroupInfos = GetNewestInnerGroupsResponseBodyGroupInfos;
class GroupManageQueryResponseBodyGroupInfoList extends $tea.Model {
    static names() {
        return {
            banWordsMode: 'banWordsMode',
            capacity: 'capacity',
            createdAt: 'createdAt',
            extInfo: 'extInfo',
            groupAdminList: 'groupAdminList',
            groupOwner: 'groupOwner',
            groupTitle: 'groupTitle',
            memberCount: 'memberCount',
            openConversationId: 'openConversationId',
            type: 'type',
        };
    }
    static types() {
        return {
            banWordsMode: 'number',
            capacity: 'number',
            createdAt: 'number',
            extInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            groupAdminList: { 'type': 'array', 'itemType': 'string' },
            groupOwner: 'string',
            groupTitle: 'string',
            memberCount: 'number',
            openConversationId: 'string',
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GroupManageQueryResponseBodyGroupInfoList = GroupManageQueryResponseBodyGroupInfoList;
class InteractiveCardCreateInstanceRequestCardData extends $tea.Model {
    static names() {
        return {
            cardMediaIdParamMap: 'cardMediaIdParamMap',
            cardParamMap: 'cardParamMap',
        };
    }
    static types() {
        return {
            cardMediaIdParamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            cardParamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InteractiveCardCreateInstanceRequestCardData = InteractiveCardCreateInstanceRequestCardData;
class ListGroupTemplatesByOrgIdResponseBodySceneGroupDetailModels extends $tea.Model {
    static names() {
        return {
            description: 'description',
            gmtCreate: 'gmtCreate',
            icon: 'icon',
            msgOpen: 'msgOpen',
            templateId: 'templateId',
            templateName: 'templateName',
        };
    }
    static types() {
        return {
            description: 'string',
            gmtCreate: 'string',
            icon: 'string',
            msgOpen: 'boolean',
            templateId: 'string',
            templateName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListGroupTemplatesByOrgIdResponseBodySceneGroupDetailModels = ListGroupTemplatesByOrgIdResponseBodySceneGroupDetailModels;
class ListOrgTextEmotionResponseBodyResultEmotions extends $tea.Model {
    static names() {
        return {
            backgroundMediaId: 'backgroundMediaId',
            backgroundMediaIdForPanel: 'backgroundMediaIdForPanel',
            deptId: 'deptId',
            emotionId: 'emotionId',
            emotionName: 'emotionName',
            status: 'status',
        };
    }
    static types() {
        return {
            backgroundMediaId: 'string',
            backgroundMediaIdForPanel: 'string',
            deptId: 'number',
            emotionId: 'string',
            emotionName: 'string',
            status: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListOrgTextEmotionResponseBodyResultEmotions = ListOrgTextEmotionResponseBodyResultEmotions;
class ListOrgTextEmotionResponseBodyResult extends $tea.Model {
    static names() {
        return {
            emotions: 'emotions',
        };
    }
    static types() {
        return {
            emotions: { 'type': 'array', 'itemType': ListOrgTextEmotionResponseBodyResultEmotions },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListOrgTextEmotionResponseBodyResult = ListOrgTextEmotionResponseBodyResult;
class OpenGroupRoleAddResponseBodyResult extends $tea.Model {
    static names() {
        return {
            openRoleId: 'openRoleId',
        };
    }
    static types() {
        return {
            openRoleId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupRoleAddResponseBodyResult = OpenGroupRoleAddResponseBodyResult;
class OpenGroupRoleQueryResponseBodyResultGroupRoles extends $tea.Model {
    static names() {
        return {
            openRoleId: 'openRoleId',
            roleName: 'roleName',
        };
    }
    static types() {
        return {
            openRoleId: 'string',
            roleName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupRoleQueryResponseBodyResultGroupRoles = OpenGroupRoleQueryResponseBodyResultGroupRoles;
class OpenGroupRoleQueryResponseBodyResult extends $tea.Model {
    static names() {
        return {
            groupRoles: 'groupRoles',
        };
    }
    static types() {
        return {
            groupRoles: { 'type': 'array', 'itemType': OpenGroupRoleQueryResponseBodyResultGroupRoles },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupRoleQueryResponseBodyResult = OpenGroupRoleQueryResponseBodyResult;
class OpenGroupUserRoleQueryResponseBodyResultGroupRoles extends $tea.Model {
    static names() {
        return {
            openRoleId: 'openRoleId',
            roleName: 'roleName',
        };
    }
    static types() {
        return {
            openRoleId: 'string',
            roleName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupUserRoleQueryResponseBodyResultGroupRoles = OpenGroupUserRoleQueryResponseBodyResultGroupRoles;
class OpenGroupUserRoleQueryResponseBodyResult extends $tea.Model {
    static names() {
        return {
            groupRoles: 'groupRoles',
        };
    }
    static types() {
        return {
            groupRoles: { 'type': 'array', 'itemType': OpenGroupUserRoleQueryResponseBodyResultGroupRoles },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenGroupUserRoleQueryResponseBodyResult = OpenGroupUserRoleQueryResponseBodyResult;
class OpenSearchGroupListResponseBodyResultGroupList extends $tea.Model {
    static names() {
        return {
            icon: 'icon',
            memberCount: 'memberCount',
            openConversationId: 'openConversationId',
            tag: 'tag',
            title: 'title',
        };
    }
    static types() {
        return {
            icon: 'string',
            memberCount: 'number',
            openConversationId: 'string',
            tag: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenSearchGroupListResponseBodyResultGroupList = OpenSearchGroupListResponseBodyResultGroupList;
class OpenSearchGroupListResponseBodyResult extends $tea.Model {
    static names() {
        return {
            groupList: 'groupList',
        };
    }
    static types() {
        return {
            groupList: { 'type': 'array', 'itemType': OpenSearchGroupListResponseBodyResultGroupList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenSearchGroupListResponseBodyResult = OpenSearchGroupListResponseBodyResult;
class OpenUserSendCardMessageRequestCardContent extends $tea.Model {
    static names() {
        return {
            lastMessage: 'lastMessage',
            outTrackId: 'outTrackId',
        };
    }
    static types() {
        return {
            lastMessage: 'string',
            outTrackId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenUserSendCardMessageRequestCardContent = OpenUserSendCardMessageRequestCardContent;
class OpenUserSendCardMessageResponseBodyResult extends $tea.Model {
    static names() {
        return {
            openTaskId: 'openTaskId',
        };
    }
    static types() {
        return {
            openTaskId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.OpenUserSendCardMessageResponseBodyResult = OpenUserSendCardMessageResponseBodyResult;
class PersonalSendCardMessageRequestCardContent extends $tea.Model {
    static names() {
        return {
            lastMessage: 'lastMessage',
            outTrackId: 'outTrackId',
        };
    }
    static types() {
        return {
            lastMessage: 'string',
            outTrackId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PersonalSendCardMessageRequestCardContent = PersonalSendCardMessageRequestCardContent;
class PersonalSendCardMessageResponseBodyResult extends $tea.Model {
    static names() {
        return {
            openTaskId: 'openTaskId',
        };
    }
    static types() {
        return {
            openTaskId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.PersonalSendCardMessageResponseBodyResult = PersonalSendCardMessageResponseBodyResult;
class QueryGroupMemberResponseBodyGroupMembers extends $tea.Model {
    static names() {
        return {
            groupMemberAvatar: 'groupMemberAvatar',
            groupMemberDynamics: 'groupMemberDynamics',
            groupMemberId: 'groupMemberId',
            groupMemberName: 'groupMemberName',
            groupMemberType: 'groupMemberType',
        };
    }
    static types() {
        return {
            groupMemberAvatar: 'string',
            groupMemberDynamics: 'string',
            groupMemberId: 'string',
            groupMemberName: 'string',
            groupMemberType: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMemberResponseBodyGroupMembers = QueryGroupMemberResponseBodyGroupMembers;
class QueryGroupMemberByMemberAuthResponseBodyGroupMemberList extends $tea.Model {
    static names() {
        return {
            groupNickName: 'groupNickName',
            orgName: 'orgName',
            profilePhotoUrl: 'profilePhotoUrl',
            userId: 'userId',
        };
    }
    static types() {
        return {
            groupNickName: 'string',
            orgName: 'string',
            profilePhotoUrl: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMemberByMemberAuthResponseBodyGroupMemberList = QueryGroupMemberByMemberAuthResponseBodyGroupMemberList;
class QueryGroupMuteStatusResponseBodyUserMuteResult extends $tea.Model {
    static names() {
        return {
            muteEndTime: 'muteEndTime',
            muteStartTime: 'muteStartTime',
            userMuteMode: 'userMuteMode',
        };
    }
    static types() {
        return {
            muteEndTime: 'number',
            muteStartTime: 'number',
            userMuteMode: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryGroupMuteStatusResponseBodyUserMuteResult = QueryGroupMuteStatusResponseBodyUserMuteResult;
class QueryInnerGroupMemberListResponseBodyList extends $tea.Model {
    static names() {
        return {
            icon: 'icon',
            name: 'name',
            nickName: 'nickName',
            userId: 'userId',
        };
    }
    static types() {
        return {
            icon: 'string',
            name: 'string',
            nickName: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryInnerGroupMemberListResponseBodyList = QueryInnerGroupMemberListResponseBodyList;
class QueryInnerGroupRecentListResponseBodyGroupInfos extends $tea.Model {
    static names() {
        return {
            icon: 'icon',
            memberAmount: 'memberAmount',
            openConversationId: 'openConversationId',
            title: 'title',
        };
    }
    static types() {
        return {
            icon: 'string',
            memberAmount: 'string',
            openConversationId: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryInnerGroupRecentListResponseBodyGroupInfos = QueryInnerGroupRecentListResponseBodyGroupInfos;
class QueryMessageSendResultResponseBodyResult extends $tea.Model {
    static names() {
        return {
            openMessageId: 'openMessageId',
            sendStatus: 'sendStatus',
        };
    }
    static types() {
        return {
            openMessageId: 'string',
            sendStatus: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMessageSendResultResponseBodyResult = QueryMessageSendResultResponseBodyResult;
class QueryOpenConversationReceiveUserResponseBodyResultReceiveUser extends $tea.Model {
    static names() {
        return {
            icon: 'icon',
            name: 'name',
            nickName: 'nickName',
            userId: 'userId',
        };
    }
    static types() {
        return {
            icon: 'string',
            name: 'string',
            nickName: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryOpenConversationReceiveUserResponseBodyResultReceiveUser = QueryOpenConversationReceiveUserResponseBodyResultReceiveUser;
class QueryOpenConversationReceiveUserResponseBodyResult extends $tea.Model {
    static names() {
        return {
            receiveUser: 'receiveUser',
        };
    }
    static types() {
        return {
            receiveUser: QueryOpenConversationReceiveUserResponseBodyResultReceiveUser,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryOpenConversationReceiveUserResponseBodyResult = QueryOpenConversationReceiveUserResponseBodyResult;
class QueryOpenGroupBaseInfoResponseBodyResult extends $tea.Model {
    static names() {
        return {
            icon: 'icon',
            memberCount: 'memberCount',
            openConversationId: 'openConversationId',
            tag: 'tag',
            title: 'title',
        };
    }
    static types() {
        return {
            icon: 'string',
            memberCount: 'number',
            openConversationId: 'string',
            tag: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryOpenGroupBaseInfoResponseBodyResult = QueryOpenGroupBaseInfoResponseBodyResult;
class QueryPersonalMessageReadStatusResponseBodyResultMessageReadInfoList extends $tea.Model {
    static names() {
        return {
            readStatus: 'readStatus',
            userId: 'userId',
        };
    }
    static types() {
        return {
            readStatus: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryPersonalMessageReadStatusResponseBodyResultMessageReadInfoList = QueryPersonalMessageReadStatusResponseBodyResultMessageReadInfoList;
class QueryPersonalMessageReadStatusResponseBodyResult extends $tea.Model {
    static names() {
        return {
            messageReadInfoList: 'messageReadInfoList',
        };
    }
    static types() {
        return {
            messageReadInfoList: { 'type': 'array', 'itemType': QueryPersonalMessageReadStatusResponseBodyResultMessageReadInfoList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryPersonalMessageReadStatusResponseBodyResult = QueryPersonalMessageReadStatusResponseBodyResult;
class QueryRecentConversationsResponseBodyResultConversationList extends $tea.Model {
    static names() {
        return {
            conversationType: 'conversationType',
            icon: 'icon',
            memberCount: 'memberCount',
            name: 'name',
            nickName: 'nickName',
            openConversationId: 'openConversationId',
            title: 'title',
            userId: 'userId',
        };
    }
    static types() {
        return {
            conversationType: 'number',
            icon: 'string',
            memberCount: 'string',
            name: 'string',
            nickName: 'string',
            openConversationId: 'string',
            title: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryRecentConversationsResponseBodyResultConversationList = QueryRecentConversationsResponseBodyResultConversationList;
class QueryRecentConversationsResponseBodyResult extends $tea.Model {
    static names() {
        return {
            conversationList: 'conversationList',
        };
    }
    static types() {
        return {
            conversationList: { 'type': 'array', 'itemType': QueryRecentConversationsResponseBodyResultConversationList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryRecentConversationsResponseBodyResult = QueryRecentConversationsResponseBodyResult;
class QuerySceneGroupTemplateRobotResponseBodyResult extends $tea.Model {
    static names() {
        return {
            unionId: 'unionId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            unionId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySceneGroupTemplateRobotResponseBodyResult = QuerySceneGroupTemplateRobotResponseBodyResult;
class QuerySingleGroupRequestGroupMembers extends $tea.Model {
    static names() {
        return {
            appUserId: 'appUserId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            appUserId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySingleGroupRequestGroupMembers = QuerySingleGroupRequestGroupMembers;
class QuerySingleGroupResponseBodyOpenConversations extends $tea.Model {
    static names() {
        return {
            appUserId: 'appUserId',
            openConversationId: 'openConversationId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            appUserId: 'string',
            openConversationId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QuerySingleGroupResponseBodyOpenConversations = QuerySingleGroupResponseBodyOpenConversations;
class QueryUnReadMessageResponseBodyUnReadItems extends $tea.Model {
    static names() {
        return {
            openConversationId: 'openConversationId',
            unReadCount: 'unReadCount',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            unReadCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUnReadMessageResponseBodyUnReadItems = QueryUnReadMessageResponseBodyUnReadItems;
class QueryUnfurlingRegisterCreatorResponseBodyData extends $tea.Model {
    static names() {
        return {
            appId: 'appId',
            creatorUserId: 'creatorUserId',
            id: 'id',
        };
    }
    static types() {
        return {
            appId: 'string',
            creatorUserId: 'string',
            id: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUnfurlingRegisterCreatorResponseBodyData = QueryUnfurlingRegisterCreatorResponseBodyData;
class QueryUnfurlingRegisterInfoResponseBodyList extends $tea.Model {
    static names() {
        return {
            apiSecret: 'apiSecret',
            appId: 'appId',
            appName: 'appName',
            callbackType: 'callbackType',
            callbackUrl: 'callbackUrl',
            cardTemplateId: 'cardTemplateId',
            creatorUserId: 'creatorUserId',
            domain: 'domain',
            grayGroupIdList: 'grayGroupIdList',
            grayUserIdList: 'grayUserIdList',
            hsfMethodName: 'hsfMethodName',
            hsfServiceName: 'hsfServiceName',
            hsfVersion: 'hsfVersion',
            id: 'id',
            path: 'path',
            ruleDesc: 'ruleDesc',
            ruleMatchType: 'ruleMatchType',
            status: 'status',
        };
    }
    static types() {
        return {
            apiSecret: 'string',
            appId: 'string',
            appName: 'string',
            callbackType: 'number',
            callbackUrl: 'string',
            cardTemplateId: 'string',
            creatorUserId: 'string',
            domain: 'string',
            grayGroupIdList: { 'type': 'array', 'itemType': 'string' },
            grayUserIdList: { 'type': 'array', 'itemType': 'string' },
            hsfMethodName: 'string',
            hsfServiceName: 'string',
            hsfVersion: 'string',
            id: 'number',
            path: 'string',
            ruleDesc: 'string',
            ruleMatchType: 'number',
            status: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUnfurlingRegisterInfoResponseBodyList = QueryUnfurlingRegisterInfoResponseBodyList;
class SearchInnerGroupsResponseBodyGroupInfos extends $tea.Model {
    static names() {
        return {
            icon: 'icon',
            memberAmount: 'memberAmount',
            openConversationId: 'openConversationId',
            title: 'title',
        };
    }
    static types() {
        return {
            icon: 'string',
            memberAmount: 'string',
            openConversationId: 'string',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SearchInnerGroupsResponseBodyGroupInfos = SearchInnerGroupsResponseBodyGroupInfos;
class SendInteractiveCardRequestCardData extends $tea.Model {
    static names() {
        return {
            cardMediaIdParamMap: 'cardMediaIdParamMap',
            cardParamMap: 'cardParamMap',
        };
    }
    static types() {
        return {
            cardMediaIdParamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            cardParamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendInteractiveCardRequestCardData = SendInteractiveCardRequestCardData;
class SendInteractiveCardRequestCardOptions extends $tea.Model {
    static names() {
        return {
            supportForward: 'supportForward',
        };
    }
    static types() {
        return {
            supportForward: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendInteractiveCardRequestCardOptions = SendInteractiveCardRequestCardOptions;
class SendInteractiveCardResponseBodyResult extends $tea.Model {
    static names() {
        return {
            processQueryKey: 'processQueryKey',
        };
    }
    static types() {
        return {
            processQueryKey: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendInteractiveCardResponseBodyResult = SendInteractiveCardResponseBodyResult;
class SendOTOInteractiveCardRequestCardData extends $tea.Model {
    static names() {
        return {
            cardParamMap: 'cardParamMap',
        };
    }
    static types() {
        return {
            cardParamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendOTOInteractiveCardRequestCardData = SendOTOInteractiveCardRequestCardData;
class SendOTOInteractiveCardRequestCardOptions extends $tea.Model {
    static names() {
        return {
            supportForward: 'supportForward',
        };
    }
    static types() {
        return {
            supportForward: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendOTOInteractiveCardRequestCardOptions = SendOTOInteractiveCardRequestCardOptions;
class SendOTOInteractiveCardResponseBodyResult extends $tea.Model {
    static names() {
        return {
            processQueryKey: 'processQueryKey',
        };
    }
    static types() {
        return {
            processQueryKey: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendOTOInteractiveCardResponseBodyResult = SendOTOInteractiveCardResponseBodyResult;
class SendPersonalMessageResponseBodyResult extends $tea.Model {
    static names() {
        return {
            openTaskId: 'openTaskId',
        };
    }
    static types() {
        return {
            openTaskId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendPersonalMessageResponseBodyResult = SendPersonalMessageResponseBodyResult;
class SendRobotInteractiveCardRequestSendOptions extends $tea.Model {
    static names() {
        return {
            atAll: 'atAll',
            atUserListJson: 'atUserListJson',
            cardPropertyJson: 'cardPropertyJson',
            receiverListJson: 'receiverListJson',
        };
    }
    static types() {
        return {
            atAll: 'boolean',
            atUserListJson: 'string',
            cardPropertyJson: 'string',
            receiverListJson: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendRobotInteractiveCardRequestSendOptions = SendRobotInteractiveCardRequestSendOptions;
class SendTemplateInteractiveCardRequestSendOptions extends $tea.Model {
    static names() {
        return {
            atAll: 'atAll',
            atUserListJson: 'atUserListJson',
            cardPropertyJson: 'cardPropertyJson',
            receiverListJson: 'receiverListJson',
        };
    }
    static types() {
        return {
            atAll: 'boolean',
            atUserListJson: 'string',
            cardPropertyJson: 'string',
            receiverListJson: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SendTemplateInteractiveCardRequestSendOptions = SendTemplateInteractiveCardRequestSendOptions;
class SetRightPanelRequestWebWndParams extends $tea.Model {
    static names() {
        return {
            targetURL: 'targetURL',
        };
    }
    static types() {
        return {
            targetURL: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SetRightPanelRequestWebWndParams = SetRightPanelRequestWebWndParams;
class UpdateInteractiveCardRequestCardData extends $tea.Model {
    static names() {
        return {
            cardMediaIdParamMap: 'cardMediaIdParamMap',
            cardParamMap: 'cardParamMap',
        };
    }
    static types() {
        return {
            cardMediaIdParamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            cardParamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateInteractiveCardRequestCardData = UpdateInteractiveCardRequestCardData;
class UpdateInteractiveCardRequestCardOptions extends $tea.Model {
    static names() {
        return {
            updateCardDataByKey: 'updateCardDataByKey',
            updatePrivateDataByKey: 'updatePrivateDataByKey',
        };
    }
    static types() {
        return {
            updateCardDataByKey: 'boolean',
            updatePrivateDataByKey: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateInteractiveCardRequestCardOptions = UpdateInteractiveCardRequestCardOptions;
class UpdateRobotInteractiveCardRequestUpdateOptions extends $tea.Model {
    static names() {
        return {
            updateCardDataByKey: 'updateCardDataByKey',
            updatePrivateDataByKey: 'updatePrivateDataByKey',
        };
    }
    static types() {
        return {
            updateCardDataByKey: 'boolean',
            updatePrivateDataByKey: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateRobotInteractiveCardRequestUpdateOptions = UpdateRobotInteractiveCardRequestUpdateOptions;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        let gatewayClient = new gateway_dingtalk_1.default();
        this._spi = gatewayClient;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    /**
     * 
     *
     * @param request - AddOrgTextEmotionRequest
     * @param headers - AddOrgTextEmotionHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns AddOrgTextEmotionResponse
     */
    async addOrgTextEmotionWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.backgroundMediaId)) {
            body["backgroundMediaId"] = request.backgroundMediaId;
        }
        if (!tea_util_1.default.isUnset(request.backgroundMediaIdForPanel)) {
            body["backgroundMediaIdForPanel"] = request.backgroundMediaIdForPanel;
        }
        if (!tea_util_1.default.isUnset(request.deptId)) {
            body["deptId"] = request.deptId;
        }
        if (!tea_util_1.default.isUnset(request.emotionName)) {
            body["emotionName"] = request.emotionName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddOrgTextEmotion",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/organizations/textEmotions`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddOrgTextEmotionResponse({}));
    }
    /**
     * 
     *
     * @param request - AddOrgTextEmotionRequest
     * @returns AddOrgTextEmotionResponse
     */
    async addOrgTextEmotion(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddOrgTextEmotionHeaders({});
        return await this.addOrgTextEmotionWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - AddRobotToConversationRequest
     * @param headers - AddRobotToConversationHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns AddRobotToConversationResponse
     */
    async addRobotToConversationWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.icon)) {
            body["icon"] = request.icon;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddRobotToConversation",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/conversations/robots`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddRobotToConversationResponse({}));
    }
    /**
     * 
     *
     * @param request - AddRobotToConversationRequest
     * @returns AddRobotToConversationResponse
     */
    async addRobotToConversation(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddRobotToConversationHeaders({});
        return await this.addRobotToConversationWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - AddUnfurlingRegisterRequest
     * @param headers - AddUnfurlingRegisterHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns AddUnfurlingRegisterResponse
     */
    async addUnfurlingRegisterWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.apiSecret)) {
            body["apiSecret"] = request.apiSecret;
        }
        if (!tea_util_1.default.isUnset(request.appId)) {
            body["appId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.callbackUrl)) {
            body["callbackUrl"] = request.callbackUrl;
        }
        if (!tea_util_1.default.isUnset(request.cardTemplateId)) {
            body["cardTemplateId"] = request.cardTemplateId;
        }
        if (!tea_util_1.default.isUnset(request.domain)) {
            body["domain"] = request.domain;
        }
        if (!tea_util_1.default.isUnset(request.path)) {
            body["path"] = request.path;
        }
        if (!tea_util_1.default.isUnset(request.ruleDesc)) {
            body["ruleDesc"] = request.ruleDesc;
        }
        if (!tea_util_1.default.isUnset(request.ruleMatchType)) {
            body["ruleMatchType"] = request.ruleMatchType;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddUnfurlingRegister",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/unfurling/rules`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddUnfurlingRegisterResponse({}));
    }
    /**
     * 
     *
     * @param request - AddUnfurlingRegisterRequest
     * @returns AddUnfurlingRegisterResponse
     */
    async addUnfurlingRegister(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddUnfurlingRegisterHeaders({});
        return await this.addUnfurlingRegisterWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param headers - AutoOpenDingTalkConnectHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns AutoOpenDingTalkConnectResponse
     */
    async autoOpenDingTalkConnectWithOptions(headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "AutoOpenDingTalkConnect",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interconnections/apps/open`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AutoOpenDingTalkConnectResponse({}));
    }
    /**
     * 
     * @returns AutoOpenDingTalkConnectResponse
     */
    async autoOpenDingTalkConnect() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AutoOpenDingTalkConnectHeaders({});
        return await this.autoOpenDingTalkConnectWithOptions(headers, runtime);
    }
    /**
     * 
     *
     * @param request - BatchQueryFamilySchoolMessageRequest
     * @param headers - BatchQueryFamilySchoolMessageHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns BatchQueryFamilySchoolMessageResponse
     */
    async batchQueryFamilySchoolMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openMessageIds)) {
            body["openMessageIds"] = request.openMessageIds;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchQueryFamilySchoolMessage",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/conversations/familySchools/messages/batchQuery`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchQueryFamilySchoolMessageResponse({}));
    }
    /**
     * 
     *
     * @param request - BatchQueryFamilySchoolMessageRequest
     * @returns BatchQueryFamilySchoolMessageResponse
     */
    async batchQueryFamilySchoolMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchQueryFamilySchoolMessageHeaders({});
        return await this.batchQueryFamilySchoolMessageWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - BatchQueryGroupMemberRequest
     * @param headers - BatchQueryGroupMemberHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns BatchQueryGroupMemberResponse
     */
    async batchQueryGroupMemberWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.coolAppCode)) {
            body["coolAppCode"] = request.coolAppCode;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchQueryGroupMember",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/sceneGroups/members/batchQuery`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchQueryGroupMemberResponse({}));
    }
    /**
     * 
     *
     * @param request - BatchQueryGroupMemberRequest
     * @returns BatchQueryGroupMemberResponse
     */
    async batchQueryGroupMember(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchQueryGroupMemberHeaders({});
        return await this.batchQueryGroupMemberWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - CardTemplateBuildActionRequest
     * @param headers - CardTemplateBuildActionHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CardTemplateBuildActionResponse
     */
    async cardTemplateBuildActionWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.cardTemplateJson)) {
            body["cardTemplateJson"] = request.cardTemplateJson;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CardTemplateBuildAction",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interactiveCards/templates/buildAction`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CardTemplateBuildActionResponse({}));
    }
    /**
     * 
     *
     * @param request - CardTemplateBuildActionRequest
     * @returns CardTemplateBuildActionResponse
     */
    async cardTemplateBuildAction(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CardTemplateBuildActionHeaders({});
        return await this.cardTemplateBuildActionWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - ChangeGroupOwnerRequest
     * @param headers - ChangeGroupOwnerHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ChangeGroupOwnerResponse
     */
    async changeGroupOwnerWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.groupOwnerId)) {
            body["groupOwnerId"] = request.groupOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.groupOwnerType)) {
            body["groupOwnerType"] = request.groupOwnerType;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ChangeGroupOwner",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interconnections/groups/owners`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ChangeGroupOwnerResponse({}));
    }
    /**
     * 
     *
     * @param request - ChangeGroupOwnerRequest
     * @returns ChangeGroupOwnerResponse
     */
    async changeGroupOwner(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ChangeGroupOwnerHeaders({});
        return await this.changeGroupOwnerWithOptions(request, headers, runtime);
    }
    /**
     * ChatIdOpenConversationId
     *
     * @param headers - ChatIdToOpenConversationIdHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ChatIdToOpenConversationIdResponse
     */
    async chatIdToOpenConversationIdWithOptions(chatId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "ChatIdToOpenConversationId",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/chat/${chatId}/convertToOpenConversationId`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ChatIdToOpenConversationIdResponse({}));
    }
    /**
     * ChatIdOpenConversationId
     * @returns ChatIdToOpenConversationIdResponse
     */
    async chatIdToOpenConversationId(chatId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ChatIdToOpenConversationIdHeaders({});
        return await this.chatIdToOpenConversationIdWithOptions(chatId, headers, runtime);
    }
    /**
     * 
     *
     * @param request - ChatSubAdminUpdateRequest
     * @param headers - ChatSubAdminUpdateHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ChatSubAdminUpdateResponse
     */
    async chatSubAdminUpdateWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.role)) {
            body["role"] = request.role;
        }
        if (!tea_util_1.default.isUnset(request.userIds)) {
            body["userIds"] = request.userIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ChatSubAdminUpdate",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/subAdministrators`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ChatSubAdminUpdateResponse({}));
    }
    /**
     * 
     *
     * @param request - ChatSubAdminUpdateRequest
     * @returns ChatSubAdminUpdateResponse
     */
    async chatSubAdminUpdate(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ChatSubAdminUpdateHeaders({});
        return await this.chatSubAdminUpdateWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - CheckUserIsGroupMemberRequest
     * @param headers - CheckUserIsGroupMemberHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CheckUserIsGroupMemberResponse
     */
    async checkUserIsGroupMemberWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CheckUserIsGroupMember",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/innerGroups/members/check`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CheckUserIsGroupMemberResponse({}));
    }
    /**
     * 
     *
     * @param request - CheckUserIsGroupMemberRequest
     * @returns CheckUserIsGroupMemberResponse
     */
    async checkUserIsGroupMember(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CheckUserIsGroupMemberHeaders({});
        return await this.checkUserIsGroupMemberWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - CopyUnfurlingRegisterRequest
     * @param headers - CopyUnfurlingRegisterHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CopyUnfurlingRegisterResponse
     */
    async copyUnfurlingRegisterWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            body["appId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.id)) {
            body["id"] = request.id;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CopyUnfurlingRegister",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/unfurling/rules/copy`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CopyUnfurlingRegisterResponse({}));
    }
    /**
     * 
     *
     * @param request - CopyUnfurlingRegisterRequest
     * @returns CopyUnfurlingRegisterResponse
     */
    async copyUnfurlingRegister(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CopyUnfurlingRegisterHeaders({});
        return await this.copyUnfurlingRegisterWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - CountOpenMsgSceneGroupsRequest
     * @param headers - CountOpenMsgSceneGroupsHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CountOpenMsgSceneGroupsResponse
     */
    async countOpenMsgSceneGroupsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.templateId)) {
            body["templateId"] = request.templateId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CountOpenMsgSceneGroups",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/openMsgSceneGroups/templates/counts/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CountOpenMsgSceneGroupsResponse({}));
    }
    /**
     * 
     *
     * @param request - CountOpenMsgSceneGroupsRequest
     * @returns CountOpenMsgSceneGroupsResponse
     */
    async countOpenMsgSceneGroups(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CountOpenMsgSceneGroupsHeaders({});
        return await this.countOpenMsgSceneGroupsWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param headers - CountOrgMessageOpenSceneGroupsHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CountOrgMessageOpenSceneGroupsResponse
     */
    async countOrgMessageOpenSceneGroupsWithOptions(headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "CountOrgMessageOpenSceneGroups",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/chats/sceneGroups/counts`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CountOrgMessageOpenSceneGroupsResponse({}));
    }
    /**
     * 
     * @returns CountOrgMessageOpenSceneGroupsResponse
     */
    async countOrgMessageOpenSceneGroups() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CountOrgMessageOpenSceneGroupsHeaders({});
        return await this.countOrgMessageOpenSceneGroupsWithOptions(headers, runtime);
    }
    /**
     * 
     *
     * @param headers - CountSceneGroupsByTemplateIdHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CountSceneGroupsByTemplateIdResponse
     */
    async countSceneGroupsByTemplateIdWithOptions(templateId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "CountSceneGroupsByTemplateId",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/chats/sceneGroups/templates/${templateId}/counts`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CountSceneGroupsByTemplateIdResponse({}));
    }
    /**
     * 
     * @returns CountSceneGroupsByTemplateIdResponse
     */
    async countSceneGroupsByTemplateId(templateId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CountSceneGroupsByTemplateIdHeaders({});
        return await this.countSceneGroupsByTemplateIdWithOptions(templateId, headers, runtime);
    }
    /**
     * 
     *
     * @param request - CreateCoupleGroupConversationRequest
     * @param headers - CreateCoupleGroupConversationHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateCoupleGroupConversationResponse
     */
    async createCoupleGroupConversationWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appUserId)) {
            body["appUserId"] = request.appUserId;
        }
        if (!tea_util_1.default.isUnset(request.groupAvatar)) {
            body["groupAvatar"] = request.groupAvatar;
        }
        if (!tea_util_1.default.isUnset(request.groupName)) {
            body["groupName"] = request.groupName;
        }
        if (!tea_util_1.default.isUnset(request.groupOwnerId)) {
            body["groupOwnerId"] = request.groupOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.groupTemplateId)) {
            body["groupTemplateId"] = request.groupTemplateId;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateCoupleGroupConversation",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interconnections/coupleGroups`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateCoupleGroupConversationResponse({}));
    }
    /**
     * 
     *
     * @param request - CreateCoupleGroupConversationRequest
     * @returns CreateCoupleGroupConversationResponse
     */
    async createCoupleGroupConversation(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateCoupleGroupConversationHeaders({});
        return await this.createCoupleGroupConversationWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - CreateGroupConversationRequest
     * @param headers - CreateGroupConversationHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateGroupConversationResponse
     */
    async createGroupConversationWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appUserIds)) {
            body["appUserIds"] = request.appUserIds;
        }
        if (!tea_util_1.default.isUnset(request.groupAvatar)) {
            body["groupAvatar"] = request.groupAvatar;
        }
        if (!tea_util_1.default.isUnset(request.groupName)) {
            body["groupName"] = request.groupName;
        }
        if (!tea_util_1.default.isUnset(request.groupOwnerId)) {
            body["groupOwnerId"] = request.groupOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.groupOwnerType)) {
            body["groupOwnerType"] = request.groupOwnerType;
        }
        if (!tea_util_1.default.isUnset(request.groupTemplateId)) {
            body["groupTemplateId"] = request.groupTemplateId;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.userIds)) {
            body["userIds"] = request.userIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateGroupConversation",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interconnections/groups`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateGroupConversationResponse({}));
    }
    /**
     * 
     *
     * @param request - CreateGroupConversationRequest
     * @returns CreateGroupConversationResponse
     */
    async createGroupConversation(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateGroupConversationHeaders({});
        return await this.createGroupConversationWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - CreateInterconnectionRequest
     * @param headers - CreateInterconnectionHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateInterconnectionResponse
     */
    async createInterconnectionWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.interconnections)) {
            body["interconnections"] = request.interconnections;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateInterconnection",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interconnections`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateInterconnectionResponse({}));
    }
    /**
     * 
     *
     * @param request - CreateInterconnectionRequest
     * @returns CreateInterconnectionResponse
     */
    async createInterconnection(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateInterconnectionHeaders({});
        return await this.createInterconnectionWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - CreateSceneGroupConversationRequest
     * @param headers - CreateSceneGroupConversationHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateSceneGroupConversationResponse
     */
    async createSceneGroupConversationWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.features)) {
            body["features"] = request.features;
        }
        if (!tea_util_1.default.isUnset(request.groupName)) {
            body["groupName"] = request.groupName;
        }
        if (!tea_util_1.default.isUnset(request.groupOwnerId)) {
            body["groupOwnerId"] = request.groupOwnerId;
        }
        if (!tea_util_1.default.isUnset(request.icon)) {
            body["icon"] = request.icon;
        }
        if (!tea_util_1.default.isUnset(request.managementOptions)) {
            body["managementOptions"] = request.managementOptions;
        }
        if (!tea_util_1.default.isUnset(request.templateId)) {
            body["templateId"] = request.templateId;
        }
        if (!tea_util_1.default.isUnset(request.userIdList)) {
            body["userIdList"] = request.userIdList;
        }
        if (!tea_util_1.default.isUnset(request.uuid)) {
            body["uuid"] = request.uuid;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateSceneGroupConversation",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/sceneGroups`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateSceneGroupConversationResponse({}));
    }
    /**
     * 
     *
     * @param request - CreateSceneGroupConversationRequest
     * @returns CreateSceneGroupConversationResponse
     */
    async createSceneGroupConversation(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateSceneGroupConversationHeaders({});
        return await this.createSceneGroupConversationWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - CreateStoreGroupConversationRequest
     * @param headers - CreateStoreGroupConversationHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateStoreGroupConversationResponse
     */
    async createStoreGroupConversationWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appUserId)) {
            body["appUserId"] = request.appUserId;
        }
        if (!tea_util_1.default.isUnset(request.businessUniqueKey)) {
            body["businessUniqueKey"] = request.businessUniqueKey;
        }
        if (!tea_util_1.default.isUnset(request.groupAvatar)) {
            body["groupAvatar"] = request.groupAvatar;
        }
        if (!tea_util_1.default.isUnset(request.groupName)) {
            body["groupName"] = request.groupName;
        }
        if (!tea_util_1.default.isUnset(request.groupTemplateId)) {
            body["groupTemplateId"] = request.groupTemplateId;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.userIds)) {
            body["userIds"] = request.userIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateStoreGroupConversation",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interconnections/storeGroups`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateStoreGroupConversationResponse({}));
    }
    /**
     * 
     *
     * @param request - CreateStoreGroupConversationRequest
     * @returns CreateStoreGroupConversationResponse
     */
    async createStoreGroupConversation(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateStoreGroupConversationHeaders({});
        return await this.createStoreGroupConversationWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - DebugUnfurlingRegisterRequest
     * @param headers - DebugUnfurlingRegisterHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DebugUnfurlingRegisterResponse
     */
    async debugUnfurlingRegisterWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            body["appId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.grayGroupIdList)) {
            body["grayGroupIdList"] = request.grayGroupIdList;
        }
        if (!tea_util_1.default.isUnset(request.grayUserIdList)) {
            body["grayUserIdList"] = request.grayUserIdList;
        }
        if (!tea_util_1.default.isUnset(request.id)) {
            body["id"] = request.id;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DebugUnfurlingRegister",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/unfurling/rules/debug`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DebugUnfurlingRegisterResponse({}));
    }
    /**
     * 
     *
     * @param request - DebugUnfurlingRegisterRequest
     * @returns DebugUnfurlingRegisterResponse
     */
    async debugUnfurlingRegister(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DebugUnfurlingRegisterHeaders({});
        return await this.debugUnfurlingRegisterWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - DeleteOrgTextEmotionRequest
     * @param headers - DeleteOrgTextEmotionHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeleteOrgTextEmotionResponse
     */
    async deleteOrgTextEmotionWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.deptId)) {
            body["deptId"] = request.deptId;
        }
        if (!tea_util_1.default.isUnset(request.emotionIds)) {
            body["emotionIds"] = request.emotionIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteOrgTextEmotion",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/organizations/textEmotions/remove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteOrgTextEmotionResponse({}));
    }
    /**
     * 
     *
     * @param request - DeleteOrgTextEmotionRequest
     * @returns DeleteOrgTextEmotionResponse
     */
    async deleteOrgTextEmotion(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteOrgTextEmotionHeaders({});
        return await this.deleteOrgTextEmotionWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - DismissGroupConversationRequest
     * @param headers - DismissGroupConversationHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DismissGroupConversationResponse
     */
    async dismissGroupConversationWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DismissGroupConversation",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interconnections/groups/dismiss`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DismissGroupConversationResponse({}));
    }
    /**
     * 
     *
     * @param request - DismissGroupConversationRequest
     * @returns DismissGroupConversationResponse
     */
    async dismissGroupConversation(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DismissGroupConversationHeaders({});
        return await this.dismissGroupConversationWithOptions(request, headers, runtime);
    }
    /**
     * ToB
     *
     * @param request - GetConversationUrlRequest
     * @param headers - GetConversationUrlHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetConversationUrlResponse
     */
    async getConversationUrlWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appUserId)) {
            body["appUserId"] = request.appUserId;
        }
        if (!tea_util_1.default.isUnset(request.channelCode)) {
            body["channelCode"] = request.channelCode;
        }
        if (!tea_util_1.default.isUnset(request.deviceId)) {
            body["deviceId"] = request.deviceId;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetConversationUrl",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/conversations/urls`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetConversationUrlResponse({}));
    }
    /**
     * ToB
     *
     * @param request - GetConversationUrlRequest
     * @returns GetConversationUrlResponse
     */
    async getConversationUrl(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetConversationUrlHeaders({});
        return await this.getConversationUrlWithOptions(request, headers, runtime);
    }
    /**
     * (&Z&)
     *
     * @param request - GetFamilySchoolConversationMsgRequest
     * @param headers - GetFamilySchoolConversationMsgHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetFamilySchoolConversationMsgResponse
     */
    async getFamilySchoolConversationMsgWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.msgTypes)) {
            body["msgTypes"] = request.msgTypes;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetFamilySchoolConversationMsg",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/conversations/familySchools/messages/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetFamilySchoolConversationMsgResponse({}));
    }
    /**
     * (&Z&)
     *
     * @param request - GetFamilySchoolConversationMsgRequest
     * @returns GetFamilySchoolConversationMsgResponse
     */
    async getFamilySchoolConversationMsg(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFamilySchoolConversationMsgHeaders({});
        return await this.getFamilySchoolConversationMsgWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - GetFamilySchoolConversationsRequest
     * @param headers - GetFamilySchoolConversationsHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetFamilySchoolConversationsResponse
     */
    async getFamilySchoolConversationsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetFamilySchoolConversations",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/conversations/familySchools/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetFamilySchoolConversationsResponse({}));
    }
    /**
     * 
     *
     * @param request - GetFamilySchoolConversationsRequest
     * @returns GetFamilySchoolConversationsResponse
     */
    async getFamilySchoolConversations(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFamilySchoolConversationsHeaders({});
        return await this.getFamilySchoolConversationsWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - GetInnerGroupMembersRequest
     * @param headers - GetInnerGroupMembersHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetInnerGroupMembersResponse
     */
    async getInnerGroupMembersWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetInnerGroupMembers",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/innerGroups/members/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetInnerGroupMembersResponse({}));
    }
    /**
     * 
     *
     * @param request - GetInnerGroupMembersRequest
     * @returns GetInnerGroupMembersResponse
     */
    async getInnerGroupMembers(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetInnerGroupMembersHeaders({});
        return await this.getInnerGroupMembersWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - GetInterconnectionUrlRequest
     * @param headers - GetInterconnectionUrlHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetInterconnectionUrlResponse
     */
    async getInterconnectionUrlWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appUserAvatar)) {
            body["appUserAvatar"] = request.appUserAvatar;
        }
        if (!tea_util_1.default.isUnset(request.appUserAvatarType)) {
            body["appUserAvatarType"] = request.appUserAvatarType;
        }
        if (!tea_util_1.default.isUnset(request.appUserId)) {
            body["appUserId"] = request.appUserId;
        }
        if (!tea_util_1.default.isUnset(request.appUserMobileNumber)) {
            body["appUserMobileNumber"] = request.appUserMobileNumber;
        }
        if (!tea_util_1.default.isUnset(request.appUserName)) {
            body["appUserName"] = request.appUserName;
        }
        if (!tea_util_1.default.isUnset(request.msgPageType)) {
            body["msgPageType"] = request.msgPageType;
        }
        if (!tea_util_1.default.isUnset(request.qrCode)) {
            body["qrCode"] = request.qrCode;
        }
        if (!tea_util_1.default.isUnset(request.signature)) {
            body["signature"] = request.signature;
        }
        if (!tea_util_1.default.isUnset(request.sourceCode)) {
            body["sourceCode"] = request.sourceCode;
        }
        if (!tea_util_1.default.isUnset(request.sourceType)) {
            body["sourceType"] = request.sourceType;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetInterconnectionUrl",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interconnections/sessions/urls`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetInterconnectionUrlResponse({}));
    }
    /**
     * 
     *
     * @param request - GetInterconnectionUrlRequest
     * @returns GetInterconnectionUrlResponse
     */
    async getInterconnectionUrl(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetInterconnectionUrlHeaders({});
        return await this.getInterconnectionUrlWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - GetNewestInnerGroupsRequest
     * @param headers - GetNewestInnerGroupsHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetNewestInnerGroupsResponse
     */
    async getNewestInnerGroupsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetNewestInnerGroups",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/activities/innerGroups`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetNewestInnerGroupsResponse({}));
    }
    /**
     * 
     *
     * @param request - GetNewestInnerGroupsRequest
     * @returns GetNewestInnerGroupsResponse
     */
    async getNewestInnerGroups(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetNewestInnerGroupsHeaders({});
        return await this.getNewestInnerGroupsWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - GetSceneGroupInfoRequest
     * @param headers - GetSceneGroupInfoHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetSceneGroupInfoResponse
     */
    async getSceneGroupInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.coolAppCode)) {
            body["coolAppCode"] = request.coolAppCode;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetSceneGroupInfo",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/sceneGroups/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetSceneGroupInfoResponse({}));
    }
    /**
     * 
     *
     * @param request - GetSceneGroupInfoRequest
     * @returns GetSceneGroupInfoResponse
     */
    async getSceneGroupInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetSceneGroupInfoHeaders({});
        return await this.getSceneGroupInfoWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - GetSceneGroupMembersRequest
     * @param headers - GetSceneGroupMembersHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetSceneGroupMembersResponse
     */
    async getSceneGroupMembersWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.coolAppCode)) {
            body["coolAppCode"] = request.coolAppCode;
        }
        if (!tea_util_1.default.isUnset(request.cursor)) {
            body["cursor"] = request.cursor;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.size)) {
            body["size"] = request.size;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetSceneGroupMembers",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/sceneGroups/members/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetSceneGroupMembersResponse({}));
    }
    /**
     * 
     *
     * @param request - GetSceneGroupMembersRequest
     * @returns GetSceneGroupMembersResponse
     */
    async getSceneGroupMembers(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetSceneGroupMembersHeaders({});
        return await this.getSceneGroupMembersWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param headers - GetSceneGroupTemplateMessageOpenStatusHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetSceneGroupTemplateMessageOpenStatusResponse
     */
    async getSceneGroupTemplateMessageOpenStatusWithOptions(templateId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetSceneGroupTemplateMessageOpenStatus",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/chats/sceneGroups/templates/${templateId}/messageOpenStatuses`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetSceneGroupTemplateMessageOpenStatusResponse({}));
    }
    /**
     * 
     * @returns GetSceneGroupTemplateMessageOpenStatusResponse
     */
    async getSceneGroupTemplateMessageOpenStatus(templateId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetSceneGroupTemplateMessageOpenStatusHeaders({});
        return await this.getSceneGroupTemplateMessageOpenStatusWithOptions(templateId, headers, runtime);
    }
    /**
     * 
     *
     * @param request - GroupBanWordsRequest
     * @param headers - GroupBanWordsHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GroupBanWordsResponse
     */
    async groupBanWordsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.banWordsMode)) {
            body["banWordsMode"] = request.banWordsMode;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.options)) {
            body["options"] = request.options;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GroupBanWords",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/groups/words/ban`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "none",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GroupBanWordsResponse({}));
    }
    /**
     * 
     *
     * @param request - GroupBanWordsRequest
     * @returns GroupBanWordsResponse
     */
    async groupBanWords(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GroupBanWordsHeaders({});
        return await this.groupBanWordsWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - GroupCapacityInquiryRequest
     * @param headers - GroupCapacityInquiryHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GroupCapacityInquiryResponse
     */
    async groupCapacityInquiryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.effectiveDuration)) {
            body["effectiveDuration"] = request.effectiveDuration;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.operator)) {
            body["operator"] = request.operator;
        }
        if (!tea_util_1.default.isUnset(request.options)) {
            body["options"] = request.options;
        }
        if (!tea_util_1.default.isUnset(request.targetCapacity)) {
            body["targetCapacity"] = request.targetCapacity;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GroupCapacityInquiry",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/groups/capacities/inquiries/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GroupCapacityInquiryResponse({}));
    }
    /**
     * 
     *
     * @param request - GroupCapacityInquiryRequest
     * @returns GroupCapacityInquiryResponse
     */
    async groupCapacityInquiry(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GroupCapacityInquiryHeaders({});
        return await this.groupCapacityInquiryWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - GroupCapacityOrderConfirmRequest
     * @param headers - GroupCapacityOrderConfirmHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GroupCapacityOrderConfirmResponse
     */
    async groupCapacityOrderConfirmWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.operator)) {
            body["operator"] = request.operator;
        }
        if (!tea_util_1.default.isUnset(request.orderId)) {
            body["orderId"] = request.orderId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GroupCapacityOrderConfirm",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/groups/capacities/orders/confirm`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GroupCapacityOrderConfirmResponse({}));
    }
    /**
     * 
     *
     * @param request - GroupCapacityOrderConfirmRequest
     * @returns GroupCapacityOrderConfirmResponse
     */
    async groupCapacityOrderConfirm(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GroupCapacityOrderConfirmHeaders({});
        return await this.groupCapacityOrderConfirmWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - GroupCapacityOrderPlaceRequest
     * @param headers - GroupCapacityOrderPlaceHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GroupCapacityOrderPlaceResponse
     */
    async groupCapacityOrderPlaceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.actualPrice)) {
            body["actualPrice"] = request.actualPrice;
        }
        if (!tea_util_1.default.isUnset(request.currentCapacity)) {
            body["currentCapacity"] = request.currentCapacity;
        }
        if (!tea_util_1.default.isUnset(request.currentEffectUntil)) {
            body["currentEffectUntil"] = request.currentEffectUntil;
        }
        if (!tea_util_1.default.isUnset(request.discount)) {
            body["discount"] = request.discount;
        }
        if (!tea_util_1.default.isUnset(request.extInfo)) {
            body["extInfo"] = request.extInfo;
        }
        if (!tea_util_1.default.isUnset(request.markedPrice)) {
            body["markedPrice"] = request.markedPrice;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.operator)) {
            body["operator"] = request.operator;
        }
        if (!tea_util_1.default.isUnset(request.targetCapacity)) {
            body["targetCapacity"] = request.targetCapacity;
        }
        if (!tea_util_1.default.isUnset(request.targetEffectUntil)) {
            body["targetEffectUntil"] = request.targetEffectUntil;
        }
        if (!tea_util_1.default.isUnset(request.token)) {
            body["token"] = request.token;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GroupCapacityOrderPlace",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/groups/capacities/orders/place`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GroupCapacityOrderPlaceResponse({}));
    }
    /**
     * 
     *
     * @param request - GroupCapacityOrderPlaceRequest
     * @returns GroupCapacityOrderPlaceResponse
     */
    async groupCapacityOrderPlace(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GroupCapacityOrderPlaceHeaders({});
        return await this.groupCapacityOrderPlaceWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - GroupManageQueryRequest
     * @param headers - GroupManageQueryHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GroupManageQueryResponse
     */
    async groupManageQueryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.createdAfter)) {
            body["createdAfter"] = request.createdAfter;
        }
        if (!tea_util_1.default.isUnset(request.groupId)) {
            body["groupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.groupMemberSamples)) {
            body["groupMemberSamples"] = request.groupMemberSamples;
        }
        if (!tea_util_1.default.isUnset(request.groupOwner)) {
            body["groupOwner"] = request.groupOwner;
        }
        if (!tea_util_1.default.isUnset(request.groupTitleKeywords)) {
            body["groupTitleKeywords"] = request.groupTitleKeywords;
        }
        if (!tea_util_1.default.isUnset(request.groupUrl)) {
            body["groupUrl"] = request.groupUrl;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.membersOver)) {
            body["membersOver"] = request.membersOver;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GroupManageQuery",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/groups/managements/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GroupManageQueryResponse({}));
    }
    /**
     * 
     *
     * @param request - GroupManageQueryRequest
     * @returns GroupManageQueryResponse
     */
    async groupManageQuery(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GroupManageQueryHeaders({});
        return await this.groupManageQueryWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - GroupManageReduceRequest
     * @param headers - GroupManageReduceHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GroupManageReduceResponse
     */
    async groupManageReduceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.capacityLimit)) {
            body["capacityLimit"] = request.capacityLimit;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.options)) {
            body["options"] = request.options;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GroupManageReduce",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/groups/capacities/reduce`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "none",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GroupManageReduceResponse({}));
    }
    /**
     * 
     *
     * @param request - GroupManageReduceRequest
     * @returns GroupManageReduceResponse
     */
    async groupManageReduce(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GroupManageReduceHeaders({});
        return await this.groupManageReduceWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - InstallRobotToOrgRequest
     * @param headers - InstallRobotToOrgHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns InstallRobotToOrgResponse
     */
    async installRobotToOrgWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.brief)) {
            body["brief"] = request.brief;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.icon)) {
            body["icon"] = request.icon;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.outgoingToken)) {
            body["outgoingToken"] = request.outgoingToken;
        }
        if (!tea_util_1.default.isUnset(request.outgoingUrl)) {
            body["outgoingUrl"] = request.outgoingUrl;
        }
        if (!tea_util_1.default.isUnset(request.previewMediaId)) {
            body["previewMediaId"] = request.previewMediaId;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "InstallRobotToOrg",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/organizations/robots/install`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new InstallRobotToOrgResponse({}));
    }
    /**
     * 
     *
     * @param request - InstallRobotToOrgRequest
     * @returns InstallRobotToOrgResponse
     */
    async installRobotToOrg(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new InstallRobotToOrgHeaders({});
        return await this.installRobotToOrgWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - InteractiveCardCreateInstanceRequest
     * @param headers - InteractiveCardCreateInstanceHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns InteractiveCardCreateInstanceResponse
     */
    async interactiveCardCreateInstanceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.callbackRouteKey)) {
            body["callbackRouteKey"] = request.callbackRouteKey;
        }
        if (!tea_util_1.default.isUnset(request.cardData)) {
            body["cardData"] = request.cardData;
        }
        if (!tea_util_1.default.isUnset(request.cardTemplateId)) {
            body["cardTemplateId"] = request.cardTemplateId;
        }
        if (!tea_util_1.default.isUnset(request.chatBotId)) {
            body["chatBotId"] = request.chatBotId;
        }
        if (!tea_util_1.default.isUnset(request.conversationType)) {
            body["conversationType"] = request.conversationType;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.outTrackId)) {
            body["outTrackId"] = request.outTrackId;
        }
        if (!tea_util_1.default.isUnset(request.privateData)) {
            body["privateData"] = request.privateData;
        }
        if (!tea_util_1.default.isUnset(request.pullStrategy)) {
            body["pullStrategy"] = request.pullStrategy;
        }
        if (!tea_util_1.default.isUnset(request.receiverUserIdList)) {
            body["receiverUserIdList"] = request.receiverUserIdList;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        if (!tea_util_1.default.isUnset(request.userIdType)) {
            body["userIdType"] = request.userIdType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "InteractiveCardCreateInstance",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interactiveCards/instances`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new InteractiveCardCreateInstanceResponse({}));
    }
    /**
     * 
     *
     * @param request - InteractiveCardCreateInstanceRequest
     * @returns InteractiveCardCreateInstanceResponse
     */
    async interactiveCardCreateInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new InteractiveCardCreateInstanceHeaders({});
        return await this.interactiveCardCreateInstanceWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - ListGroupTemplatesByOrgIdRequest
     * @param headers - ListGroupTemplatesByOrgIdHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ListGroupTemplatesByOrgIdResponse
     */
    async listGroupTemplatesByOrgIdWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["pageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["pageSize"] = request.pageSize;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListGroupTemplatesByOrgId",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/chats/sceneGroups/templates/lists`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListGroupTemplatesByOrgIdResponse({}));
    }
    /**
     * 
     *
     * @param request - ListGroupTemplatesByOrgIdRequest
     * @returns ListGroupTemplatesByOrgIdResponse
     */
    async listGroupTemplatesByOrgId(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListGroupTemplatesByOrgIdHeaders({});
        return await this.listGroupTemplatesByOrgIdWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param headers - ListOrgTextEmotionHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ListOrgTextEmotionResponse
     */
    async listOrgTextEmotionWithOptions(headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "ListOrgTextEmotion",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/organizations/textEmotions`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListOrgTextEmotionResponse({}));
    }
    /**
     * 
     * @returns ListOrgTextEmotionResponse
     */
    async listOrgTextEmotion() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListOrgTextEmotionHeaders({});
        return await this.listOrgTextEmotionWithOptions(headers, runtime);
    }
    /**
     * id
     *
     * @param request - ListSceneGroupsByTemplateIdRequest
     * @param headers - ListSceneGroupsByTemplateIdHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ListSceneGroupsByTemplateIdResponse
     */
    async listSceneGroupsByTemplateIdWithOptions(templateId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["pageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["pageSize"] = request.pageSize;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListSceneGroupsByTemplateId",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/chats/sceneGroups/templates/${templateId}/lists`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListSceneGroupsByTemplateIdResponse({}));
    }
    /**
     * id
     *
     * @param request - ListSceneGroupsByTemplateIdRequest
     * @returns ListSceneGroupsByTemplateIdResponse
     */
    async listSceneGroupsByTemplateId(templateId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListSceneGroupsByTemplateIdHeaders({});
        return await this.listSceneGroupsByTemplateIdWithOptions(templateId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - OfflineUnfurlingRegisterRequest
     * @param headers - OfflineUnfurlingRegisterHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns OfflineUnfurlingRegisterResponse
     */
    async offlineUnfurlingRegisterWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            body["appId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.id)) {
            body["id"] = request.id;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "OfflineUnfurlingRegister",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/unfurling/rules/remove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new OfflineUnfurlingRegisterResponse({}));
    }
    /**
     * 
     *
     * @param request - OfflineUnfurlingRegisterRequest
     * @returns OfflineUnfurlingRegisterResponse
     */
    async offlineUnfurlingRegister(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new OfflineUnfurlingRegisterHeaders({});
        return await this.offlineUnfurlingRegisterWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - OpenGroupRoleAddRequest
     * @param headers - OpenGroupRoleAddHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns OpenGroupRoleAddResponse
     */
    async openGroupRoleAddWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.roleName)) {
            body["roleName"] = request.roleName;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "OpenGroupRoleAdd",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/groups/roles`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new OpenGroupRoleAddResponse({}));
    }
    /**
     * 
     *
     * @param request - OpenGroupRoleAddRequest
     * @returns OpenGroupRoleAddResponse
     */
    async openGroupRoleAdd(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new OpenGroupRoleAddHeaders({});
        return await this.openGroupRoleAddWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - OpenGroupRoleQueryRequest
     * @param headers - OpenGroupRoleQueryHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns OpenGroupRoleQueryResponse
     */
    async openGroupRoleQueryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "OpenGroupRoleQuery",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/groups/roles/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new OpenGroupRoleQueryResponse({}));
    }
    /**
     * 
     *
     * @param request - OpenGroupRoleQueryRequest
     * @returns OpenGroupRoleQueryResponse
     */
    async openGroupRoleQuery(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new OpenGroupRoleQueryHeaders({});
        return await this.openGroupRoleQueryWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - OpenGroupRoleRemoveRequest
     * @param headers - OpenGroupRoleRemoveHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns OpenGroupRoleRemoveResponse
     */
    async openGroupRoleRemoveWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openRoleId)) {
            body["openRoleId"] = request.openRoleId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "OpenGroupRoleRemove",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/groups/roles/remove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new OpenGroupRoleRemoveResponse({}));
    }
    /**
     * 
     *
     * @param request - OpenGroupRoleRemoveRequest
     * @returns OpenGroupRoleRemoveResponse
     */
    async openGroupRoleRemove(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new OpenGroupRoleRemoveHeaders({});
        return await this.openGroupRoleRemoveWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - OpenGroupRoleUpdateRequest
     * @param headers - OpenGroupRoleUpdateHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns OpenGroupRoleUpdateResponse
     */
    async openGroupRoleUpdateWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openRoleId)) {
            body["openRoleId"] = request.openRoleId;
        }
        if (!tea_util_1.default.isUnset(request.roleName)) {
            body["roleName"] = request.roleName;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "OpenGroupRoleUpdate",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/groups/roles`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new OpenGroupRoleUpdateResponse({}));
    }
    /**
     * 
     *
     * @param request - OpenGroupRoleUpdateRequest
     * @returns OpenGroupRoleUpdateResponse
     */
    async openGroupRoleUpdate(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new OpenGroupRoleUpdateHeaders({});
        return await this.openGroupRoleUpdateWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - OpenGroupUserRoleQueryRequest
     * @param headers - OpenGroupUserRoleQueryHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns OpenGroupUserRoleQueryResponse
     */
    async openGroupUserRoleQueryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        if (!tea_util_1.default.isUnset(request.viewedUserId)) {
            body["viewedUserId"] = request.viewedUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "OpenGroupUserRoleQuery",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/groups/users/roles/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new OpenGroupUserRoleQueryResponse({}));
    }
    /**
     * 
     *
     * @param request - OpenGroupUserRoleQueryRequest
     * @returns OpenGroupUserRoleQueryResponse
     */
    async openGroupUserRoleQuery(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new OpenGroupUserRoleQueryHeaders({});
        return await this.openGroupUserRoleQueryWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - OpenInnerGroupTransferToDeptGroupRequest
     * @param headers - OpenInnerGroupTransferToDeptGroupHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns OpenInnerGroupTransferToDeptGroupResponse
     */
    async openInnerGroupTransferToDeptGroupWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.deptId)) {
            body["deptId"] = request.deptId;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "OpenInnerGroupTransferToDeptGroup",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/innerGroups/transferToDeptGroups`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new OpenInnerGroupTransferToDeptGroupResponse({}));
    }
    /**
     * 
     *
     * @param request - OpenInnerGroupTransferToDeptGroupRequest
     * @returns OpenInnerGroupTransferToDeptGroupResponse
     */
    async openInnerGroupTransferToDeptGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new OpenInnerGroupTransferToDeptGroupHeaders({});
        return await this.openInnerGroupTransferToDeptGroupWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - OpenSearchGroupListRequest
     * @param headers - OpenSearchGroupListHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns OpenSearchGroupListResponse
     */
    async openSearchGroupListWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.keyword)) {
            body["keyword"] = request.keyword;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "OpenSearchGroupList",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/groups/search`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new OpenSearchGroupListResponse({}));
    }
    /**
     * 
     *
     * @param request - OpenSearchGroupListRequest
     * @returns OpenSearchGroupListResponse
     */
    async openSearchGroupList(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new OpenSearchGroupListHeaders({});
        return await this.openSearchGroupListWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - OpenUserSendCardMessageRequest
     * @param headers - OpenUserSendCardMessageHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns OpenUserSendCardMessageResponse
     */
    async openUserSendCardMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.cardContent)) {
            body["cardContent"] = request.cardContent;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.receiveUserId)) {
            body["receiveUserId"] = request.receiveUserId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "OpenUserSendCardMessage",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/cardMessages/users/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new OpenUserSendCardMessageResponse({}));
    }
    /**
     * 
     *
     * @param request - OpenUserSendCardMessageRequest
     * @returns OpenUserSendCardMessageResponse
     */
    async openUserSendCardMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new OpenUserSendCardMessageHeaders({});
        return await this.openUserSendCardMessageWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - PersonalSendCardMessageRequest
     * @param headers - PersonalSendCardMessageHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns PersonalSendCardMessageResponse
     */
    async personalSendCardMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.atUserIds)) {
            body["atUserIds"] = request.atUserIds;
        }
        if (!tea_util_1.default.isUnset(request.cardContent)) {
            body["cardContent"] = request.cardContent;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.receiveUserId)) {
            body["receiveUserId"] = request.receiveUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "PersonalSendCardMessage",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/me/messages/cards/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new PersonalSendCardMessageResponse({}));
    }
    /**
     * 
     *
     * @param request - PersonalSendCardMessageRequest
     * @returns PersonalSendCardMessageResponse
     */
    async personalSendCardMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new PersonalSendCardMessageHeaders({});
        return await this.personalSendCardMessageWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryGroupInfoByMemberAuthRequest
     * @param headers - QueryGroupInfoByMemberAuthHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryGroupInfoByMemberAuthResponse
     */
    async queryGroupInfoByMemberAuthWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.coolAppCode)) {
            body["coolAppCode"] = request.coolAppCode;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryGroupInfoByMemberAuth",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/memberAuthorizations/groups/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryGroupInfoByMemberAuthResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryGroupInfoByMemberAuthRequest
     * @returns QueryGroupInfoByMemberAuthResponse
     */
    async queryGroupInfoByMemberAuth(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryGroupInfoByMemberAuthHeaders({});
        return await this.queryGroupInfoByMemberAuthWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryGroupMemberRequest
     * @param headers - QueryGroupMemberHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryGroupMemberResponse
     */
    async queryGroupMemberWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            query["openConversationId"] = request.openConversationId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryGroupMember",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interconnections/conversations/members`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryGroupMemberResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryGroupMemberRequest
     * @returns QueryGroupMemberResponse
     */
    async queryGroupMember(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryGroupMemberHeaders({});
        return await this.queryGroupMemberWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryGroupMemberByMemberAuthRequest
     * @param headers - QueryGroupMemberByMemberAuthHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryGroupMemberByMemberAuthResponse
     */
    async queryGroupMemberByMemberAuthWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.coolAppCode)) {
            body["coolAppCode"] = request.coolAppCode;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryGroupMemberByMemberAuth",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/memberAuthorizations/groups/members/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryGroupMemberByMemberAuthResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryGroupMemberByMemberAuthRequest
     * @returns QueryGroupMemberByMemberAuthResponse
     */
    async queryGroupMemberByMemberAuth(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryGroupMemberByMemberAuthHeaders({});
        return await this.queryGroupMemberByMemberAuthWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryGroupMuteStatusRequest
     * @param headers - QueryGroupMuteStatusHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryGroupMuteStatusResponse
     */
    async queryGroupMuteStatusWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            query["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryGroupMuteStatus",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/sceneGroups/muteSettings`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryGroupMuteStatusResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryGroupMuteStatusRequest
     * @returns QueryGroupMuteStatusResponse
     */
    async queryGroupMuteStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryGroupMuteStatusHeaders({});
        return await this.queryGroupMuteStatusWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryInnerGroupMemberListRequest
     * @param headers - QueryInnerGroupMemberListHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryInnerGroupMemberListResponse
     */
    async queryInnerGroupMemberListWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryInnerGroupMemberList",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/innerGroups/memberLists/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryInnerGroupMemberListResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryInnerGroupMemberListRequest
     * @returns QueryInnerGroupMemberListResponse
     */
    async queryInnerGroupMemberList(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryInnerGroupMemberListHeaders({});
        return await this.queryInnerGroupMemberListWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryInnerGroupRecentListRequest
     * @param headers - QueryInnerGroupRecentListHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryInnerGroupRecentListResponse
     */
    async queryInnerGroupRecentListWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryInnerGroupRecentList",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/innerGroups/recentLists`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryInnerGroupRecentListResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryInnerGroupRecentListRequest
     * @returns QueryInnerGroupRecentListResponse
     */
    async queryInnerGroupRecentList(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryInnerGroupRecentListHeaders({});
        return await this.queryInnerGroupRecentListWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryMembersOfGroupRoleRequest
     * @param headers - QueryMembersOfGroupRoleHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryMembersOfGroupRoleResponse
     */
    async queryMembersOfGroupRoleWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openRoleId)) {
            body["openRoleId"] = request.openRoleId;
        }
        if (!tea_util_1.default.isUnset(request.timestamp)) {
            body["timestamp"] = request.timestamp;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryMembersOfGroupRole",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/sceneGroups/roles/members/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryMembersOfGroupRoleResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryMembersOfGroupRoleRequest
     * @returns QueryMembersOfGroupRoleResponse
     */
    async queryMembersOfGroupRole(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryMembersOfGroupRoleHeaders({});
        return await this.queryMembersOfGroupRoleWithOptions(request, headers, runtime);
    }
    /**
     * openTaskId
     *
     * @param request - QueryMessageSendResultRequest
     * @param headers - QueryMessageSendResultHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryMessageSendResultResponse
     */
    async queryMessageSendResultWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openTaskId)) {
            body["openTaskId"] = request.openTaskId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryMessageSendResult",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/messages/sendResults/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryMessageSendResultResponse({}));
    }
    /**
     * openTaskId
     *
     * @param request - QueryMessageSendResultRequest
     * @returns QueryMessageSendResultResponse
     */
    async queryMessageSendResult(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryMessageSendResultHeaders({});
        return await this.queryMessageSendResultWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryOpenConversationReceiveUserRequest
     * @param headers - QueryOpenConversationReceiveUserHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryOpenConversationReceiveUserResponse
     */
    async queryOpenConversationReceiveUserWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.sendUserId)) {
            body["sendUserId"] = request.sendUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryOpenConversationReceiveUser",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/otoChat/receiveUsers/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryOpenConversationReceiveUserResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryOpenConversationReceiveUserRequest
     * @returns QueryOpenConversationReceiveUserResponse
     */
    async queryOpenConversationReceiveUser(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryOpenConversationReceiveUserHeaders({});
        return await this.queryOpenConversationReceiveUserWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryOpenGroupBaseInfoRequest
     * @param headers - QueryOpenGroupBaseInfoHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryOpenGroupBaseInfoResponse
     */
    async queryOpenGroupBaseInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryOpenGroupBaseInfo",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/groups/baseInfos/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryOpenGroupBaseInfoResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryOpenGroupBaseInfoRequest
     * @returns QueryOpenGroupBaseInfoResponse
     */
    async queryOpenGroupBaseInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryOpenGroupBaseInfoHeaders({});
        return await this.queryOpenGroupBaseInfoWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryPersonalMessageReadStatusRequest
     * @param headers - QueryPersonalMessageReadStatusHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryPersonalMessageReadStatusResponse
     */
    async queryPersonalMessageReadStatusWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openMessageId)) {
            body["openMessageId"] = request.openMessageId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryPersonalMessageReadStatus",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/me/messages/readStatuses/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryPersonalMessageReadStatusResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryPersonalMessageReadStatusRequest
     * @returns QueryPersonalMessageReadStatusResponse
     */
    async queryPersonalMessageReadStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryPersonalMessageReadStatusHeaders({});
        return await this.queryPersonalMessageReadStatusWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryRecentConversationsRequest
     * @param headers - QueryRecentConversationsHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryRecentConversationsResponse
     */
    async queryRecentConversationsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.onlyHuman)) {
            body["onlyHuman"] = request.onlyHuman;
        }
        if (!tea_util_1.default.isUnset(request.onlyInnerGroup)) {
            body["onlyInnerGroup"] = request.onlyInnerGroup;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryRecentConversations",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/conversations/recentLists/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryRecentConversationsResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryRecentConversationsRequest
     * @returns QueryRecentConversationsResponse
     */
    async queryRecentConversations(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryRecentConversationsHeaders({});
        return await this.queryRecentConversationsWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QuerySceneGroupTemplateRobotRequest
     * @param headers - QuerySceneGroupTemplateRobotHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QuerySceneGroupTemplateRobotResponse
     */
    async querySceneGroupTemplateRobotWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            query["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            query["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QuerySceneGroupTemplateRobot",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/sceneGroups/templates/robots`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QuerySceneGroupTemplateRobotResponse({}));
    }
    /**
     * 
     *
     * @param request - QuerySceneGroupTemplateRobotRequest
     * @returns QuerySceneGroupTemplateRobotResponse
     */
    async querySceneGroupTemplateRobot(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QuerySceneGroupTemplateRobotHeaders({});
        return await this.querySceneGroupTemplateRobotWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QuerySingleGroupRequest
     * @param headers - QuerySingleGroupHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QuerySingleGroupResponse
     */
    async querySingleGroupWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.groupMembers)) {
            body["groupMembers"] = request.groupMembers;
        }
        if (!tea_util_1.default.isUnset(request.groupTemplateId)) {
            body["groupTemplateId"] = request.groupTemplateId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QuerySingleGroup",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interconnections/doubleGroups/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QuerySingleGroupResponse({}));
    }
    /**
     * 
     *
     * @param request - QuerySingleGroupRequest
     * @returns QuerySingleGroupResponse
     */
    async querySingleGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QuerySingleGroupHeaders({});
        return await this.querySingleGroupWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryUnReadMessageRequest
     * @param headers - QueryUnReadMessageHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryUnReadMessageResponse
     */
    async queryUnReadMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appUserId)) {
            body["appUserId"] = request.appUserId;
        }
        if (!tea_util_1.default.isUnset(request.openConversationIds)) {
            body["openConversationIds"] = request.openConversationIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryUnReadMessage",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interconnections/unReadMsgs/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryUnReadMessageResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryUnReadMessageRequest
     * @returns QueryUnReadMessageResponse
     */
    async queryUnReadMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryUnReadMessageHeaders({});
        return await this.queryUnReadMessageWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryUnfurlingRegisterCreatorRequest
     * @param headers - QueryUnfurlingRegisterCreatorHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryUnfurlingRegisterCreatorResponse
     */
    async queryUnfurlingRegisterCreatorWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.domain)) {
            query["domain"] = request.domain;
        }
        if (!tea_util_1.default.isUnset(request.path)) {
            query["path"] = request.path;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryUnfurlingRegisterCreator",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/unfurling/rules/creators`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryUnfurlingRegisterCreatorResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryUnfurlingRegisterCreatorRequest
     * @returns QueryUnfurlingRegisterCreatorResponse
     */
    async queryUnfurlingRegisterCreator(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryUnfurlingRegisterCreatorHeaders({});
        return await this.queryUnfurlingRegisterCreatorWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryUnfurlingRegisterInfoRequest
     * @param headers - QueryUnfurlingRegisterInfoHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryUnfurlingRegisterInfoResponse
     */
    async queryUnfurlingRegisterInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            query["appId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryUnfurlingRegisterInfo",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/unfurling/rules`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryUnfurlingRegisterInfoResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryUnfurlingRegisterInfoRequest
     * @returns QueryUnfurlingRegisterInfoResponse
     */
    async queryUnfurlingRegisterInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryUnfurlingRegisterInfoHeaders({});
        return await this.queryUnfurlingRegisterInfoWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - ReleaseUnfurlingRegisterRequest
     * @param headers - ReleaseUnfurlingRegisterHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ReleaseUnfurlingRegisterResponse
     */
    async releaseUnfurlingRegisterWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            body["appId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.id)) {
            body["id"] = request.id;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ReleaseUnfurlingRegister",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/unfurling/rules/publish`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ReleaseUnfurlingRegisterResponse({}));
    }
    /**
     * 
     *
     * @param request - ReleaseUnfurlingRegisterRequest
     * @returns ReleaseUnfurlingRegisterResponse
     */
    async releaseUnfurlingRegister(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ReleaseUnfurlingRegisterHeaders({});
        return await this.releaseUnfurlingRegisterWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - RemoveRobotFromConversationRequest
     * @param headers - RemoveRobotFromConversationHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns RemoveRobotFromConversationResponse
     */
    async removeRobotFromConversationWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.chatBotUserId)) {
            body["chatBotUserId"] = request.chatBotUserId;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RemoveRobotFromConversation",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/conversations/robots/remove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RemoveRobotFromConversationResponse({}));
    }
    /**
     * 
     *
     * @param request - RemoveRobotFromConversationRequest
     * @returns RemoveRobotFromConversationResponse
     */
    async removeRobotFromConversation(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RemoveRobotFromConversationHeaders({});
        return await this.removeRobotFromConversationWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - SearchInnerGroupsRequest
     * @param headers - SearchInnerGroupsHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns SearchInnerGroupsResponse
     */
    async searchInnerGroupsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.searchKey)) {
            body["searchKey"] = request.searchKey;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SearchInnerGroups",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/innerGroups/search`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SearchInnerGroupsResponse({}));
    }
    /**
     * 
     *
     * @param request - SearchInnerGroupsRequest
     * @returns SearchInnerGroupsResponse
     */
    async searchInnerGroups(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SearchInnerGroupsHeaders({});
        return await this.searchInnerGroupsWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - SendInteractiveCardRequest
     * @param headers - SendInteractiveCardHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns SendInteractiveCardResponse
     */
    async sendInteractiveCardWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.atOpenIds)) {
            body["atOpenIds"] = request.atOpenIds;
        }
        if (!tea_util_1.default.isUnset(request.callbackRouteKey)) {
            body["callbackRouteKey"] = request.callbackRouteKey;
        }
        if (!tea_util_1.default.isUnset(request.cardData)) {
            body["cardData"] = request.cardData;
        }
        if (!tea_util_1.default.isUnset(request.cardOptions)) {
            body["cardOptions"] = request.cardOptions;
        }
        if (!tea_util_1.default.isUnset(request.cardTemplateId)) {
            body["cardTemplateId"] = request.cardTemplateId;
        }
        if (!tea_util_1.default.isUnset(request.chatBotId)) {
            body["chatBotId"] = request.chatBotId;
        }
        if (!tea_util_1.default.isUnset(request.conversationType)) {
            body["conversationType"] = request.conversationType;
        }
        if (!tea_util_1.default.isUnset(request.digitalWorkerCode)) {
            body["digitalWorkerCode"] = request.digitalWorkerCode;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.outTrackId)) {
            body["outTrackId"] = request.outTrackId;
        }
        if (!tea_util_1.default.isUnset(request.privateData)) {
            body["privateData"] = request.privateData;
        }
        if (!tea_util_1.default.isUnset(request.pullStrategy)) {
            body["pullStrategy"] = request.pullStrategy;
        }
        if (!tea_util_1.default.isUnset(request.receiverUserIdList)) {
            body["receiverUserIdList"] = request.receiverUserIdList;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        if (!tea_util_1.default.isUnset(request.userIdType)) {
            body["userIdType"] = request.userIdType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SendInteractiveCard",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interactiveCards/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendInteractiveCardResponse({}));
    }
    /**
     * 
     *
     * @param request - SendInteractiveCardRequest
     * @returns SendInteractiveCardResponse
     */
    async sendInteractiveCard(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendInteractiveCardHeaders({});
        return await this.sendInteractiveCardWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - SendOTOInteractiveCardRequest
     * @param headers - SendOTOInteractiveCardHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns SendOTOInteractiveCardResponse
     */
    async sendOTOInteractiveCardWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.atOpenIds)) {
            body["atOpenIds"] = request.atOpenIds;
        }
        if (!tea_util_1.default.isUnset(request.callbackRouteKey)) {
            body["callbackRouteKey"] = request.callbackRouteKey;
        }
        if (!tea_util_1.default.isUnset(request.cardData)) {
            body["cardData"] = request.cardData;
        }
        if (!tea_util_1.default.isUnset(request.cardOptions)) {
            body["cardOptions"] = request.cardOptions;
        }
        if (!tea_util_1.default.isUnset(request.cardTemplateId)) {
            body["cardTemplateId"] = request.cardTemplateId;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.outTrackId)) {
            body["outTrackId"] = request.outTrackId;
        }
        if (!tea_util_1.default.isUnset(request.privateData)) {
            body["privateData"] = request.privateData;
        }
        if (!tea_util_1.default.isUnset(request.pullStrategy)) {
            body["pullStrategy"] = request.pullStrategy;
        }
        if (!tea_util_1.default.isUnset(request.receiverUserIdList)) {
            body["receiverUserIdList"] = request.receiverUserIdList;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        if (!tea_util_1.default.isUnset(request.userIdType)) {
            body["userIdType"] = request.userIdType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SendOTOInteractiveCard",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/privateChat/interactiveCards/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendOTOInteractiveCardResponse({}));
    }
    /**
     * 
     *
     * @param request - SendOTOInteractiveCardRequest
     * @returns SendOTOInteractiveCardResponse
     */
    async sendOTOInteractiveCard(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendOTOInteractiveCardHeaders({});
        return await this.sendOTOInteractiveCardWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - SendPersonalMessageRequest
     * @param headers - SendPersonalMessageHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns SendPersonalMessageResponse
     */
    async sendPersonalMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.msgType)) {
            body["msgType"] = request.msgType;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.receiverUid)) {
            body["receiverUid"] = request.receiverUid;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SendPersonalMessage",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/me/messages/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendPersonalMessageResponse({}));
    }
    /**
     * 
     *
     * @param request - SendPersonalMessageRequest
     * @returns SendPersonalMessageResponse
     */
    async sendPersonalMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendPersonalMessageHeaders({});
        return await this.sendPersonalMessageWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - SendRobotInteractiveCardRequest
     * @param headers - SendRobotInteractiveCardHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns SendRobotInteractiveCardResponse
     */
    async sendRobotInteractiveCardWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.callbackUrl)) {
            body["callbackUrl"] = request.callbackUrl;
        }
        if (!tea_util_1.default.isUnset(request.cardBizId)) {
            body["cardBizId"] = request.cardBizId;
        }
        if (!tea_util_1.default.isUnset(request.cardData)) {
            body["cardData"] = request.cardData;
        }
        if (!tea_util_1.default.isUnset(request.cardTemplateId)) {
            body["cardTemplateId"] = request.cardTemplateId;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.pullStrategy)) {
            body["pullStrategy"] = request.pullStrategy;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        if (!tea_util_1.default.isUnset(request.sendOptions)) {
            body["sendOptions"] = request.sendOptions;
        }
        if (!tea_util_1.default.isUnset(request.singleChatReceiver)) {
            body["singleChatReceiver"] = request.singleChatReceiver;
        }
        if (!tea_util_1.default.isUnset(request.unionIdPrivateDataMap)) {
            body["unionIdPrivateDataMap"] = request.unionIdPrivateDataMap;
        }
        if (!tea_util_1.default.isUnset(request.userIdPrivateDataMap)) {
            body["userIdPrivateDataMap"] = request.userIdPrivateDataMap;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SendRobotInteractiveCard",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/v1.0/robot/interactiveCards/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendRobotInteractiveCardResponse({}));
    }
    /**
     * 
     *
     * @param request - SendRobotInteractiveCardRequest
     * @returns SendRobotInteractiveCardResponse
     */
    async sendRobotInteractiveCard(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendRobotInteractiveCardHeaders({});
        return await this.sendRobotInteractiveCardWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - SendRobotMessageRequest
     * @param headers - SendRobotMessageHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns SendRobotMessageResponse
     */
    async sendRobotMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.atAll)) {
            body["atAll"] = request.atAll;
        }
        if (!tea_util_1.default.isUnset(request.atAppUserId)) {
            body["atAppUserId"] = request.atAppUserId;
        }
        if (!tea_util_1.default.isUnset(request.atDingUserId)) {
            body["atDingUserId"] = request.atDingUserId;
        }
        if (!tea_util_1.default.isUnset(request.msgContent)) {
            body["msgContent"] = request.msgContent;
        }
        if (!tea_util_1.default.isUnset(request.msgType)) {
            body["msgType"] = request.msgType;
        }
        if (!tea_util_1.default.isUnset(request.openConversationIds)) {
            body["openConversationIds"] = request.openConversationIds;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SendRobotMessage",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interconnections/robotMessages/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendRobotMessageResponse({}));
    }
    /**
     * 
     *
     * @param request - SendRobotMessageRequest
     * @returns SendRobotMessageResponse
     */
    async sendRobotMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendRobotMessageHeaders({});
        return await this.sendRobotMessageWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - SendTemplateInteractiveCardRequest
     * @param headers - SendTemplateInteractiveCardHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns SendTemplateInteractiveCardResponse
     */
    async sendTemplateInteractiveCardWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.callbackUrl)) {
            body["callbackUrl"] = request.callbackUrl;
        }
        if (!tea_util_1.default.isUnset(request.cardData)) {
            body["cardData"] = request.cardData;
        }
        if (!tea_util_1.default.isUnset(request.cardTemplateId)) {
            body["cardTemplateId"] = request.cardTemplateId;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.outTrackId)) {
            body["outTrackId"] = request.outTrackId;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        if (!tea_util_1.default.isUnset(request.sendOptions)) {
            body["sendOptions"] = request.sendOptions;
        }
        if (!tea_util_1.default.isUnset(request.singleChatReceiver)) {
            body["singleChatReceiver"] = request.singleChatReceiver;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SendTemplateInteractiveCard",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interactiveCards/templates/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendTemplateInteractiveCardResponse({}));
    }
    /**
     * 
     *
     * @param request - SendTemplateInteractiveCardRequest
     * @returns SendTemplateInteractiveCardResponse
     */
    async sendTemplateInteractiveCard(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendTemplateInteractiveCardHeaders({});
        return await this.sendTemplateInteractiveCardWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - SetRightPanelRequest
     * @param headers - SetRightPanelHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns SetRightPanelResponse
     */
    async setRightPanelWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.rightPanelClosePermitted)) {
            body["rightPanelClosePermitted"] = request.rightPanelClosePermitted;
        }
        if (!tea_util_1.default.isUnset(request.rightPanelOpenStatus)) {
            body["rightPanelOpenStatus"] = request.rightPanelOpenStatus;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        if (!tea_util_1.default.isUnset(request.webWndParams)) {
            body["webWndParams"] = request.webWndParams;
        }
        if (!tea_util_1.default.isUnset(request.width)) {
            body["width"] = request.width;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SetRightPanel",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/rightPanels/set`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SetRightPanelResponse({}));
    }
    /**
     * 
     *
     * @param request - SetRightPanelRequest
     * @returns SetRightPanelResponse
     */
    async setRightPanel(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SetRightPanelHeaders({});
        return await this.setRightPanelWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - TopboxCloseRequest
     * @param headers - TopboxCloseHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns TopboxCloseResponse
     */
    async topboxCloseWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.conversationType)) {
            body["conversationType"] = request.conversationType;
        }
        if (!tea_util_1.default.isUnset(request.coolAppCode)) {
            body["coolAppCode"] = request.coolAppCode;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.outTrackId)) {
            body["outTrackId"] = request.outTrackId;
        }
        if (!tea_util_1.default.isUnset(request.receiverUserIdList)) {
            body["receiverUserIdList"] = request.receiverUserIdList;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "TopboxClose",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/topBoxes/close`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "none",
        });
        return $tea.cast(await this.execute(params, req, runtime), new TopboxCloseResponse({}));
    }
    /**
     * 
     *
     * @param request - TopboxCloseRequest
     * @returns TopboxCloseResponse
     */
    async topboxClose(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new TopboxCloseHeaders({});
        return await this.topboxCloseWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - TopboxOpenRequest
     * @param headers - TopboxOpenHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns TopboxOpenResponse
     */
    async topboxOpenWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.conversationType)) {
            body["conversationType"] = request.conversationType;
        }
        if (!tea_util_1.default.isUnset(request.coolAppCode)) {
            body["coolAppCode"] = request.coolAppCode;
        }
        if (!tea_util_1.default.isUnset(request.expiredTime)) {
            body["expiredTime"] = request.expiredTime;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.outTrackId)) {
            body["outTrackId"] = request.outTrackId;
        }
        if (!tea_util_1.default.isUnset(request.platforms)) {
            body["platforms"] = request.platforms;
        }
        if (!tea_util_1.default.isUnset(request.receiverUserIdList)) {
            body["receiverUserIdList"] = request.receiverUserIdList;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "TopboxOpen",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/topBoxes/open`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "none",
        });
        return $tea.cast(await this.execute(params, req, runtime), new TopboxOpenResponse({}));
    }
    /**
     * 
     *
     * @param request - TopboxOpenRequest
     * @returns TopboxOpenResponse
     */
    async topboxOpen(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new TopboxOpenHeaders({});
        return await this.topboxOpenWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - UpdateGroupAvatarRequest
     * @param headers - UpdateGroupAvatarHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateGroupAvatarResponse
     */
    async updateGroupAvatarWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.groupAvatar)) {
            body["groupAvatar"] = request.groupAvatar;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateGroupAvatar",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interconnections/groups/avatars`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateGroupAvatarResponse({}));
    }
    /**
     * 
     *
     * @param request - UpdateGroupAvatarRequest
     * @returns UpdateGroupAvatarResponse
     */
    async updateGroupAvatar(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateGroupAvatarHeaders({});
        return await this.updateGroupAvatarWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - UpdateGroupNameRequest
     * @param headers - UpdateGroupNameHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateGroupNameResponse
     */
    async updateGroupNameWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.groupName)) {
            body["groupName"] = request.groupName;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateGroupName",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interconnections/groups/names`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateGroupNameResponse({}));
    }
    /**
     * 
     *
     * @param request - UpdateGroupNameRequest
     * @returns UpdateGroupNameResponse
     */
    async updateGroupName(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateGroupNameHeaders({});
        return await this.updateGroupNameWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - UpdateGroupPermissionRequest
     * @param headers - UpdateGroupPermissionHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateGroupPermissionResponse
     */
    async updateGroupPermissionWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.permissionGroup)) {
            body["permissionGroup"] = request.permissionGroup;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            body["status"] = request.status;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateGroupPermission",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/sceneGroups/permissions`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateGroupPermissionResponse({}));
    }
    /**
     * 
     *
     * @param request - UpdateGroupPermissionRequest
     * @returns UpdateGroupPermissionResponse
     */
    async updateGroupPermission(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateGroupPermissionHeaders({});
        return await this.updateGroupPermissionWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - UpdateGroupSubAdminRequest
     * @param headers - UpdateGroupSubAdminHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateGroupSubAdminResponse
     */
    async updateGroupSubAdminWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.role)) {
            body["role"] = request.role;
        }
        if (!tea_util_1.default.isUnset(request.userIds)) {
            body["userIds"] = request.userIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateGroupSubAdmin",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/sceneGroups/subAdmins`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateGroupSubAdminResponse({}));
    }
    /**
     * 
     *
     * @param request - UpdateGroupSubAdminRequest
     * @returns UpdateGroupSubAdminResponse
     */
    async updateGroupSubAdmin(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateGroupSubAdminHeaders({});
        return await this.updateGroupSubAdminWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - UpdateInteractiveCardRequest
     * @param headers - UpdateInteractiveCardHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateInteractiveCardResponse
     */
    async updateInteractiveCardWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.cardData)) {
            body["cardData"] = request.cardData;
        }
        if (!tea_util_1.default.isUnset(request.cardOptions)) {
            body["cardOptions"] = request.cardOptions;
        }
        if (!tea_util_1.default.isUnset(request.outTrackId)) {
            body["outTrackId"] = request.outTrackId;
        }
        if (!tea_util_1.default.isUnset(request.privateData)) {
            body["privateData"] = request.privateData;
        }
        if (!tea_util_1.default.isUnset(request.userIdType)) {
            body["userIdType"] = request.userIdType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateInteractiveCard",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interactiveCards`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateInteractiveCardResponse({}));
    }
    /**
     * 
     *
     * @param request - UpdateInteractiveCardRequest
     * @returns UpdateInteractiveCardResponse
     */
    async updateInteractiveCard(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateInteractiveCardHeaders({});
        return await this.updateInteractiveCardWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - UpdateMemberBanWordsRequest
     * @param headers - UpdateMemberBanWordsHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateMemberBanWordsResponse
     */
    async updateMemberBanWordsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.muteDuration)) {
            body["muteDuration"] = request.muteDuration;
        }
        if (!tea_util_1.default.isUnset(request.muteStatus)) {
            body["muteStatus"] = request.muteStatus;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.userIdList)) {
            body["userIdList"] = request.userIdList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateMemberBanWords",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/sceneGroups/muteMembers/set`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "none",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateMemberBanWordsResponse({}));
    }
    /**
     * 
     *
     * @param request - UpdateMemberBanWordsRequest
     * @returns UpdateMemberBanWordsResponse
     */
    async updateMemberBanWords(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateMemberBanWordsHeaders({});
        return await this.updateMemberBanWordsWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - UpdateMemberGroupNickRequest
     * @param headers - UpdateMemberGroupNickHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateMemberGroupNickResponse
     */
    async updateMemberGroupNickWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.groupNick)) {
            body["groupNick"] = request.groupNick;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateMemberGroupNick",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/sceneGroups/members/groupNicks`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateMemberGroupNickResponse({}));
    }
    /**
     * 
     *
     * @param request - UpdateMemberGroupNickRequest
     * @returns UpdateMemberGroupNickResponse
     */
    async updateMemberGroupNick(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateMemberGroupNickHeaders({});
        return await this.updateMemberGroupNickWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - UpdateRobotInOrgRequest
     * @param headers - UpdateRobotInOrgHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateRobotInOrgResponse
     */
    async updateRobotInOrgWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.brief)) {
            body["brief"] = request.brief;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.icon)) {
            body["icon"] = request.icon;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.outgoingToken)) {
            body["outgoingToken"] = request.outgoingToken;
        }
        if (!tea_util_1.default.isUnset(request.outgoingUrl)) {
            body["outgoingUrl"] = request.outgoingUrl;
        }
        if (!tea_util_1.default.isUnset(request.previewMediaId)) {
            body["previewMediaId"] = request.previewMediaId;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateRobotInOrg",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/organizations/robots`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateRobotInOrgResponse({}));
    }
    /**
     * 
     *
     * @param request - UpdateRobotInOrgRequest
     * @returns UpdateRobotInOrgResponse
     */
    async updateRobotInOrg(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateRobotInOrgHeaders({});
        return await this.updateRobotInOrgWithOptions(request, headers, runtime);
    }
    /**
     * ()
     *
     * @param request - UpdateRobotInteractiveCardRequest
     * @param headers - UpdateRobotInteractiveCardHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateRobotInteractiveCardResponse
     */
    async updateRobotInteractiveCardWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.cardBizId)) {
            body["cardBizId"] = request.cardBizId;
        }
        if (!tea_util_1.default.isUnset(request.cardData)) {
            body["cardData"] = request.cardData;
        }
        if (!tea_util_1.default.isUnset(request.unionIdPrivateDataMap)) {
            body["unionIdPrivateDataMap"] = request.unionIdPrivateDataMap;
        }
        if (!tea_util_1.default.isUnset(request.updateOptions)) {
            body["updateOptions"] = request.updateOptions;
        }
        if (!tea_util_1.default.isUnset(request.userIdPrivateDataMap)) {
            body["userIdPrivateDataMap"] = request.userIdPrivateDataMap;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateRobotInteractiveCard",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/robots/interactiveCards`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateRobotInteractiveCardResponse({}));
    }
    /**
     * ()
     *
     * @param request - UpdateRobotInteractiveCardRequest
     * @returns UpdateRobotInteractiveCardResponse
     */
    async updateRobotInteractiveCard(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateRobotInteractiveCardHeaders({});
        return await this.updateRobotInteractiveCardWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - UpdateSceneGroupTemplateMessageOpenStatusRequest
     * @param headers - UpdateSceneGroupTemplateMessageOpenStatusHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateSceneGroupTemplateMessageOpenStatusResponse
     */
    async updateSceneGroupTemplateMessageOpenStatusWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.status)) {
            body["status"] = request.status;
        }
        if (!tea_util_1.default.isUnset(request.templateIdList)) {
            body["templateIdList"] = request.templateIdList;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateSceneGroupTemplateMessageOpenStatus",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/chats/sceneGroups/templates/messageOpenStatuses`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateSceneGroupTemplateMessageOpenStatusResponse({}));
    }
    /**
     * 
     *
     * @param request - UpdateSceneGroupTemplateMessageOpenStatusRequest
     * @returns UpdateSceneGroupTemplateMessageOpenStatusResponse
     */
    async updateSceneGroupTemplateMessageOpenStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateSceneGroupTemplateMessageOpenStatusHeaders({});
        return await this.updateSceneGroupTemplateMessageOpenStatusWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - UpdateTheGroupRolesOfGroupMemberRequest
     * @param headers - UpdateTheGroupRolesOfGroupMemberHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateTheGroupRolesOfGroupMemberResponse
     */
    async updateTheGroupRolesOfGroupMemberWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.openRoleIds)) {
            body["openRoleIds"] = request.openRoleIds;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateTheGroupRolesOfGroupMember",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/sceneGroups/members/groupRoles`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateTheGroupRolesOfGroupMemberResponse({}));
    }
    /**
     * 
     *
     * @param request - UpdateTheGroupRolesOfGroupMemberRequest
     * @returns UpdateTheGroupRolesOfGroupMemberResponse
     */
    async updateTheGroupRolesOfGroupMember(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateTheGroupRolesOfGroupMemberHeaders({});
        return await this.updateTheGroupRolesOfGroupMemberWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - UpdateUnfurlingRegisterRequest
     * @param headers - UpdateUnfurlingRegisterHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateUnfurlingRegisterResponse
     */
    async updateUnfurlingRegisterWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.apiSecret)) {
            body["apiSecret"] = request.apiSecret;
        }
        if (!tea_util_1.default.isUnset(request.appId)) {
            body["appId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.callbackUrl)) {
            body["callbackUrl"] = request.callbackUrl;
        }
        if (!tea_util_1.default.isUnset(request.cardTemplateId)) {
            body["cardTemplateId"] = request.cardTemplateId;
        }
        if (!tea_util_1.default.isUnset(request.domain)) {
            body["domain"] = request.domain;
        }
        if (!tea_util_1.default.isUnset(request.id)) {
            body["id"] = request.id;
        }
        if (!tea_util_1.default.isUnset(request.path)) {
            body["path"] = request.path;
        }
        if (!tea_util_1.default.isUnset(request.ruleDesc)) {
            body["ruleDesc"] = request.ruleDesc;
        }
        if (!tea_util_1.default.isUnset(request.ruleMatchType)) {
            body["ruleMatchType"] = request.ruleMatchType;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateUnfurlingRegister",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/unfurling/rules`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateUnfurlingRegisterResponse({}));
    }
    /**
     * 
     *
     * @param request - UpdateUnfurlingRegisterRequest
     * @returns UpdateUnfurlingRegisterResponse
     */
    async updateUnfurlingRegister(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateUnfurlingRegisterHeaders({});
        return await this.updateUnfurlingRegisterWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - UpdateUnfurlingRegisterStatusRequest
     * @param headers - UpdateUnfurlingRegisterStatusHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateUnfurlingRegisterStatusResponse
     */
    async updateUnfurlingRegisterStatusWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            body["appId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.id)) {
            body["id"] = request.id;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            body["status"] = request.status;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateUnfurlingRegisterStatus",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/unfurling/rules/statuses`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateUnfurlingRegisterStatusResponse({}));
    }
    /**
     * 
     *
     * @param request - UpdateUnfurlingRegisterStatusRequest
     * @returns UpdateUnfurlingRegisterStatusResponse
     */
    async updateUnfurlingRegisterStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateUnfurlingRegisterStatusHeaders({});
        return await this.updateUnfurlingRegisterStatusWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - AddGroupMemberRequest
     * @param headers - AddGroupMemberHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns AddGroupMemberResponse
     */
    async addGroupMemberWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appUserIds)) {
            body["appUserIds"] = request.appUserIds;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.userIds)) {
            body["userIds"] = request.userIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "addGroupMember",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interconnections/groups/members`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddGroupMemberResponse({}));
    }
    /**
     * 
     *
     * @param request - AddGroupMemberRequest
     * @returns AddGroupMemberResponse
     */
    async addGroupMember(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddGroupMemberHeaders({});
        return await this.addGroupMemberWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - RemoveGroupMemberRequest
     * @param headers - RemoveGroupMemberHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns RemoveGroupMemberResponse
     */
    async removeGroupMemberWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appUserIds)) {
            body["appUserIds"] = request.appUserIds;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.userIds)) {
            body["userIds"] = request.userIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "removeGroupMember",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interconnections/groups/members/remove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RemoveGroupMemberResponse({}));
    }
    /**
     * 
     *
     * @param request - RemoveGroupMemberRequest
     * @returns RemoveGroupMemberResponse
     */
    async removeGroupMember(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RemoveGroupMemberHeaders({});
        return await this.removeGroupMemberWithOptions(request, headers, runtime);
    }
    /**
     * ToC
     *
     * @param request - SendDingMessageRequest
     * @param headers - SendDingMessageHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns SendDingMessageResponse
     */
    async sendDingMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.code)) {
            body["code"] = request.code;
        }
        if (!tea_util_1.default.isUnset(request.message)) {
            body["message"] = request.message;
        }
        if (!tea_util_1.default.isUnset(request.messageType)) {
            body["messageType"] = request.messageType;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.receiverId)) {
            body["receiverId"] = request.receiverId;
        }
        if (!tea_util_1.default.isUnset(request.senderId)) {
            body["senderId"] = request.senderId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "sendDingMessage",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interconnections/dingMessages/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendDingMessageResponse({}));
    }
    /**
     * ToC
     *
     * @param request - SendDingMessageRequest
     * @returns SendDingMessageResponse
     */
    async sendDingMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendDingMessageHeaders({});
        return await this.sendDingMessageWithOptions(request, headers, runtime);
    }
    /**
     * ToB
     *
     * @param request - SendMessageRequest
     * @param headers - SendMessageHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns SendMessageResponse
     */
    async sendMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.message)) {
            body["message"] = request.message;
        }
        if (!tea_util_1.default.isUnset(request.messageType)) {
            body["messageType"] = request.messageType;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.receiverId)) {
            body["receiverId"] = request.receiverId;
        }
        if (!tea_util_1.default.isUnset(request.senderId)) {
            body["senderId"] = request.senderId;
        }
        if (!tea_util_1.default.isUnset(request.sourceInfos)) {
            body["sourceInfos"] = request.sourceInfos;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "sendMessage",
            version: "im_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/im/interconnections/messages/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendMessageResponse({}));
    }
    /**
     * ToB
     *
     * @param request - SendMessageRequest
     * @returns SendMessageResponse
     */
    async sendMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendMessageHeaders({});
        return await this.sendMessageWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map