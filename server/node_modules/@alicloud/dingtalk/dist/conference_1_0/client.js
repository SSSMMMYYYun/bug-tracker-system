"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetHistoryConfDataListResponse = exports.GetHistoryConfDataListResponseBody = exports.GetHistoryConfDataListRequest = exports.GetHistoryConfDataListHeaders = exports.GetConfDetailDataResponse = exports.GetConfDetailDataResponseBody = exports.GetConfDetailDataRequest = exports.GetConfDetailDataHeaders = exports.GetConfDataByConferenceIdResponse = exports.GetConfDataByConferenceIdResponseBody = exports.GetConfDataByConferenceIdRequest = exports.GetConfDataByConferenceIdHeaders = exports.GenerateFlashMinutesDocumentUrlResponse = exports.GenerateFlashMinutesDocumentUrlResponseBody = exports.GenerateFlashMinutesDocumentUrlRequest = exports.GenerateFlashMinutesDocumentUrlHeaders = exports.FocusResponse = exports.FocusResponseBody = exports.FocusRequest = exports.FocusHeaders = exports.CreateVideoConferenceResponse = exports.CreateVideoConferenceResponseBody = exports.CreateVideoConferenceRequest = exports.CreateVideoConferenceHeaders = exports.CreateScheduleConferenceResponse = exports.CreateScheduleConferenceResponseBody = exports.CreateScheduleConferenceRequest = exports.CreateScheduleConferenceHeaders = exports.CreateCustomShortLinkResponse = exports.CreateCustomShortLinkResponseBody = exports.CreateCustomShortLinkRequest = exports.CreateCustomShortLinkHeaders = exports.CohostsResponse = exports.CohostsResponseBody = exports.CohostsRequest = exports.CohostsHeaders = exports.CloseVideoConferenceResponse = exports.CloseVideoConferenceResponseBody = exports.CloseVideoConferenceRequest = exports.CloseVideoConferenceHeaders = exports.CancelScheduleConferenceResponse = exports.CancelScheduleConferenceResponseBody = exports.CancelScheduleConferenceRequest = exports.CancelScheduleConferenceHeaders = exports.AddRecordPermissionResponse = exports.AddRecordPermissionResponseBody = exports.AddRecordPermissionRequest = exports.AddRecordPermissionHeaders = exports.MemberModelMapValue = exports.MetricMapValue = void 0;
exports.QueryConferenceInfoByRoomCodeResponseBody = exports.QueryConferenceInfoByRoomCodeRequest = exports.QueryConferenceInfoByRoomCodeHeaders = exports.QueryConferenceInfoBatchResponse = exports.QueryConferenceInfoBatchResponseBody = exports.QueryConferenceInfoBatchRequest = exports.QueryConferenceInfoBatchHeaders = exports.QueryConferenceInfoResponse = exports.QueryConferenceInfoResponseBody = exports.QueryConferenceInfoHeaders = exports.QueryCloudRecordVideoPlayInfoResponse = exports.QueryCloudRecordVideoPlayInfoResponseBody = exports.QueryCloudRecordVideoPlayInfoRequest = exports.QueryCloudRecordVideoPlayInfoHeaders = exports.QueryCloudRecordVideoResponse = exports.QueryCloudRecordVideoResponseBody = exports.QueryCloudRecordVideoRequest = exports.QueryCloudRecordVideoHeaders = exports.QueryCloudRecordTextResponse = exports.QueryCloudRecordTextResponseBody = exports.QueryCloudRecordTextRequest = exports.QueryCloudRecordTextHeaders = exports.MuteMembersResponse = exports.MuteMembersResponseBody = exports.MuteMembersRequest = exports.MuteMembersHeaders = exports.MuteAllResponse = exports.MuteAllResponseBody = exports.MuteAllRequest = exports.MuteAllHeaders = exports.LockConferenceResponse = exports.LockConferenceResponseBody = exports.LockConferenceRequest = exports.LockConferenceHeaders = exports.KickMembersResponse = exports.KickMembersResponseBody = exports.KickMembersRequest = exports.KickMembersHeaders = exports.InviteUsersResponse = exports.InviteUsersResponseBody = exports.InviteUsersRequest = exports.InviteUsersHeaders = exports.GetUserMetricDataResponse = exports.GetUserMetricDataResponseBody = exports.GetUserMetricDataRequest = exports.GetUserMetricDataHeaders = exports.GetUserLastMetricResponse = exports.GetUserLastMetricResponseBody = exports.GetUserLastMetricRequest = exports.GetUserLastMetricHeaders = void 0;
exports.StartMinutesHeaders = exports.StartCloudRecordResponse = exports.StartCloudRecordResponseBody = exports.StartCloudRecordRequest = exports.StartCloudRecordHeaders = exports.QueryUserOnGoingConferenceResponse = exports.QueryUserOnGoingConferenceResponseBody = exports.QueryUserOnGoingConferenceRequest = exports.QueryUserOnGoingConferenceHeaders = exports.QueryScheduleConferenceInfoResponse = exports.QueryScheduleConferenceInfoResponseBody = exports.QueryScheduleConferenceInfoRequest = exports.QueryScheduleConferenceInfoHeaders = exports.QueryScheduleConferenceResponse = exports.QueryScheduleConferenceResponseBody = exports.QueryScheduleConferenceRequest = exports.QueryScheduleConferenceHeaders = exports.QueryScheduleConfSettingsResponse = exports.QueryScheduleConfSettingsResponseBody = exports.QueryScheduleConfSettingsRequest = exports.QueryScheduleConfSettingsHeaders = exports.QueryRecordMinutesUrlResponse = exports.QueryRecordMinutesUrlResponseBody = exports.QueryRecordMinutesUrlRequest = exports.QueryRecordMinutesUrlHeaders = exports.QueryOrgConferenceListResponse = exports.QueryOrgConferenceListResponseBody = exports.QueryOrgConferenceListRequest = exports.QueryOrgConferenceListHeaders = exports.QueryMinutesTextResponse = exports.QueryMinutesTextResponseBody = exports.QueryMinutesTextRequest = exports.QueryMinutesTextHeaders = exports.QueryMinutesSummaryResponse = exports.QueryMinutesSummaryResponseBody = exports.QueryMinutesSummaryRequest = exports.QueryMinutesSummaryHeaders = exports.QueryMinutesAudioResponse = exports.QueryMinutesAudioResponseBody = exports.QueryMinutesAudioRequest = exports.QueryMinutesAudioHeaders = exports.QueryFlashMinutesSummaryResponse = exports.QueryFlashMinutesSummaryResponseBody = exports.QueryFlashMinutesSummaryRequest = exports.QueryFlashMinutesSummaryHeaders = exports.QueryConferenceMembersResponse = exports.QueryConferenceMembersResponseBody = exports.QueryConferenceMembersRequest = exports.QueryConferenceMembersHeaders = exports.QueryConferenceInfoByRoomCodeResponse = void 0;
exports.QueryCloudRecordTextResponseBodyParagraphList = exports.QueryCloudRecordTextResponseBodyParagraphListSentenceList = exports.QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList = exports.MuteMembersRequestUserList = exports.KickMembersRequestUserList = exports.InviteUsersRequestPhoneInviteeList = exports.InviteUsersRequestInviteeList = exports.GetUserMetricDataResponseBodyMetricDataList = exports.GetHistoryConfDataListResponseBodyList = exports.GetConfDetailDataResponseBodyList = exports.CreateScheduleConferenceRequestScheduleConfSettingModel = exports.CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSetting = exports.CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings = exports.CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfOpenRecordSetting = exports.CreateCustomShortLinkResponseBodyResult = exports.CohostsRequestUserList = exports.UpdateVideoConferenceSettingResponse = exports.UpdateVideoConferenceSettingResponseBody = exports.UpdateVideoConferenceSettingRequest = exports.UpdateVideoConferenceSettingHeaders = exports.UpdateVideoConferenceExtInfoResponse = exports.UpdateVideoConferenceExtInfoResponseBody = exports.UpdateVideoConferenceExtInfoHeaders = exports.UpdateScheduleConferenceResponse = exports.UpdateScheduleConferenceResponseBody = exports.UpdateScheduleConferenceRequest = exports.UpdateScheduleConferenceHeaders = exports.UpdateScheduleConfSettingsResponse = exports.UpdateScheduleConfSettingsResponseBody = exports.UpdateScheduleConfSettingsRequest = exports.UpdateScheduleConfSettingsHeaders = exports.StopStreamOutResponse = exports.StopStreamOutResponseBody = exports.StopStreamOutRequest = exports.StopStreamOutHeaders = exports.StopMinutesResponse = exports.StopMinutesResponseBody = exports.StopMinutesRequest = exports.StopMinutesHeaders = exports.StopCloudRecordResponse = exports.StopCloudRecordResponseBody = exports.StopCloudRecordRequest = exports.StopCloudRecordHeaders = exports.StartStreamOutResponse = exports.StartStreamOutResponseBody = exports.StartStreamOutRequest = exports.StartStreamOutHeaders = exports.StartMinutesResponse = exports.StartMinutesResponseBody = exports.StartMinutesRequest = void 0;
exports.UpdateScheduleConfSettingsRequestScheduleConfSettingModel = exports.UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting = exports.UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings = exports.UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfOpenRecordSetting = exports.QueryScheduleConferenceInfoResponseBodyConferenceList = exports.QueryScheduleConfSettingsResponseBodyScheduleConfSettingModel = exports.QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSetting = exports.QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings = exports.QueryRecordMinutesUrlResponseBodyRecordMinutesUrls = exports.QueryOrgConferenceListResponseBodyOnGoingConfList = exports.QueryMinutesTextResponseBodyParagraphList = exports.QueryMinutesTextResponseBodyParagraphListSentenceList = exports.QueryMinutesTextResponseBodyParagraphListSentenceListWordList = exports.QueryMinutesSummaryResponseBodySummary = exports.QueryMinutesSummaryResponseBodySummaryQuestionsAnsweringSummary = exports.QueryMinutesSummaryResponseBodySummaryKeySentences = exports.QueryMinutesSummaryResponseBodySummaryConversationalSummary = exports.QueryMinutesSummaryResponseBodySummaryAutoChapters = exports.QueryMinutesSummaryResponseBodySummaryActions = exports.QueryMinutesAudioResponseBodyAudioList = exports.QueryFlashMinutesSummaryResponseBodyFlashMinutesSummary = exports.QueryFlashMinutesSummaryResponseBodyFlashMinutesSummarySummary = exports.QueryConferenceMembersResponseBodyMemberModels = exports.QueryConferenceInfoByRoomCodeResponseBodyConferenceList = exports.QueryConferenceInfoBatchResponseBodyInfos = exports.QueryConferenceInfoBatchResponseBodyInfosUserList = exports.QueryConferenceInfoResponseBodyConfInfo = exports.QueryConferenceInfoResponseBodyConfInfoExtensionAppSettings = exports.QueryCloudRecordVideoResponseBodyVideoList = void 0;
// This file is auto-generated, don't edit it
/**
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class MetricMapValue extends $tea.Model {
    static names() {
        return {
            timestamp: 'timestamp',
            sendBitRate: 'sendBitRate',
            recvBitRate: 'recvBitRate',
            lostRate: 'lostRate',
            roundTripTime: 'roundTripTime',
            audioSendBitRate: 'audioSendBitRate',
            audioRecvBitRate: 'audioRecvBitRate',
            audioRecLevel: 'audioRecLevel',
            audioPlayLevel: 'audioPlayLevel',
            cameraSendBitRate: 'cameraSendBitRate',
            cameraRecvBitRate: 'cameraRecvBitRate',
            cameraSendResolutionActual: 'cameraSendResolutionActual',
            cameraRecvResolutionActual: 'cameraRecvResolutionActual',
            cameraSendFrame: 'cameraSendFrame',
            screenSendBitRate: 'screenSendBitRate',
            cameraRecvFrame: 'cameraRecvFrame',
            screenRecvBitRate: 'screenRecvBitRate',
            screenSendResolutionActual: 'screenSendResolutionActual',
            screenRecvResolutionActual: 'screenRecvResolutionActual',
            screenSendFrame: 'screenSendFrame',
            screenRecvFrame: 'screenRecvFrame',
            audioJitterMax: 'audioJitterMax',
            audioJitterAvg: 'audioJitterAvg',
        };
    }
    static types() {
        return {
            timestamp: 'number',
            sendBitRate: 'string',
            recvBitRate: 'string',
            lostRate: 'string',
            roundTripTime: 'string',
            audioSendBitRate: 'string',
            audioRecvBitRate: 'string',
            audioRecLevel: 'string',
            audioPlayLevel: 'string',
            cameraSendBitRate: 'string',
            cameraRecvBitRate: 'string',
            cameraSendResolutionActual: 'string',
            cameraRecvResolutionActual: 'string',
            cameraSendFrame: 'string',
            screenSendBitRate: 'string',
            cameraRecvFrame: 'string',
            screenRecvBitRate: 'string',
            screenSendResolutionActual: 'string',
            screenRecvResolutionActual: 'string',
            screenSendFrame: 'string',
            screenRecvFrame: 'string',
            audioJitterMax: 'string',
            audioJitterAvg: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MetricMapValue = MetricMapValue;
class MemberModelMapValue extends $tea.Model {
    static names() {
        return {
            unionId: 'unionId',
            conferenceId: 'conferenceId',
            userNick: 'userNick',
            joinTime: 'joinTime',
            leaveTime: 'leaveTime',
            duration: 'duration',
            attendStatus: 'attendStatus',
            host: 'host',
            coHost: 'coHost',
            outerOrgMember: 'outerOrgMember',
            pstnJoin: 'pstnJoin',
            deviceType: 'deviceType',
        };
    }
    static types() {
        return {
            unionId: 'string',
            conferenceId: 'string',
            userNick: 'string',
            joinTime: 'number',
            leaveTime: 'number',
            duration: 'number',
            attendStatus: 'number',
            host: 'boolean',
            coHost: 'boolean',
            outerOrgMember: 'boolean',
            pstnJoin: 'boolean',
            deviceType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MemberModelMapValue = MemberModelMapValue;
class AddRecordPermissionHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddRecordPermissionHeaders = AddRecordPermissionHeaders;
class AddRecordPermissionRequest extends $tea.Model {
    static names() {
        return {
            bizType: 'bizType',
            ownerUnionId: 'ownerUnionId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            bizType: 'string',
            ownerUnionId: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddRecordPermissionRequest = AddRecordPermissionRequest;
class AddRecordPermissionResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'code',
        };
    }
    static types() {
        return {
            code: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddRecordPermissionResponseBody = AddRecordPermissionResponseBody;
class AddRecordPermissionResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddRecordPermissionResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddRecordPermissionResponse = AddRecordPermissionResponse;
class CancelScheduleConferenceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CancelScheduleConferenceHeaders = CancelScheduleConferenceHeaders;
class CancelScheduleConferenceRequest extends $tea.Model {
    static names() {
        return {
            creatorUnionId: 'creatorUnionId',
            scheduleConferenceId: 'scheduleConferenceId',
        };
    }
    static types() {
        return {
            creatorUnionId: 'string',
            scheduleConferenceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CancelScheduleConferenceRequest = CancelScheduleConferenceRequest;
class CancelScheduleConferenceResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CancelScheduleConferenceResponseBody = CancelScheduleConferenceResponseBody;
class CancelScheduleConferenceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CancelScheduleConferenceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CancelScheduleConferenceResponse = CancelScheduleConferenceResponse;
class CloseVideoConferenceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseVideoConferenceHeaders = CloseVideoConferenceHeaders;
class CloseVideoConferenceRequest extends $tea.Model {
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseVideoConferenceRequest = CloseVideoConferenceRequest;
class CloseVideoConferenceResponseBody extends $tea.Model {
    static names() {
        return {
            cause: 'cause',
            code: 'code',
        };
    }
    static types() {
        return {
            cause: 'string',
            code: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseVideoConferenceResponseBody = CloseVideoConferenceResponseBody;
class CloseVideoConferenceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CloseVideoConferenceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CloseVideoConferenceResponse = CloseVideoConferenceResponse;
class CohostsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CohostsHeaders = CohostsHeaders;
class CohostsRequest extends $tea.Model {
    static names() {
        return {
            action: 'action',
            userList: 'userList',
        };
    }
    static types() {
        return {
            action: 'string',
            userList: { 'type': 'array', 'itemType': CohostsRequestUserList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CohostsRequest = CohostsRequest;
class CohostsResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CohostsResponseBody = CohostsResponseBody;
class CohostsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CohostsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CohostsResponse = CohostsResponse;
class CreateCustomShortLinkHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateCustomShortLinkHeaders = CreateCustomShortLinkHeaders;
class CreateCustomShortLinkRequest extends $tea.Model {
    static names() {
        return {
            coolAppCode: 'coolAppCode',
            creatorUnionId: 'creatorUnionId',
            extensionAppBizData: 'extensionAppBizData',
            scheduleConferenceId: 'scheduleConferenceId',
            useExtensionApp: 'useExtensionApp',
        };
    }
    static types() {
        return {
            coolAppCode: 'string',
            creatorUnionId: 'string',
            extensionAppBizData: 'string',
            scheduleConferenceId: 'string',
            useExtensionApp: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateCustomShortLinkRequest = CreateCustomShortLinkRequest;
class CreateCustomShortLinkResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: CreateCustomShortLinkResponseBodyResult,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateCustomShortLinkResponseBody = CreateCustomShortLinkResponseBody;
class CreateCustomShortLinkResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateCustomShortLinkResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateCustomShortLinkResponse = CreateCustomShortLinkResponse;
class CreateScheduleConferenceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateScheduleConferenceHeaders = CreateScheduleConferenceHeaders;
class CreateScheduleConferenceRequest extends $tea.Model {
    static names() {
        return {
            creatorUnionId: 'creatorUnionId',
            endTime: 'endTime',
            scheduleConfSettingModel: 'scheduleConfSettingModel',
            startTime: 'startTime',
            title: 'title',
        };
    }
    static types() {
        return {
            creatorUnionId: 'string',
            endTime: 'number',
            scheduleConfSettingModel: CreateScheduleConferenceRequestScheduleConfSettingModel,
            startTime: 'number',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateScheduleConferenceRequest = CreateScheduleConferenceRequest;
class CreateScheduleConferenceResponseBody extends $tea.Model {
    static names() {
        return {
            phones: 'phones',
            requestId: 'requestId',
            roomCode: 'roomCode',
            scheduleConferenceId: 'scheduleConferenceId',
            url: 'url',
        };
    }
    static types() {
        return {
            phones: { 'type': 'array', 'itemType': 'string' },
            requestId: 'string',
            roomCode: 'string',
            scheduleConferenceId: 'string',
            url: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateScheduleConferenceResponseBody = CreateScheduleConferenceResponseBody;
class CreateScheduleConferenceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateScheduleConferenceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateScheduleConferenceResponse = CreateScheduleConferenceResponse;
class CreateVideoConferenceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateVideoConferenceHeaders = CreateVideoConferenceHeaders;
class CreateVideoConferenceRequest extends $tea.Model {
    static names() {
        return {
            confTitle: 'confTitle',
            inviteCaller: 'inviteCaller',
            inviteUserIds: 'inviteUserIds',
            userId: 'userId',
        };
    }
    static types() {
        return {
            confTitle: 'string',
            inviteCaller: 'boolean',
            inviteUserIds: { 'type': 'array', 'itemType': 'string' },
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateVideoConferenceRequest = CreateVideoConferenceRequest;
class CreateVideoConferenceResponseBody extends $tea.Model {
    static names() {
        return {
            conferenceId: 'conferenceId',
            conferencePassword: 'conferencePassword',
            externalLinkUrl: 'externalLinkUrl',
            hostPassword: 'hostPassword',
            phoneNumbers: 'phoneNumbers',
            roomCode: 'roomCode',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            conferencePassword: 'string',
            externalLinkUrl: 'string',
            hostPassword: 'string',
            phoneNumbers: { 'type': 'array', 'itemType': 'string' },
            roomCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateVideoConferenceResponseBody = CreateVideoConferenceResponseBody;
class CreateVideoConferenceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateVideoConferenceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateVideoConferenceResponse = CreateVideoConferenceResponse;
class FocusHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.FocusHeaders = FocusHeaders;
class FocusRequest extends $tea.Model {
    static names() {
        return {
            action: 'action',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            action: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.FocusRequest = FocusRequest;
class FocusResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.FocusResponseBody = FocusResponseBody;
class FocusResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: FocusResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.FocusResponse = FocusResponse;
class GenerateFlashMinutesDocumentUrlHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GenerateFlashMinutesDocumentUrlHeaders = GenerateFlashMinutesDocumentUrlHeaders;
class GenerateFlashMinutesDocumentUrlRequest extends $tea.Model {
    static names() {
        return {
            bizType: 'bizType',
            expireTime: 'expireTime',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            bizType: 'string',
            expireTime: 'number',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GenerateFlashMinutesDocumentUrlRequest = GenerateFlashMinutesDocumentUrlRequest;
class GenerateFlashMinutesDocumentUrlResponseBody extends $tea.Model {
    static names() {
        return {
            minutesDocUrl: 'minutesDocUrl',
        };
    }
    static types() {
        return {
            minutesDocUrl: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GenerateFlashMinutesDocumentUrlResponseBody = GenerateFlashMinutesDocumentUrlResponseBody;
class GenerateFlashMinutesDocumentUrlResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GenerateFlashMinutesDocumentUrlResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GenerateFlashMinutesDocumentUrlResponse = GenerateFlashMinutesDocumentUrlResponse;
class GetConfDataByConferenceIdHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConfDataByConferenceIdHeaders = GetConfDataByConferenceIdHeaders;
class GetConfDataByConferenceIdRequest extends $tea.Model {
    static names() {
        return {
            realData: 'realData',
        };
    }
    static types() {
        return {
            realData: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConfDataByConferenceIdRequest = GetConfDataByConferenceIdRequest;
class GetConfDataByConferenceIdResponseBody extends $tea.Model {
    static names() {
        return {
            conferenceId: 'conferenceId',
            creatorId: 'creatorId',
            creatorNick: 'creatorNick',
            deptName: 'deptName',
            endTime: 'endTime',
            freeType: 'freeType',
            scene: 'scene',
            startTime: 'startTime',
            timeLength: 'timeLength',
            title: 'title',
            userCount: 'userCount',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            creatorId: 'string',
            creatorNick: 'string',
            deptName: 'string',
            endTime: 'number',
            freeType: 'string',
            scene: 'string',
            startTime: 'number',
            timeLength: 'number',
            title: 'string',
            userCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConfDataByConferenceIdResponseBody = GetConfDataByConferenceIdResponseBody;
class GetConfDataByConferenceIdResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetConfDataByConferenceIdResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConfDataByConferenceIdResponse = GetConfDataByConferenceIdResponse;
class GetConfDetailDataHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConfDetailDataHeaders = GetConfDetailDataHeaders;
class GetConfDetailDataRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            nick: 'nick',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            nick: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConfDetailDataRequest = GetConfDetailDataRequest;
class GetConfDetailDataResponseBody extends $tea.Model {
    static names() {
        return {
            list: 'list',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            list: { 'type': 'array', 'itemType': GetConfDetailDataResponseBodyList },
            nextToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConfDetailDataResponseBody = GetConfDetailDataResponseBody;
class GetConfDetailDataResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetConfDetailDataResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConfDetailDataResponse = GetConfDetailDataResponse;
class GetHistoryConfDataListHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetHistoryConfDataListHeaders = GetHistoryConfDataListHeaders;
class GetHistoryConfDataListRequest extends $tea.Model {
    static names() {
        return {
            creatorNike: 'creatorNike',
            endTime: 'endTime',
            freeType: 'freeType',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            realData: 'realData',
            scene: 'scene',
            startTime: 'startTime',
            title: 'title',
        };
    }
    static types() {
        return {
            creatorNike: 'string',
            endTime: 'number',
            freeType: 'string',
            maxResults: 'number',
            nextToken: 'string',
            realData: 'boolean',
            scene: 'string',
            startTime: 'number',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetHistoryConfDataListRequest = GetHistoryConfDataListRequest;
class GetHistoryConfDataListResponseBody extends $tea.Model {
    static names() {
        return {
            list: 'list',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            list: { 'type': 'array', 'itemType': GetHistoryConfDataListResponseBodyList },
            nextToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetHistoryConfDataListResponseBody = GetHistoryConfDataListResponseBody;
class GetHistoryConfDataListResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetHistoryConfDataListResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetHistoryConfDataListResponse = GetHistoryConfDataListResponse;
class GetUserLastMetricHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserLastMetricHeaders = GetUserLastMetricHeaders;
class GetUserLastMetricRequest extends $tea.Model {
    static names() {
        return {
            unionIdList: 'unionIdList',
        };
    }
    static types() {
        return {
            unionIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserLastMetricRequest = GetUserLastMetricRequest;
class GetUserLastMetricResponseBody extends $tea.Model {
    static names() {
        return {
            metricMap: 'metricMap',
        };
    }
    static types() {
        return {
            metricMap: { 'type': 'map', 'keyType': 'string', 'valueType': MetricMapValue },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserLastMetricResponseBody = GetUserLastMetricResponseBody;
class GetUserLastMetricResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetUserLastMetricResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserLastMetricResponse = GetUserLastMetricResponse;
class GetUserMetricDataHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserMetricDataHeaders = GetUserMetricDataHeaders;
class GetUserMetricDataRequest extends $tea.Model {
    static names() {
        return {
            beginTime: 'beginTime',
            endTime: 'endTime',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            beginTime: 'number',
            endTime: 'number',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserMetricDataRequest = GetUserMetricDataRequest;
class GetUserMetricDataResponseBody extends $tea.Model {
    static names() {
        return {
            metricDataList: 'metricDataList',
        };
    }
    static types() {
        return {
            metricDataList: { 'type': 'array', 'itemType': GetUserMetricDataResponseBodyMetricDataList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserMetricDataResponseBody = GetUserMetricDataResponseBody;
class GetUserMetricDataResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetUserMetricDataResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserMetricDataResponse = GetUserMetricDataResponse;
class InviteUsersHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InviteUsersHeaders = InviteUsersHeaders;
class InviteUsersRequest extends $tea.Model {
    static names() {
        return {
            inviteeList: 'inviteeList',
            phoneInviteeList: 'phoneInviteeList',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            inviteeList: { 'type': 'array', 'itemType': InviteUsersRequestInviteeList },
            phoneInviteeList: { 'type': 'array', 'itemType': InviteUsersRequestPhoneInviteeList },
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InviteUsersRequest = InviteUsersRequest;
class InviteUsersResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InviteUsersResponseBody = InviteUsersResponseBody;
class InviteUsersResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: InviteUsersResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InviteUsersResponse = InviteUsersResponse;
class KickMembersHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.KickMembersHeaders = KickMembersHeaders;
class KickMembersRequest extends $tea.Model {
    static names() {
        return {
            forbiddenRejoin: 'forbiddenRejoin',
            userList: 'userList',
        };
    }
    static types() {
        return {
            forbiddenRejoin: 'boolean',
            userList: { 'type': 'array', 'itemType': KickMembersRequestUserList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.KickMembersRequest = KickMembersRequest;
class KickMembersResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.KickMembersResponseBody = KickMembersResponseBody;
class KickMembersResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: KickMembersResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.KickMembersResponse = KickMembersResponse;
class LockConferenceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.LockConferenceHeaders = LockConferenceHeaders;
class LockConferenceRequest extends $tea.Model {
    static names() {
        return {
            action: 'action',
        };
    }
    static types() {
        return {
            action: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.LockConferenceRequest = LockConferenceRequest;
class LockConferenceResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.LockConferenceResponseBody = LockConferenceResponseBody;
class LockConferenceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: LockConferenceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.LockConferenceResponse = LockConferenceResponse;
class MuteAllHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MuteAllHeaders = MuteAllHeaders;
class MuteAllRequest extends $tea.Model {
    static names() {
        return {
            action: 'action',
            forceMute: 'forceMute',
        };
    }
    static types() {
        return {
            action: 'string',
            forceMute: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MuteAllRequest = MuteAllRequest;
class MuteAllResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MuteAllResponseBody = MuteAllResponseBody;
class MuteAllResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MuteAllResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MuteAllResponse = MuteAllResponse;
class MuteMembersHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MuteMembersHeaders = MuteMembersHeaders;
class MuteMembersRequest extends $tea.Model {
    static names() {
        return {
            action: 'action',
            userList: 'userList',
        };
    }
    static types() {
        return {
            action: 'string',
            userList: { 'type': 'array', 'itemType': MuteMembersRequestUserList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MuteMembersRequest = MuteMembersRequest;
class MuteMembersResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MuteMembersResponseBody = MuteMembersResponseBody;
class MuteMembersResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MuteMembersResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MuteMembersResponse = MuteMembersResponse;
class QueryCloudRecordTextHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordTextHeaders = QueryCloudRecordTextHeaders;
class QueryCloudRecordTextRequest extends $tea.Model {
    static names() {
        return {
            direction: 'direction',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            startTime: 'startTime',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            direction: 'string',
            maxResults: 'number',
            nextToken: 'number',
            startTime: 'number',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordTextRequest = QueryCloudRecordTextRequest;
class QueryCloudRecordTextResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            paragraphList: 'paragraphList',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            paragraphList: { 'type': 'array', 'itemType': QueryCloudRecordTextResponseBodyParagraphList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordTextResponseBody = QueryCloudRecordTextResponseBody;
class QueryCloudRecordTextResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCloudRecordTextResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordTextResponse = QueryCloudRecordTextResponse;
class QueryCloudRecordVideoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordVideoHeaders = QueryCloudRecordVideoHeaders;
class QueryCloudRecordVideoRequest extends $tea.Model {
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordVideoRequest = QueryCloudRecordVideoRequest;
class QueryCloudRecordVideoResponseBody extends $tea.Model {
    static names() {
        return {
            videoList: 'videoList',
        };
    }
    static types() {
        return {
            videoList: { 'type': 'array', 'itemType': QueryCloudRecordVideoResponseBodyVideoList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordVideoResponseBody = QueryCloudRecordVideoResponseBody;
class QueryCloudRecordVideoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCloudRecordVideoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordVideoResponse = QueryCloudRecordVideoResponse;
class QueryCloudRecordVideoPlayInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordVideoPlayInfoHeaders = QueryCloudRecordVideoPlayInfoHeaders;
class QueryCloudRecordVideoPlayInfoRequest extends $tea.Model {
    static names() {
        return {
            mediaId: 'mediaId',
            regionId: 'regionId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            mediaId: 'string',
            regionId: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordVideoPlayInfoRequest = QueryCloudRecordVideoPlayInfoRequest;
class QueryCloudRecordVideoPlayInfoResponseBody extends $tea.Model {
    static names() {
        return {
            duration: 'duration',
            fileSize: 'fileSize',
            mp4FileUrl: 'mp4FileUrl',
            playUrl: 'playUrl',
            status: 'status',
        };
    }
    static types() {
        return {
            duration: 'number',
            fileSize: 'number',
            mp4FileUrl: 'string',
            playUrl: 'string',
            status: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordVideoPlayInfoResponseBody = QueryCloudRecordVideoPlayInfoResponseBody;
class QueryCloudRecordVideoPlayInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCloudRecordVideoPlayInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordVideoPlayInfoResponse = QueryCloudRecordVideoPlayInfoResponse;
class QueryConferenceInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoHeaders = QueryConferenceInfoHeaders;
class QueryConferenceInfoResponseBody extends $tea.Model {
    static names() {
        return {
            confInfo: 'confInfo',
        };
    }
    static types() {
        return {
            confInfo: QueryConferenceInfoResponseBodyConfInfo,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoResponseBody = QueryConferenceInfoResponseBody;
class QueryConferenceInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryConferenceInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoResponse = QueryConferenceInfoResponse;
class QueryConferenceInfoBatchHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoBatchHeaders = QueryConferenceInfoBatchHeaders;
class QueryConferenceInfoBatchRequest extends $tea.Model {
    static names() {
        return {
            conferenceIdList: 'conferenceIdList',
        };
    }
    static types() {
        return {
            conferenceIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoBatchRequest = QueryConferenceInfoBatchRequest;
class QueryConferenceInfoBatchResponseBody extends $tea.Model {
    static names() {
        return {
            infos: 'infos',
        };
    }
    static types() {
        return {
            infos: { 'type': 'array', 'itemType': QueryConferenceInfoBatchResponseBodyInfos },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoBatchResponseBody = QueryConferenceInfoBatchResponseBody;
class QueryConferenceInfoBatchResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryConferenceInfoBatchResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoBatchResponse = QueryConferenceInfoBatchResponse;
class QueryConferenceInfoByRoomCodeHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoByRoomCodeHeaders = QueryConferenceInfoByRoomCodeHeaders;
class QueryConferenceInfoByRoomCodeRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoByRoomCodeRequest = QueryConferenceInfoByRoomCodeRequest;
class QueryConferenceInfoByRoomCodeResponseBody extends $tea.Model {
    static names() {
        return {
            conferenceList: 'conferenceList',
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            conferenceList: { 'type': 'array', 'itemType': QueryConferenceInfoByRoomCodeResponseBodyConferenceList },
            hasMore: 'boolean',
            nextToken: 'string',
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoByRoomCodeResponseBody = QueryConferenceInfoByRoomCodeResponseBody;
class QueryConferenceInfoByRoomCodeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryConferenceInfoByRoomCodeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoByRoomCodeResponse = QueryConferenceInfoByRoomCodeResponse;
class QueryConferenceMembersHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceMembersHeaders = QueryConferenceMembersHeaders;
class QueryConferenceMembersRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceMembersRequest = QueryConferenceMembersRequest;
class QueryConferenceMembersResponseBody extends $tea.Model {
    static names() {
        return {
            memberModels: 'memberModels',
            nextToken: 'nextToken',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            memberModels: { 'type': 'array', 'itemType': QueryConferenceMembersResponseBodyMemberModels },
            nextToken: 'string',
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceMembersResponseBody = QueryConferenceMembersResponseBody;
class QueryConferenceMembersResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryConferenceMembersResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceMembersResponse = QueryConferenceMembersResponse;
class QueryFlashMinutesSummaryHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryFlashMinutesSummaryHeaders = QueryFlashMinutesSummaryHeaders;
class QueryFlashMinutesSummaryRequest extends $tea.Model {
    static names() {
        return {
            bizType: 'bizType',
            recorderUnionId: 'recorderUnionId',
        };
    }
    static types() {
        return {
            bizType: 'string',
            recorderUnionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryFlashMinutesSummaryRequest = QueryFlashMinutesSummaryRequest;
class QueryFlashMinutesSummaryResponseBody extends $tea.Model {
    static names() {
        return {
            flashMinutesSummary: 'flashMinutesSummary',
        };
    }
    static types() {
        return {
            flashMinutesSummary: QueryFlashMinutesSummaryResponseBodyFlashMinutesSummary,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryFlashMinutesSummaryResponseBody = QueryFlashMinutesSummaryResponseBody;
class QueryFlashMinutesSummaryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryFlashMinutesSummaryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryFlashMinutesSummaryResponse = QueryFlashMinutesSummaryResponse;
class QueryMinutesAudioHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesAudioHeaders = QueryMinutesAudioHeaders;
class QueryMinutesAudioRequest extends $tea.Model {
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesAudioRequest = QueryMinutesAudioRequest;
class QueryMinutesAudioResponseBody extends $tea.Model {
    static names() {
        return {
            audioList: 'audioList',
        };
    }
    static types() {
        return {
            audioList: { 'type': 'array', 'itemType': QueryMinutesAudioResponseBodyAudioList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesAudioResponseBody = QueryMinutesAudioResponseBody;
class QueryMinutesAudioResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryMinutesAudioResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesAudioResponse = QueryMinutesAudioResponse;
class QueryMinutesSummaryHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesSummaryHeaders = QueryMinutesSummaryHeaders;
class QueryMinutesSummaryRequest extends $tea.Model {
    static names() {
        return {
            summaryTypeList: 'summaryTypeList',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            summaryTypeList: { 'type': 'array', 'itemType': 'string' },
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesSummaryRequest = QueryMinutesSummaryRequest;
class QueryMinutesSummaryResponseBody extends $tea.Model {
    static names() {
        return {
            summary: 'summary',
        };
    }
    static types() {
        return {
            summary: QueryMinutesSummaryResponseBodySummary,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesSummaryResponseBody = QueryMinutesSummaryResponseBody;
class QueryMinutesSummaryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryMinutesSummaryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesSummaryResponse = QueryMinutesSummaryResponse;
class QueryMinutesTextHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesTextHeaders = QueryMinutesTextHeaders;
class QueryMinutesTextRequest extends $tea.Model {
    static names() {
        return {
            direction: 'direction',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            direction: 'string',
            maxResults: 'number',
            nextToken: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesTextRequest = QueryMinutesTextRequest;
class QueryMinutesTextResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            paragraphList: 'paragraphList',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'string',
            paragraphList: { 'type': 'array', 'itemType': QueryMinutesTextResponseBodyParagraphList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesTextResponseBody = QueryMinutesTextResponseBody;
class QueryMinutesTextResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryMinutesTextResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesTextResponse = QueryMinutesTextResponse;
class QueryOrgConferenceListHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryOrgConferenceListHeaders = QueryOrgConferenceListHeaders;
class QueryOrgConferenceListRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryOrgConferenceListRequest = QueryOrgConferenceListRequest;
class QueryOrgConferenceListResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            onGoingConfList: 'onGoingConfList',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'string',
            onGoingConfList: { 'type': 'array', 'itemType': QueryOrgConferenceListResponseBodyOnGoingConfList },
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryOrgConferenceListResponseBody = QueryOrgConferenceListResponseBody;
class QueryOrgConferenceListResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryOrgConferenceListResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryOrgConferenceListResponse = QueryOrgConferenceListResponse;
class QueryRecordMinutesUrlHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryRecordMinutesUrlHeaders = QueryRecordMinutesUrlHeaders;
class QueryRecordMinutesUrlRequest extends $tea.Model {
    static names() {
        return {
            bizType: 'bizType',
            recorderUnionId: 'recorderUnionId',
        };
    }
    static types() {
        return {
            bizType: 'string',
            recorderUnionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryRecordMinutesUrlRequest = QueryRecordMinutesUrlRequest;
class QueryRecordMinutesUrlResponseBody extends $tea.Model {
    static names() {
        return {
            recordMinutesUrls: 'recordMinutesUrls',
        };
    }
    static types() {
        return {
            recordMinutesUrls: { 'type': 'array', 'itemType': QueryRecordMinutesUrlResponseBodyRecordMinutesUrls },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryRecordMinutesUrlResponseBody = QueryRecordMinutesUrlResponseBody;
class QueryRecordMinutesUrlResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryRecordMinutesUrlResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryRecordMinutesUrlResponse = QueryRecordMinutesUrlResponse;
class QueryScheduleConfSettingsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConfSettingsHeaders = QueryScheduleConfSettingsHeaders;
class QueryScheduleConfSettingsRequest extends $tea.Model {
    static names() {
        return {
            scheduleConferenceId: 'scheduleConferenceId',
        };
    }
    static types() {
        return {
            scheduleConferenceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConfSettingsRequest = QueryScheduleConfSettingsRequest;
class QueryScheduleConfSettingsResponseBody extends $tea.Model {
    static names() {
        return {
            scheduleConfSettingModel: 'scheduleConfSettingModel',
        };
    }
    static types() {
        return {
            scheduleConfSettingModel: QueryScheduleConfSettingsResponseBodyScheduleConfSettingModel,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConfSettingsResponseBody = QueryScheduleConfSettingsResponseBody;
class QueryScheduleConfSettingsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryScheduleConfSettingsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConfSettingsResponse = QueryScheduleConfSettingsResponse;
class QueryScheduleConferenceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConferenceHeaders = QueryScheduleConferenceHeaders;
class QueryScheduleConferenceRequest extends $tea.Model {
    static names() {
        return {
            requestUnionId: 'requestUnionId',
        };
    }
    static types() {
        return {
            requestUnionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConferenceRequest = QueryScheduleConferenceRequest;
class QueryScheduleConferenceResponseBody extends $tea.Model {
    static names() {
        return {
            endTime: 'endTime',
            phones: 'phones',
            requestId: 'requestId',
            roomCode: 'roomCode',
            scheduleConferenceId: 'scheduleConferenceId',
            startTime: 'startTime',
            title: 'title',
            url: 'url',
        };
    }
    static types() {
        return {
            endTime: 'number',
            phones: { 'type': 'array', 'itemType': 'string' },
            requestId: 'string',
            roomCode: 'string',
            scheduleConferenceId: 'string',
            startTime: 'number',
            title: 'string',
            url: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConferenceResponseBody = QueryScheduleConferenceResponseBody;
class QueryScheduleConferenceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryScheduleConferenceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConferenceResponse = QueryScheduleConferenceResponse;
class QueryScheduleConferenceInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConferenceInfoHeaders = QueryScheduleConferenceInfoHeaders;
class QueryScheduleConferenceInfoRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConferenceInfoRequest = QueryScheduleConferenceInfoRequest;
class QueryScheduleConferenceInfoResponseBody extends $tea.Model {
    static names() {
        return {
            conferenceList: 'conferenceList',
            nextToken: 'nextToken',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            conferenceList: { 'type': 'array', 'itemType': QueryScheduleConferenceInfoResponseBodyConferenceList },
            nextToken: 'string',
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConferenceInfoResponseBody = QueryScheduleConferenceInfoResponseBody;
class QueryScheduleConferenceInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryScheduleConferenceInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConferenceInfoResponse = QueryScheduleConferenceInfoResponse;
class QueryUserOnGoingConferenceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUserOnGoingConferenceHeaders = QueryUserOnGoingConferenceHeaders;
class QueryUserOnGoingConferenceRequest extends $tea.Model {
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUserOnGoingConferenceRequest = QueryUserOnGoingConferenceRequest;
class QueryUserOnGoingConferenceResponseBody extends $tea.Model {
    static names() {
        return {
            memberModelMap: 'memberModelMap',
            onGoingConfIdList: 'onGoingConfIdList',
        };
    }
    static types() {
        return {
            memberModelMap: { 'type': 'map', 'keyType': 'string', 'valueType': MemberModelMapValue },
            onGoingConfIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUserOnGoingConferenceResponseBody = QueryUserOnGoingConferenceResponseBody;
class QueryUserOnGoingConferenceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryUserOnGoingConferenceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryUserOnGoingConferenceResponse = QueryUserOnGoingConferenceResponse;
class StartCloudRecordHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartCloudRecordHeaders = StartCloudRecordHeaders;
class StartCloudRecordRequest extends $tea.Model {
    static names() {
        return {
            mode: 'mode',
            smallWindowPosition: 'smallWindowPosition',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            mode: 'string',
            smallWindowPosition: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartCloudRecordRequest = StartCloudRecordRequest;
class StartCloudRecordResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'code',
        };
    }
    static types() {
        return {
            code: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartCloudRecordResponseBody = StartCloudRecordResponseBody;
class StartCloudRecordResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StartCloudRecordResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartCloudRecordResponse = StartCloudRecordResponse;
class StartMinutesHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartMinutesHeaders = StartMinutesHeaders;
class StartMinutesRequest extends $tea.Model {
    static names() {
        return {
            ownerUnionId: 'ownerUnionId',
            recordAudio: 'recordAudio',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            ownerUnionId: 'string',
            recordAudio: 'boolean',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartMinutesRequest = StartMinutesRequest;
class StartMinutesResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'code',
        };
    }
    static types() {
        return {
            code: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartMinutesResponseBody = StartMinutesResponseBody;
class StartMinutesResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StartMinutesResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartMinutesResponse = StartMinutesResponse;
class StartStreamOutHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartStreamOutHeaders = StartStreamOutHeaders;
class StartStreamOutRequest extends $tea.Model {
    static names() {
        return {
            mode: 'mode',
            needHostJoin: 'needHostJoin',
            smallWindowPosition: 'smallWindowPosition',
            streamName: 'streamName',
            streamUrlList: 'streamUrlList',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            mode: 'string',
            needHostJoin: 'boolean',
            smallWindowPosition: 'string',
            streamName: 'string',
            streamUrlList: { 'type': 'array', 'itemType': 'string' },
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartStreamOutRequest = StartStreamOutRequest;
class StartStreamOutResponseBody extends $tea.Model {
    static names() {
        return {
            failStreamMap: 'failStreamMap',
            successStreamMap: 'successStreamMap',
        };
    }
    static types() {
        return {
            failStreamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            successStreamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartStreamOutResponseBody = StartStreamOutResponseBody;
class StartStreamOutResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StartStreamOutResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StartStreamOutResponse = StartStreamOutResponse;
class StopCloudRecordHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopCloudRecordHeaders = StopCloudRecordHeaders;
class StopCloudRecordRequest extends $tea.Model {
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopCloudRecordRequest = StopCloudRecordRequest;
class StopCloudRecordResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'code',
        };
    }
    static types() {
        return {
            code: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopCloudRecordResponseBody = StopCloudRecordResponseBody;
class StopCloudRecordResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StopCloudRecordResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopCloudRecordResponse = StopCloudRecordResponse;
class StopMinutesHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopMinutesHeaders = StopMinutesHeaders;
class StopMinutesRequest extends $tea.Model {
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopMinutesRequest = StopMinutesRequest;
class StopMinutesResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'code',
        };
    }
    static types() {
        return {
            code: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopMinutesResponseBody = StopMinutesResponseBody;
class StopMinutesResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StopMinutesResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopMinutesResponse = StopMinutesResponse;
class StopStreamOutHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopStreamOutHeaders = StopStreamOutHeaders;
class StopStreamOutRequest extends $tea.Model {
    static names() {
        return {
            stopAllStream: 'stopAllStream',
            streamId: 'streamId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            stopAllStream: 'boolean',
            streamId: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopStreamOutRequest = StopStreamOutRequest;
class StopStreamOutResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'code',
        };
    }
    static types() {
        return {
            code: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopStreamOutResponseBody = StopStreamOutResponseBody;
class StopStreamOutResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StopStreamOutResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.StopStreamOutResponse = StopStreamOutResponse;
class UpdateScheduleConfSettingsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConfSettingsHeaders = UpdateScheduleConfSettingsHeaders;
class UpdateScheduleConfSettingsRequest extends $tea.Model {
    static names() {
        return {
            creatorUnionId: 'creatorUnionId',
            scheduleConfSettingModel: 'scheduleConfSettingModel',
            scheduleConferenceId: 'scheduleConferenceId',
        };
    }
    static types() {
        return {
            creatorUnionId: 'string',
            scheduleConfSettingModel: UpdateScheduleConfSettingsRequestScheduleConfSettingModel,
            scheduleConferenceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConfSettingsRequest = UpdateScheduleConfSettingsRequest;
class UpdateScheduleConfSettingsResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConfSettingsResponseBody = UpdateScheduleConfSettingsResponseBody;
class UpdateScheduleConfSettingsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateScheduleConfSettingsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConfSettingsResponse = UpdateScheduleConfSettingsResponse;
class UpdateScheduleConferenceHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConferenceHeaders = UpdateScheduleConferenceHeaders;
class UpdateScheduleConferenceRequest extends $tea.Model {
    static names() {
        return {
            creatorUnionId: 'creatorUnionId',
            endTime: 'endTime',
            scheduleConferenceId: 'scheduleConferenceId',
            startTime: 'startTime',
            title: 'title',
        };
    }
    static types() {
        return {
            creatorUnionId: 'string',
            endTime: 'number',
            scheduleConferenceId: 'string',
            startTime: 'number',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConferenceRequest = UpdateScheduleConferenceRequest;
class UpdateScheduleConferenceResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConferenceResponseBody = UpdateScheduleConferenceResponseBody;
class UpdateScheduleConferenceResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateScheduleConferenceResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConferenceResponse = UpdateScheduleConferenceResponse;
class UpdateVideoConferenceExtInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateVideoConferenceExtInfoHeaders = UpdateVideoConferenceExtInfoHeaders;
class UpdateVideoConferenceExtInfoResponseBody extends $tea.Model {
    static names() {
        return {
            case: 'case',
            code: 'code',
        };
    }
    static types() {
        return {
            case: 'string',
            code: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateVideoConferenceExtInfoResponseBody = UpdateVideoConferenceExtInfoResponseBody;
class UpdateVideoConferenceExtInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateVideoConferenceExtInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateVideoConferenceExtInfoResponse = UpdateVideoConferenceExtInfoResponse;
class UpdateVideoConferenceSettingHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateVideoConferenceSettingHeaders = UpdateVideoConferenceSettingHeaders;
class UpdateVideoConferenceSettingRequest extends $tea.Model {
    static names() {
        return {
            allowUnmuteSelf: 'allowUnmuteSelf',
            autoTransferHost: 'autoTransferHost',
            forbiddenShareScreen: 'forbiddenShareScreen',
            lockConference: 'lockConference',
            muteAll: 'muteAll',
            onlyInternalEmployeesJoin: 'onlyInternalEmployeesJoin',
        };
    }
    static types() {
        return {
            allowUnmuteSelf: 'boolean',
            autoTransferHost: 'boolean',
            forbiddenShareScreen: 'boolean',
            lockConference: 'boolean',
            muteAll: 'boolean',
            onlyInternalEmployeesJoin: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateVideoConferenceSettingRequest = UpdateVideoConferenceSettingRequest;
class UpdateVideoConferenceSettingResponseBody extends $tea.Model {
    static names() {
        return {
            case: 'case',
            code: 'code',
        };
    }
    static types() {
        return {
            case: 'string',
            code: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateVideoConferenceSettingResponseBody = UpdateVideoConferenceSettingResponseBody;
class UpdateVideoConferenceSettingResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateVideoConferenceSettingResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateVideoConferenceSettingResponse = UpdateVideoConferenceSettingResponse;
class CohostsRequestUserList extends $tea.Model {
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CohostsRequestUserList = CohostsRequestUserList;
class CreateCustomShortLinkResponseBodyResult extends $tea.Model {
    static names() {
        return {
            customShortLink: 'customShortLink',
        };
    }
    static types() {
        return {
            customShortLink: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateCustomShortLinkResponseBodyResult = CreateCustomShortLinkResponseBodyResult;
class CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfOpenRecordSetting extends $tea.Model {
    static names() {
        return {
            isFollowHost: 'isFollowHost',
            mode: 'mode',
            recordAutoStart: 'recordAutoStart',
            recordAutoStartType: 'recordAutoStartType',
        };
    }
    static types() {
        return {
            isFollowHost: 'boolean',
            mode: 'string',
            recordAutoStart: 'number',
            recordAutoStartType: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfOpenRecordSetting = CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfOpenRecordSetting;
class CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings extends $tea.Model {
    static names() {
        return {
            autoOpenMode: 'autoOpenMode',
            coolAppCode: 'coolAppCode',
            extensionAppBizData: 'extensionAppBizData',
        };
    }
    static types() {
        return {
            autoOpenMode: 'number',
            coolAppCode: 'string',
            extensionAppBizData: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings = CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings;
class CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSetting extends $tea.Model {
    static names() {
        return {
            cloudRecordOwnerUnionId: 'cloudRecordOwnerUnionId',
            enableChat: 'enableChat',
            enableWebAnonymousJoin: 'enableWebAnonymousJoin',
            joinBeforeHost: 'joinBeforeHost',
            lockMediaStatusMicMute: 'lockMediaStatusMicMute',
            lockNick: 'lockNick',
            minutesOwnerUnionId: 'minutesOwnerUnionId',
            moziConfExtensionAppSettings: 'moziConfExtensionAppSettings',
            pushAllMeetingRecords: 'pushAllMeetingRecords',
            pushCloudRecordCard: 'pushCloudRecordCard',
            pushMinutesCard: 'pushMinutesCard',
            waitingRoom: 'waitingRoom',
        };
    }
    static types() {
        return {
            cloudRecordOwnerUnionId: 'string',
            enableChat: 'number',
            enableWebAnonymousJoin: 'boolean',
            joinBeforeHost: 'number',
            lockMediaStatusMicMute: 'number',
            lockNick: 'number',
            minutesOwnerUnionId: 'string',
            moziConfExtensionAppSettings: { 'type': 'array', 'itemType': CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings },
            pushAllMeetingRecords: 'boolean',
            pushCloudRecordCard: 'boolean',
            pushMinutesCard: 'boolean',
            waitingRoom: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSetting = CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSetting;
class CreateScheduleConferenceRequestScheduleConfSettingModel extends $tea.Model {
    static names() {
        return {
            cohostUnionIds: 'cohostUnionIds',
            confAllowedCorpId: 'confAllowedCorpId',
            hostUnionId: 'hostUnionId',
            lockRoom: 'lockRoom',
            moziConfOpenRecordSetting: 'moziConfOpenRecordSetting',
            moziConfVirtualExtraSetting: 'moziConfVirtualExtraSetting',
            muteOnJoin: 'muteOnJoin',
            screenShareForbidden: 'screenShareForbidden',
        };
    }
    static types() {
        return {
            cohostUnionIds: { 'type': 'array', 'itemType': 'string' },
            confAllowedCorpId: 'string',
            hostUnionId: 'string',
            lockRoom: 'number',
            moziConfOpenRecordSetting: CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfOpenRecordSetting,
            moziConfVirtualExtraSetting: CreateScheduleConferenceRequestScheduleConfSettingModelMoziConfVirtualExtraSetting,
            muteOnJoin: 'number',
            screenShareForbidden: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateScheduleConferenceRequestScheduleConfSettingModel = CreateScheduleConferenceRequestScheduleConfSettingModel;
class GetConfDetailDataResponseBodyList extends $tea.Model {
    static names() {
        return {
            belongOrg: 'belongOrg',
            conferenceId: 'conferenceId',
            deviceType: 'deviceType',
            duration: 'duration',
            joinTime: 'joinTime',
            leaveTime: 'leaveTime',
            networkQuality: 'networkQuality',
            nick: 'nick',
            role: 'role',
            sessionId: 'sessionId',
            status: 'status',
            unionId: 'unionId',
            version: 'version',
        };
    }
    static types() {
        return {
            belongOrg: 'string',
            conferenceId: 'string',
            deviceType: 'string',
            duration: 'number',
            joinTime: 'number',
            leaveTime: 'number',
            networkQuality: 'string',
            nick: 'string',
            role: 'string',
            sessionId: 'string',
            status: 'string',
            unionId: 'string',
            version: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetConfDetailDataResponseBodyList = GetConfDetailDataResponseBodyList;
class GetHistoryConfDataListResponseBodyList extends $tea.Model {
    static names() {
        return {
            conferenceId: 'conferenceId',
            creatorId: 'creatorId',
            creatorNick: 'creatorNick',
            deptName: 'deptName',
            endTime: 'endTime',
            freeType: 'freeType',
            scene: 'scene',
            startTime: 'startTime',
            timeLength: 'timeLength',
            title: 'title',
            userCount: 'userCount',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            creatorId: 'string',
            creatorNick: 'string',
            deptName: 'string',
            endTime: 'number',
            freeType: 'string',
            scene: 'string',
            startTime: 'number',
            timeLength: 'number',
            title: 'string',
            userCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetHistoryConfDataListResponseBodyList = GetHistoryConfDataListResponseBodyList;
class GetUserMetricDataResponseBodyMetricDataList extends $tea.Model {
    static names() {
        return {
            audioPlayLevel: 'audioPlayLevel',
            audioRecLevel: 'audioRecLevel',
            audioRecvBitRate: 'audioRecvBitRate',
            audioSendBitRate: 'audioSendBitRate',
            cameraRecvBitRate: 'cameraRecvBitRate',
            cameraRecvFrame: 'cameraRecvFrame',
            cameraRecvResolutionActual: 'cameraRecvResolutionActual',
            cameraSendBitRate: 'cameraSendBitRate',
            cameraSendFrame: 'cameraSendFrame',
            cameraSendResolutionActual: 'cameraSendResolutionActual',
            lostRate: 'lostRate',
            recvBitRate: 'recvBitRate',
            roundTripTime: 'roundTripTime',
            screenRecvBitRate: 'screenRecvBitRate',
            screenRecvFrame: 'screenRecvFrame',
            screenRecvResolutionActual: 'screenRecvResolutionActual',
            screenSendBitRate: 'screenSendBitRate',
            screenSendFrame: 'screenSendFrame',
            screenSendResolutionActual: 'screenSendResolutionActual',
            sendBitRate: 'sendBitRate',
            timestamp: 'timestamp',
        };
    }
    static types() {
        return {
            audioPlayLevel: 'string',
            audioRecLevel: 'string',
            audioRecvBitRate: 'string',
            audioSendBitRate: 'string',
            cameraRecvBitRate: 'string',
            cameraRecvFrame: 'string',
            cameraRecvResolutionActual: 'string',
            cameraSendBitRate: 'string',
            cameraSendFrame: 'string',
            cameraSendResolutionActual: 'string',
            lostRate: 'string',
            recvBitRate: 'string',
            roundTripTime: 'string',
            screenRecvBitRate: 'string',
            screenRecvFrame: 'string',
            screenRecvResolutionActual: 'string',
            screenSendBitRate: 'string',
            screenSendFrame: 'string',
            screenSendResolutionActual: 'string',
            sendBitRate: 'string',
            timestamp: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetUserMetricDataResponseBodyMetricDataList = GetUserMetricDataResponseBodyMetricDataList;
class InviteUsersRequestInviteeList extends $tea.Model {
    static names() {
        return {
            nick: 'nick',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            nick: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InviteUsersRequestInviteeList = InviteUsersRequestInviteeList;
class InviteUsersRequestPhoneInviteeList extends $tea.Model {
    static names() {
        return {
            inviteClient: 'inviteClient',
            nick: 'nick',
            phoneNumber: 'phoneNumber',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            inviteClient: 'boolean',
            nick: 'string',
            phoneNumber: 'string',
            statusCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InviteUsersRequestPhoneInviteeList = InviteUsersRequestPhoneInviteeList;
class KickMembersRequestUserList extends $tea.Model {
    static names() {
        return {
            participantId: 'participantId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            participantId: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.KickMembersRequestUserList = KickMembersRequestUserList;
class MuteMembersRequestUserList extends $tea.Model {
    static names() {
        return {
            participantId: 'participantId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            participantId: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.MuteMembersRequestUserList = MuteMembersRequestUserList;
class QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList extends $tea.Model {
    static names() {
        return {
            endTime: 'endTime',
            startTime: 'startTime',
            word: 'word',
            wordId: 'wordId',
        };
    }
    static types() {
        return {
            endTime: 'number',
            startTime: 'number',
            word: 'string',
            wordId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList = QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList;
class QueryCloudRecordTextResponseBodyParagraphListSentenceList extends $tea.Model {
    static names() {
        return {
            endTime: 'endTime',
            sentence: 'sentence',
            startTime: 'startTime',
            unionId: 'unionId',
            wordList: 'wordList',
        };
    }
    static types() {
        return {
            endTime: 'number',
            sentence: 'string',
            startTime: 'number',
            unionId: 'string',
            wordList: { 'type': 'array', 'itemType': QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordTextResponseBodyParagraphListSentenceList = QueryCloudRecordTextResponseBodyParagraphListSentenceList;
class QueryCloudRecordTextResponseBodyParagraphList extends $tea.Model {
    static names() {
        return {
            endTime: 'endTime',
            nextTtoken: 'nextTtoken',
            nickName: 'nickName',
            paragraph: 'paragraph',
            recordId: 'recordId',
            sentenceList: 'sentenceList',
            startTime: 'startTime',
            status: 'status',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            endTime: 'number',
            nextTtoken: 'number',
            nickName: 'string',
            paragraph: 'string',
            recordId: 'number',
            sentenceList: { 'type': 'array', 'itemType': QueryCloudRecordTextResponseBodyParagraphListSentenceList },
            startTime: 'number',
            status: 'number',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordTextResponseBodyParagraphList = QueryCloudRecordTextResponseBodyParagraphList;
class QueryCloudRecordVideoResponseBodyVideoList extends $tea.Model {
    static names() {
        return {
            duration: 'duration',
            endTime: 'endTime',
            fileSize: 'fileSize',
            mediaId: 'mediaId',
            recordId: 'recordId',
            recordType: 'recordType',
            regionId: 'regionId',
            startTime: 'startTime',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            duration: 'number',
            endTime: 'number',
            fileSize: 'number',
            mediaId: 'string',
            recordId: 'string',
            recordType: 'number',
            regionId: 'string',
            startTime: 'number',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryCloudRecordVideoResponseBodyVideoList = QueryCloudRecordVideoResponseBodyVideoList;
class QueryConferenceInfoResponseBodyConfInfoExtensionAppSettings extends $tea.Model {
    static names() {
        return {
            appCode: 'appCode',
            appId: 'appId',
            autoOpenMode: 'autoOpenMode',
            extensionAppBizData: 'extensionAppBizData',
        };
    }
    static types() {
        return {
            appCode: 'string',
            appId: 'string',
            autoOpenMode: 'number',
            extensionAppBizData: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoResponseBodyConfInfoExtensionAppSettings = QueryConferenceInfoResponseBodyConfInfoExtensionAppSettings;
class QueryConferenceInfoResponseBodyConfInfo extends $tea.Model {
    static names() {
        return {
            activeNum: 'activeNum',
            attendNum: 'attendNum',
            bizType: 'bizType',
            cloudRecordOwnerUnionId: 'cloudRecordOwnerUnionId',
            cloudRecordStatus: 'cloudRecordStatus',
            confDuration: 'confDuration',
            conferenceId: 'conferenceId',
            creatorId: 'creatorId',
            creatorNick: 'creatorNick',
            endTime: 'endTime',
            extensionAppSettings: 'extensionAppSettings',
            externalLinkUrl: 'externalLinkUrl',
            invitedNum: 'invitedNum',
            minutesOwnerUnionId: 'minutesOwnerUnionId',
            minutesStatus: 'minutesStatus',
            roomCode: 'roomCode',
            scheduleConferenceId: 'scheduleConferenceId',
            startTime: 'startTime',
            status: 'status',
            title: 'title',
        };
    }
    static types() {
        return {
            activeNum: 'number',
            attendNum: 'number',
            bizType: 'string',
            cloudRecordOwnerUnionId: 'string',
            cloudRecordStatus: 'number',
            confDuration: 'number',
            conferenceId: 'string',
            creatorId: 'string',
            creatorNick: 'string',
            endTime: 'number',
            extensionAppSettings: { 'type': 'array', 'itemType': QueryConferenceInfoResponseBodyConfInfoExtensionAppSettings },
            externalLinkUrl: 'string',
            invitedNum: 'number',
            minutesOwnerUnionId: 'string',
            minutesStatus: 'number',
            roomCode: 'string',
            scheduleConferenceId: 'string',
            startTime: 'number',
            status: 'number',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoResponseBodyConfInfo = QueryConferenceInfoResponseBodyConfInfo;
class QueryConferenceInfoBatchResponseBodyInfosUserList extends $tea.Model {
    static names() {
        return {
            attendStatus: 'attendStatus',
            cameraStatus: 'cameraStatus',
            micStatus: 'micStatus',
            nick: 'nick',
            rejectDescription: 'rejectDescription',
            userId: 'userId',
        };
    }
    static types() {
        return {
            attendStatus: 'number',
            cameraStatus: 'number',
            micStatus: 'number',
            nick: 'string',
            rejectDescription: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoBatchResponseBodyInfosUserList = QueryConferenceInfoBatchResponseBodyInfosUserList;
class QueryConferenceInfoBatchResponseBodyInfos extends $tea.Model {
    static names() {
        return {
            conferenceId: 'conferenceId',
            mediaStatus: 'mediaStatus',
            startTime: 'startTime',
            status: 'status',
            title: 'title',
            userList: 'userList',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            mediaStatus: 'number',
            startTime: 'number',
            status: 'number',
            title: 'string',
            userList: { 'type': 'array', 'itemType': QueryConferenceInfoBatchResponseBodyInfosUserList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoBatchResponseBodyInfos = QueryConferenceInfoBatchResponseBodyInfos;
class QueryConferenceInfoByRoomCodeResponseBodyConferenceList extends $tea.Model {
    static names() {
        return {
            bizType: 'bizType',
            confDuration: 'confDuration',
            conferenceId: 'conferenceId',
            creatorId: 'creatorId',
            creatorNick: 'creatorNick',
            endTime: 'endTime',
            externalLinkUrl: 'externalLinkUrl',
            roomCode: 'roomCode',
            scheduleConferenceId: 'scheduleConferenceId',
            startTime: 'startTime',
            status: 'status',
            title: 'title',
        };
    }
    static types() {
        return {
            bizType: 'string',
            confDuration: 'number',
            conferenceId: 'string',
            creatorId: 'string',
            creatorNick: 'string',
            endTime: 'number',
            externalLinkUrl: 'string',
            roomCode: 'string',
            scheduleConferenceId: 'string',
            startTime: 'number',
            status: 'number',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceInfoByRoomCodeResponseBodyConferenceList = QueryConferenceInfoByRoomCodeResponseBodyConferenceList;
class QueryConferenceMembersResponseBodyMemberModels extends $tea.Model {
    static names() {
        return {
            attendStatus: 'attendStatus',
            coHost: 'coHost',
            conferenceId: 'conferenceId',
            duration: 'duration',
            host: 'host',
            joinTime: 'joinTime',
            leaveTime: 'leaveTime',
            outerOrgMember: 'outerOrgMember',
            pstnJoin: 'pstnJoin',
            unionId: 'unionId',
            userNick: 'userNick',
        };
    }
    static types() {
        return {
            attendStatus: 'number',
            coHost: 'boolean',
            conferenceId: 'string',
            duration: 'number',
            host: 'boolean',
            joinTime: 'number',
            leaveTime: 'number',
            outerOrgMember: 'boolean',
            pstnJoin: 'boolean',
            unionId: 'string',
            userNick: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryConferenceMembersResponseBodyMemberModels = QueryConferenceMembersResponseBodyMemberModels;
class QueryFlashMinutesSummaryResponseBodyFlashMinutesSummarySummary extends $tea.Model {
    static names() {
        return {
            end: 'end',
            headline: 'headline',
            id: 'id',
            start: 'start',
            summary: 'summary',
        };
    }
    static types() {
        return {
            end: 'number',
            headline: 'string',
            id: 'number',
            start: 'number',
            summary: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryFlashMinutesSummaryResponseBodyFlashMinutesSummarySummary = QueryFlashMinutesSummaryResponseBodyFlashMinutesSummarySummary;
class QueryFlashMinutesSummaryResponseBodyFlashMinutesSummary extends $tea.Model {
    static names() {
        return {
            status: 'status',
            summary: 'summary',
        };
    }
    static types() {
        return {
            status: 'number',
            summary: { 'type': 'array', 'itemType': QueryFlashMinutesSummaryResponseBodyFlashMinutesSummarySummary },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryFlashMinutesSummaryResponseBodyFlashMinutesSummary = QueryFlashMinutesSummaryResponseBodyFlashMinutesSummary;
class QueryMinutesAudioResponseBodyAudioList extends $tea.Model {
    static names() {
        return {
            duration: 'duration',
            endTime: 'endTime',
            fileSize: 'fileSize',
            playUrl: 'playUrl',
            recordId: 'recordId',
            startTime: 'startTime',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            duration: 'number',
            endTime: 'number',
            fileSize: 'number',
            playUrl: 'string',
            recordId: 'string',
            startTime: 'number',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesAudioResponseBodyAudioList = QueryMinutesAudioResponseBodyAudioList;
class QueryMinutesSummaryResponseBodySummaryActions extends $tea.Model {
    static names() {
        return {
            end: 'end',
            id: 'id',
            sentenceId: 'sentenceId',
            start: 'start',
            text: 'text',
        };
    }
    static types() {
        return {
            end: 'number',
            id: 'number',
            sentenceId: 'number',
            start: 'number',
            text: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesSummaryResponseBodySummaryActions = QueryMinutesSummaryResponseBodySummaryActions;
class QueryMinutesSummaryResponseBodySummaryAutoChapters extends $tea.Model {
    static names() {
        return {
            end: 'end',
            headline: 'headline',
            id: 'id',
            start: 'start',
            summary: 'summary',
        };
    }
    static types() {
        return {
            end: 'number',
            headline: 'string',
            id: 'number',
            start: 'number',
            summary: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesSummaryResponseBodySummaryAutoChapters = QueryMinutesSummaryResponseBodySummaryAutoChapters;
class QueryMinutesSummaryResponseBodySummaryConversationalSummary extends $tea.Model {
    static names() {
        return {
            speakerId: 'speakerId',
            speakerName: 'speakerName',
            summary: 'summary',
        };
    }
    static types() {
        return {
            speakerId: 'string',
            speakerName: 'string',
            summary: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesSummaryResponseBodySummaryConversationalSummary = QueryMinutesSummaryResponseBodySummaryConversationalSummary;
class QueryMinutesSummaryResponseBodySummaryKeySentences extends $tea.Model {
    static names() {
        return {
            end: 'end',
            id: 'id',
            sentenceId: 'sentenceId',
            start: 'start',
            text: 'text',
        };
    }
    static types() {
        return {
            end: 'number',
            id: 'number',
            sentenceId: 'number',
            start: 'number',
            text: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesSummaryResponseBodySummaryKeySentences = QueryMinutesSummaryResponseBodySummaryKeySentences;
class QueryMinutesSummaryResponseBodySummaryQuestionsAnsweringSummary extends $tea.Model {
    static names() {
        return {
            answer: 'answer',
            question: 'question',
            sentenceIdsOfAnswer: 'sentenceIdsOfAnswer',
            sentenceIdsOfQuestion: 'sentenceIdsOfQuestion',
        };
    }
    static types() {
        return {
            answer: 'string',
            question: 'string',
            sentenceIdsOfAnswer: { 'type': 'array', 'itemType': 'number' },
            sentenceIdsOfQuestion: { 'type': 'array', 'itemType': 'number' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesSummaryResponseBodySummaryQuestionsAnsweringSummary = QueryMinutesSummaryResponseBodySummaryQuestionsAnsweringSummary;
class QueryMinutesSummaryResponseBodySummary extends $tea.Model {
    static names() {
        return {
            actions: 'actions',
            autoChapters: 'autoChapters',
            conversationalSummary: 'conversationalSummary',
            keySentences: 'keySentences',
            keywords: 'keywords',
            paragraphSummary: 'paragraphSummary',
            questionsAnsweringSummary: 'questionsAnsweringSummary',
        };
    }
    static types() {
        return {
            actions: { 'type': 'array', 'itemType': QueryMinutesSummaryResponseBodySummaryActions },
            autoChapters: { 'type': 'array', 'itemType': QueryMinutesSummaryResponseBodySummaryAutoChapters },
            conversationalSummary: { 'type': 'array', 'itemType': QueryMinutesSummaryResponseBodySummaryConversationalSummary },
            keySentences: { 'type': 'array', 'itemType': QueryMinutesSummaryResponseBodySummaryKeySentences },
            keywords: { 'type': 'array', 'itemType': 'string' },
            paragraphSummary: 'string',
            questionsAnsweringSummary: { 'type': 'array', 'itemType': QueryMinutesSummaryResponseBodySummaryQuestionsAnsweringSummary },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesSummaryResponseBodySummary = QueryMinutesSummaryResponseBodySummary;
class QueryMinutesTextResponseBodyParagraphListSentenceListWordList extends $tea.Model {
    static names() {
        return {
            endTime: 'endTime',
            startTime: 'startTime',
            word: 'word',
            wordId: 'wordId',
        };
    }
    static types() {
        return {
            endTime: 'number',
            startTime: 'number',
            word: 'string',
            wordId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesTextResponseBodyParagraphListSentenceListWordList = QueryMinutesTextResponseBodyParagraphListSentenceListWordList;
class QueryMinutesTextResponseBodyParagraphListSentenceList extends $tea.Model {
    static names() {
        return {
            endTime: 'endTime',
            sentence: 'sentence',
            startTime: 'startTime',
            unionId: 'unionId',
            wordList: 'wordList',
        };
    }
    static types() {
        return {
            endTime: 'number',
            sentence: 'string',
            startTime: 'number',
            unionId: 'string',
            wordList: { 'type': 'array', 'itemType': QueryMinutesTextResponseBodyParagraphListSentenceListWordList },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesTextResponseBodyParagraphListSentenceList = QueryMinutesTextResponseBodyParagraphListSentenceList;
class QueryMinutesTextResponseBodyParagraphList extends $tea.Model {
    static names() {
        return {
            endTime: 'endTime',
            nickName: 'nickName',
            paragraph: 'paragraph',
            paragraphId: 'paragraphId',
            recordId: 'recordId',
            sentenceList: 'sentenceList',
            startTime: 'startTime',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            endTime: 'number',
            nickName: 'string',
            paragraph: 'string',
            paragraphId: 'number',
            recordId: 'number',
            sentenceList: { 'type': 'array', 'itemType': QueryMinutesTextResponseBodyParagraphListSentenceList },
            startTime: 'number',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryMinutesTextResponseBodyParagraphList = QueryMinutesTextResponseBodyParagraphList;
class QueryOrgConferenceListResponseBodyOnGoingConfList extends $tea.Model {
    static names() {
        return {
            bizType: 'bizType',
            conferenceId: 'conferenceId',
            creatorId: 'creatorId',
            creatorNick: 'creatorNick',
            endTime: 'endTime',
            roomCode: 'roomCode',
            startTime: 'startTime',
            status: 'status',
            title: 'title',
        };
    }
    static types() {
        return {
            bizType: 'string',
            conferenceId: 'string',
            creatorId: 'string',
            creatorNick: 'string',
            endTime: 'number',
            roomCode: 'string',
            startTime: 'number',
            status: 'number',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryOrgConferenceListResponseBodyOnGoingConfList = QueryOrgConferenceListResponseBodyOnGoingConfList;
class QueryRecordMinutesUrlResponseBodyRecordMinutesUrls extends $tea.Model {
    static names() {
        return {
            recordMinutesUrl: 'recordMinutesUrl',
        };
    }
    static types() {
        return {
            recordMinutesUrl: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryRecordMinutesUrlResponseBodyRecordMinutesUrls = QueryRecordMinutesUrlResponseBodyRecordMinutesUrls;
class QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings extends $tea.Model {
    static names() {
        return {
            autoOpenMode: 'autoOpenMode',
            clientId: 'clientId',
            coolAppCode: 'coolAppCode',
            extensionAppBizData: 'extensionAppBizData',
        };
    }
    static types() {
        return {
            autoOpenMode: 'string',
            clientId: 'string',
            coolAppCode: 'string',
            extensionAppBizData: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings = QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings;
class QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSetting extends $tea.Model {
    static names() {
        return {
            enableChat: 'enableChat',
            enableWebAnonymousJoin: 'enableWebAnonymousJoin',
            joinBeforeHost: 'joinBeforeHost',
            lockMediaStatusMicMute: 'lockMediaStatusMicMute',
            lockNick: 'lockNick',
            moziConfExtensionAppSettings: 'moziConfExtensionAppSettings',
            waitingRoom: 'waitingRoom',
        };
    }
    static types() {
        return {
            enableChat: 'number',
            enableWebAnonymousJoin: 'boolean',
            joinBeforeHost: 'number',
            lockMediaStatusMicMute: 'number',
            lockNick: 'number',
            moziConfExtensionAppSettings: { 'type': 'array', 'itemType': QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings },
            waitingRoom: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSetting = QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSetting;
class QueryScheduleConfSettingsResponseBodyScheduleConfSettingModel extends $tea.Model {
    static names() {
        return {
            cohostUnionIds: 'cohostUnionIds',
            confAllowedCorpId: 'confAllowedCorpId',
            hostUnionId: 'hostUnionId',
            lockRoom: 'lockRoom',
            moziConfVirtualExtraSetting: 'moziConfVirtualExtraSetting',
            muteOnJoin: 'muteOnJoin',
            screenShareForbidden: 'screenShareForbidden',
        };
    }
    static types() {
        return {
            cohostUnionIds: { 'type': 'array', 'itemType': 'string' },
            confAllowedCorpId: 'string',
            hostUnionId: 'string',
            lockRoom: 'number',
            moziConfVirtualExtraSetting: QueryScheduleConfSettingsResponseBodyScheduleConfSettingModelMoziConfVirtualExtraSetting,
            muteOnJoin: 'number',
            screenShareForbidden: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConfSettingsResponseBodyScheduleConfSettingModel = QueryScheduleConfSettingsResponseBodyScheduleConfSettingModel;
class QueryScheduleConferenceInfoResponseBodyConferenceList extends $tea.Model {
    static names() {
        return {
            conferenceId: 'conferenceId',
            endTime: 'endTime',
            roomCode: 'roomCode',
            startTime: 'startTime',
            status: 'status',
            title: 'title',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            endTime: 'number',
            roomCode: 'string',
            startTime: 'number',
            status: 'number',
            title: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.QueryScheduleConferenceInfoResponseBodyConferenceList = QueryScheduleConferenceInfoResponseBodyConferenceList;
class UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfOpenRecordSetting extends $tea.Model {
    static names() {
        return {
            isFollowHost: 'isFollowHost',
            mode: 'mode',
            recordAutoStart: 'recordAutoStart',
            recordAutoStartType: 'recordAutoStartType',
        };
    }
    static types() {
        return {
            isFollowHost: 'boolean',
            mode: 'string',
            recordAutoStart: 'number',
            recordAutoStartType: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfOpenRecordSetting = UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfOpenRecordSetting;
class UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings extends $tea.Model {
    static names() {
        return {
            autoOpenMode: 'autoOpenMode',
            coolAppCode: 'coolAppCode',
            extensionAppBizData: 'extensionAppBizData',
        };
    }
    static types() {
        return {
            autoOpenMode: 'number',
            coolAppCode: 'string',
            extensionAppBizData: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings = UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings;
class UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting extends $tea.Model {
    static names() {
        return {
            cloudRecordOwnerUnionId: 'cloudRecordOwnerUnionId',
            enableChat: 'enableChat',
            enableWebAnonymousJoin: 'enableWebAnonymousJoin',
            joinBeforeHost: 'joinBeforeHost',
            lockMediaStatusMicMute: 'lockMediaStatusMicMute',
            lockNick: 'lockNick',
            minutesOwnerUnionId: 'minutesOwnerUnionId',
            moziConfExtensionAppSettings: 'moziConfExtensionAppSettings',
            pushAllMeetingRecords: 'pushAllMeetingRecords',
            pushCloudRecordCard: 'pushCloudRecordCard',
            pushMinutesCard: 'pushMinutesCard',
            waitingRoom: 'waitingRoom',
        };
    }
    static types() {
        return {
            cloudRecordOwnerUnionId: 'string',
            enableChat: 'number',
            enableWebAnonymousJoin: 'boolean',
            joinBeforeHost: 'number',
            lockMediaStatusMicMute: 'number',
            lockNick: 'number',
            minutesOwnerUnionId: 'string',
            moziConfExtensionAppSettings: { 'type': 'array', 'itemType': UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSettingMoziConfExtensionAppSettings },
            pushAllMeetingRecords: 'boolean',
            pushCloudRecordCard: 'boolean',
            pushMinutesCard: 'boolean',
            waitingRoom: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting = UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting;
class UpdateScheduleConfSettingsRequestScheduleConfSettingModel extends $tea.Model {
    static names() {
        return {
            cohostUnionIds: 'cohostUnionIds',
            confAllowedCorpId: 'confAllowedCorpId',
            hostUnionId: 'hostUnionId',
            lockRoom: 'lockRoom',
            moziConfOpenRecordSetting: 'moziConfOpenRecordSetting',
            moziConfVirtualExtraSetting: 'moziConfVirtualExtraSetting',
            muteOnJoin: 'muteOnJoin',
            screenShareForbidden: 'screenShareForbidden',
        };
    }
    static types() {
        return {
            cohostUnionIds: { 'type': 'array', 'itemType': 'string' },
            confAllowedCorpId: 'string',
            hostUnionId: 'string',
            lockRoom: 'number',
            moziConfOpenRecordSetting: UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfOpenRecordSetting,
            moziConfVirtualExtraSetting: UpdateScheduleConfSettingsRequestScheduleConfSettingModelMoziConfVirtualExtraSetting,
            muteOnJoin: 'number',
            screenShareForbidden: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateScheduleConfSettingsRequestScheduleConfSettingModel = UpdateScheduleConfSettingsRequestScheduleConfSettingModel;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        let gatewayClient = new gateway_dingtalk_1.default();
        this._spi = gatewayClient;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    /**
     * 
     *
     * @param request - AddRecordPermissionRequest
     * @param headers - AddRecordPermissionHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns AddRecordPermissionResponse
     */
    async addRecordPermissionWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizType)) {
            body["bizType"] = request.bizType;
        }
        if (!tea_util_1.default.isUnset(request.ownerUnionId)) {
            body["ownerUnionId"] = request.ownerUnionId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddRecordPermission",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/flashMinutes/recordPermissions`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddRecordPermissionResponse({}));
    }
    /**
     * 
     *
     * @param request - AddRecordPermissionRequest
     * @returns AddRecordPermissionResponse
     */
    async addRecordPermission(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddRecordPermissionHeaders({});
        return await this.addRecordPermissionWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - CancelScheduleConferenceRequest
     * @param headers - CancelScheduleConferenceHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CancelScheduleConferenceResponse
     */
    async cancelScheduleConferenceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.creatorUnionId)) {
            body["creatorUnionId"] = request.creatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.scheduleConferenceId)) {
            body["scheduleConferenceId"] = request.scheduleConferenceId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CancelScheduleConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/scheduleConferences/cancel`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CancelScheduleConferenceResponse({}));
    }
    /**
     * 
     *
     * @param request - CancelScheduleConferenceRequest
     * @returns CancelScheduleConferenceResponse
     */
    async cancelScheduleConference(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CancelScheduleConferenceHeaders({});
        return await this.cancelScheduleConferenceWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - CloseVideoConferenceRequest
     * @param headers - CloseVideoConferenceHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CloseVideoConferenceResponse
     */
    async closeVideoConferenceWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CloseVideoConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CloseVideoConferenceResponse({}));
    }
    /**
     * 
     *
     * @param request - CloseVideoConferenceRequest
     * @returns CloseVideoConferenceResponse
     */
    async closeVideoConference(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CloseVideoConferenceHeaders({});
        return await this.closeVideoConferenceWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - CohostsRequest
     * @param headers - CohostsHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CohostsResponse
     */
    async cohostsWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.userList)) {
            body["userList"] = request.userList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "Cohosts",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/coHosts/set`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CohostsResponse({}));
    }
    /**
     * 
     *
     * @param request - CohostsRequest
     * @returns CohostsResponse
     */
    async cohosts(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CohostsHeaders({});
        return await this.cohostsWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - CreateCustomShortLinkRequest
     * @param headers - CreateCustomShortLinkHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateCustomShortLinkResponse
     */
    async createCustomShortLinkWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.coolAppCode)) {
            body["coolAppCode"] = request.coolAppCode;
        }
        if (!tea_util_1.default.isUnset(request.creatorUnionId)) {
            body["creatorUnionId"] = request.creatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.extensionAppBizData)) {
            body["extensionAppBizData"] = request.extensionAppBizData;
        }
        if (!tea_util_1.default.isUnset(request.scheduleConferenceId)) {
            body["scheduleConferenceId"] = request.scheduleConferenceId;
        }
        if (!tea_util_1.default.isUnset(request.useExtensionApp)) {
            body["useExtensionApp"] = request.useExtensionApp;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateCustomShortLink",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/customShortLinks`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateCustomShortLinkResponse({}));
    }
    /**
     * 
     *
     * @param request - CreateCustomShortLinkRequest
     * @returns CreateCustomShortLinkResponse
     */
    async createCustomShortLink(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateCustomShortLinkHeaders({});
        return await this.createCustomShortLinkWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - CreateScheduleConferenceRequest
     * @param headers - CreateScheduleConferenceHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateScheduleConferenceResponse
     */
    async createScheduleConferenceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.creatorUnionId)) {
            body["creatorUnionId"] = request.creatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            body["endTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.scheduleConfSettingModel)) {
            body["scheduleConfSettingModel"] = request.scheduleConfSettingModel;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            body["startTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateScheduleConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/scheduleConferences`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateScheduleConferenceResponse({}));
    }
    /**
     * 
     *
     * @param request - CreateScheduleConferenceRequest
     * @returns CreateScheduleConferenceResponse
     */
    async createScheduleConference(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateScheduleConferenceHeaders({});
        return await this.createScheduleConferenceWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - CreateVideoConferenceRequest
     * @param headers - CreateVideoConferenceHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateVideoConferenceResponse
     */
    async createVideoConferenceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.confTitle)) {
            body["confTitle"] = request.confTitle;
        }
        if (!tea_util_1.default.isUnset(request.inviteCaller)) {
            body["inviteCaller"] = request.inviteCaller;
        }
        if (!tea_util_1.default.isUnset(request.inviteUserIds)) {
            body["inviteUserIds"] = request.inviteUserIds;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateVideoConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateVideoConferenceResponse({}));
    }
    /**
     * 
     *
     * @param request - CreateVideoConferenceRequest
     * @returns CreateVideoConferenceResponse
     */
    async createVideoConference(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateVideoConferenceHeaders({});
        return await this.createVideoConferenceWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - FocusRequest
     * @param headers - FocusHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns FocusResponse
     */
    async focusWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "Focus",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/focus`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new FocusResponse({}));
    }
    /**
     * 
     *
     * @param request - FocusRequest
     * @returns FocusResponse
     */
    async focus(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new FocusHeaders({});
        return await this.focusWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - GenerateFlashMinutesDocumentUrlRequest
     * @param headers - GenerateFlashMinutesDocumentUrlHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GenerateFlashMinutesDocumentUrlResponse
     */
    async generateFlashMinutesDocumentUrlWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizType)) {
            query["bizType"] = request.bizType;
        }
        if (!tea_util_1.default.isUnset(request.expireTime)) {
            query["expireTime"] = request.expireTime;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GenerateFlashMinutesDocumentUrl",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/flashMinutes/document/generate`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GenerateFlashMinutesDocumentUrlResponse({}));
    }
    /**
     * 
     *
     * @param request - GenerateFlashMinutesDocumentUrlRequest
     * @returns GenerateFlashMinutesDocumentUrlResponse
     */
    async generateFlashMinutesDocumentUrl(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GenerateFlashMinutesDocumentUrlHeaders({});
        return await this.generateFlashMinutesDocumentUrlWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * conferenceId
     *
     * @param request - GetConfDataByConferenceIdRequest
     * @param headers - GetConfDataByConferenceIdHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetConfDataByConferenceIdResponse
     */
    async getConfDataByConferenceIdWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.realData)) {
            query["realData"] = request.realData;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetConfDataByConferenceId",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/infos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetConfDataByConferenceIdResponse({}));
    }
    /**
     * conferenceId
     *
     * @param request - GetConfDataByConferenceIdRequest
     * @returns GetConfDataByConferenceIdResponse
     */
    async getConfDataByConferenceId(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetConfDataByConferenceIdHeaders({});
        return await this.getConfDataByConferenceIdWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * conferenceId
     *
     * @param request - GetConfDetailDataRequest
     * @param headers - GetConfDetailDataHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetConfDetailDataResponse
     */
    async getConfDetailDataWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.nick)) {
            query["nick"] = request.nick;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetConfDetailData",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/details`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetConfDetailDataResponse({}));
    }
    /**
     * conferenceId
     *
     * @param request - GetConfDetailDataRequest
     * @returns GetConfDetailDataResponse
     */
    async getConfDetailData(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetConfDetailDataHeaders({});
        return await this.getConfDetailDataWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - GetHistoryConfDataListRequest
     * @param headers - GetHistoryConfDataListHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetHistoryConfDataListResponse
     */
    async getHistoryConfDataListWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.creatorNike)) {
            query["creatorNike"] = request.creatorNike;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["endTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.freeType)) {
            query["freeType"] = request.freeType;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.realData)) {
            query["realData"] = request.realData;
        }
        if (!tea_util_1.default.isUnset(request.scene)) {
            query["scene"] = request.scene;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["startTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            query["title"] = request.title;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetHistoryConfDataList",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/histories/dataLists`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetHistoryConfDataListResponse({}));
    }
    /**
     * 
     *
     * @param request - GetHistoryConfDataListRequest
     * @returns GetHistoryConfDataListResponse
     */
    async getHistoryConfDataList(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetHistoryConfDataListHeaders({});
        return await this.getHistoryConfDataListWithOptions(request, headers, runtime);
    }
    /**
     * conferenceIdunionId
     *
     * @param request - GetUserLastMetricRequest
     * @param headers - GetUserLastMetricHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetUserLastMetricResponse
     */
    async getUserLastMetricWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.unionIdList)) {
            body["unionIdList"] = request.unionIdList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetUserLastMetric",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/lastMetricDatas/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetUserLastMetricResponse({}));
    }
    /**
     * conferenceIdunionId
     *
     * @param request - GetUserLastMetricRequest
     * @returns GetUserLastMetricResponse
     */
    async getUserLastMetric(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetUserLastMetricHeaders({});
        return await this.getUserLastMetricWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * conferenceIdunionId
     *
     * @param request - GetUserMetricDataRequest
     * @param headers - GetUserMetricDataHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetUserMetricDataResponse
     */
    async getUserMetricDataWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.beginTime)) {
            query["beginTime"] = request.beginTime;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["endTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetUserMetricData",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/metricDatas`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetUserMetricDataResponse({}));
    }
    /**
     * conferenceIdunionId
     *
     * @param request - GetUserMetricDataRequest
     * @returns GetUserMetricDataResponse
     */
    async getUserMetricData(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetUserMetricDataHeaders({});
        return await this.getUserMetricDataWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - InviteUsersRequest
     * @param headers - InviteUsersHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns InviteUsersResponse
     */
    async inviteUsersWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.inviteeList)) {
            body["inviteeList"] = request.inviteeList;
        }
        if (!tea_util_1.default.isUnset(request.phoneInviteeList)) {
            body["phoneInviteeList"] = request.phoneInviteeList;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "InviteUsers",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/users/invite`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new InviteUsersResponse({}));
    }
    /**
     * 
     *
     * @param request - InviteUsersRequest
     * @returns InviteUsersResponse
     */
    async inviteUsers(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new InviteUsersHeaders({});
        return await this.inviteUsersWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - KickMembersRequest
     * @param headers - KickMembersHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns KickMembersResponse
     */
    async kickMembersWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.forbiddenRejoin)) {
            body["forbiddenRejoin"] = request.forbiddenRejoin;
        }
        if (!tea_util_1.default.isUnset(request.userList)) {
            body["userList"] = request.userList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "KickMembers",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/members/kick`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new KickMembersResponse({}));
    }
    /**
     * 
     *
     * @param request - KickMembersRequest
     * @returns KickMembersResponse
     */
    async kickMembers(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new KickMembersHeaders({});
        return await this.kickMembersWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - LockConferenceRequest
     * @param headers - LockConferenceHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns LockConferenceResponse
     */
    async lockConferenceWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "LockConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/lock`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new LockConferenceResponse({}));
    }
    /**
     * 
     *
     * @param request - LockConferenceRequest
     * @returns LockConferenceResponse
     */
    async lockConference(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new LockConferenceHeaders({});
        return await this.lockConferenceWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - MuteAllRequest
     * @param headers - MuteAllHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns MuteAllResponse
     */
    async muteAllWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.forceMute)) {
            body["forceMute"] = request.forceMute;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "MuteAll",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/allMembers/mute`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new MuteAllResponse({}));
    }
    /**
     * 
     *
     * @param request - MuteAllRequest
     * @returns MuteAllResponse
     */
    async muteAll(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MuteAllHeaders({});
        return await this.muteAllWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - MuteMembersRequest
     * @param headers - MuteMembersHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns MuteMembersResponse
     */
    async muteMembersWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.userList)) {
            body["userList"] = request.userList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "MuteMembers",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/members/mute`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new MuteMembersResponse({}));
    }
    /**
     * 
     *
     * @param request - MuteMembersRequest
     * @returns MuteMembersResponse
     */
    async muteMembers(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MuteMembersHeaders({});
        return await this.muteMembersWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryCloudRecordTextRequest
     * @param headers - QueryCloudRecordTextHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryCloudRecordTextResponse
     */
    async queryCloudRecordTextWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.direction)) {
            query["direction"] = request.direction;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["startTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryCloudRecordText",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/getTexts`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryCloudRecordTextResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryCloudRecordTextRequest
     * @returns QueryCloudRecordTextResponse
     */
    async queryCloudRecordText(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCloudRecordTextHeaders({});
        return await this.queryCloudRecordTextWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryCloudRecordVideoRequest
     * @param headers - QueryCloudRecordVideoHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryCloudRecordVideoResponse
     */
    async queryCloudRecordVideoWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryCloudRecordVideo",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/getVideos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryCloudRecordVideoResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryCloudRecordVideoRequest
     * @returns QueryCloudRecordVideoResponse
     */
    async queryCloudRecordVideo(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCloudRecordVideoHeaders({});
        return await this.queryCloudRecordVideoWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryCloudRecordVideoPlayInfoRequest
     * @param headers - QueryCloudRecordVideoPlayInfoHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryCloudRecordVideoPlayInfoResponse
     */
    async queryCloudRecordVideoPlayInfoWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.mediaId)) {
            query["mediaId"] = request.mediaId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["regionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryCloudRecordVideoPlayInfo",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/videos/getPlayInfos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryCloudRecordVideoPlayInfoResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryCloudRecordVideoPlayInfoRequest
     * @returns QueryCloudRecordVideoPlayInfoResponse
     */
    async queryCloudRecordVideoPlayInfo(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCloudRecordVideoPlayInfoHeaders({});
        return await this.queryCloudRecordVideoPlayInfoWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param headers - QueryConferenceInfoHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryConferenceInfoResponse
     */
    async queryConferenceInfoWithOptions(conferenceId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "QueryConferenceInfo",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryConferenceInfoResponse({}));
    }
    /**
     * 
     * @returns QueryConferenceInfoResponse
     */
    async queryConferenceInfo(conferenceId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryConferenceInfoHeaders({});
        return await this.queryConferenceInfoWithOptions(conferenceId, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryConferenceInfoBatchRequest
     * @param headers - QueryConferenceInfoBatchHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryConferenceInfoBatchResponse
     */
    async queryConferenceInfoBatchWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.conferenceIdList)) {
            body["conferenceIdList"] = request.conferenceIdList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryConferenceInfoBatch",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryConferenceInfoBatchResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryConferenceInfoBatchRequest
     * @returns QueryConferenceInfoBatchResponse
     */
    async queryConferenceInfoBatch(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryConferenceInfoBatchHeaders({});
        return await this.queryConferenceInfoBatchWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryConferenceInfoByRoomCodeRequest
     * @param headers - QueryConferenceInfoByRoomCodeHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryConferenceInfoByRoomCodeResponse
     */
    async queryConferenceInfoByRoomCodeWithOptions(roomCode, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryConferenceInfoByRoomCode",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/roomCodes/${roomCode}/infos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryConferenceInfoByRoomCodeResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryConferenceInfoByRoomCodeRequest
     * @returns QueryConferenceInfoByRoomCodeResponse
     */
    async queryConferenceInfoByRoomCode(roomCode, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryConferenceInfoByRoomCodeHeaders({});
        return await this.queryConferenceInfoByRoomCodeWithOptions(roomCode, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryConferenceMembersRequest
     * @param headers - QueryConferenceMembersHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryConferenceMembersResponse
     */
    async queryConferenceMembersWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryConferenceMembers",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/members`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryConferenceMembersResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryConferenceMembersRequest
     * @returns QueryConferenceMembersResponse
     */
    async queryConferenceMembers(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryConferenceMembersHeaders({});
        return await this.queryConferenceMembersWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryFlashMinutesSummaryRequest
     * @param headers - QueryFlashMinutesSummaryHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryFlashMinutesSummaryResponse
     */
    async queryFlashMinutesSummaryWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizType)) {
            query["bizType"] = request.bizType;
        }
        if (!tea_util_1.default.isUnset(request.recorderUnionId)) {
            query["recorderUnionId"] = request.recorderUnionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryFlashMinutesSummary",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/flashMinutes/summaries`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryFlashMinutesSummaryResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryFlashMinutesSummaryRequest
     * @returns QueryFlashMinutesSummaryResponse
     */
    async queryFlashMinutesSummary(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryFlashMinutesSummaryHeaders({});
        return await this.queryFlashMinutesSummaryWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryMinutesAudioRequest
     * @param headers - QueryMinutesAudioHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryMinutesAudioResponse
     */
    async queryMinutesAudioWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryMinutesAudio",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/minutes/audioInfos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryMinutesAudioResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryMinutesAudioRequest
     * @returns QueryMinutesAudioResponse
     */
    async queryMinutesAudio(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryMinutesAudioHeaders({});
        return await this.queryMinutesAudioWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryMinutesSummaryRequest
     * @param headers - QueryMinutesSummaryHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryMinutesSummaryResponse
     */
    async queryMinutesSummaryWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.summaryTypeList)) {
            body["summaryTypeList"] = request.summaryTypeList;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryMinutesSummary",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/minutes/summaries/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryMinutesSummaryResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryMinutesSummaryRequest
     * @returns QueryMinutesSummaryResponse
     */
    async queryMinutesSummary(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryMinutesSummaryHeaders({});
        return await this.queryMinutesSummaryWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryMinutesTextRequest
     * @param headers - QueryMinutesTextHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryMinutesTextResponse
     */
    async queryMinutesTextWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.direction)) {
            query["direction"] = request.direction;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryMinutesText",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/minutes/textInfos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryMinutesTextResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryMinutesTextRequest
     * @returns QueryMinutesTextResponse
     */
    async queryMinutesText(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryMinutesTextHeaders({});
        return await this.queryMinutesTextWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryOrgConferenceListRequest
     * @param headers - QueryOrgConferenceListHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryOrgConferenceListResponse
     */
    async queryOrgConferenceListWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryOrgConferenceList",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/orgConferences`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryOrgConferenceListResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryOrgConferenceListRequest
     * @returns QueryOrgConferenceListResponse
     */
    async queryOrgConferenceList(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryOrgConferenceListHeaders({});
        return await this.queryOrgConferenceListWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryRecordMinutesUrlRequest
     * @param headers - QueryRecordMinutesUrlHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryRecordMinutesUrlResponse
     */
    async queryRecordMinutesUrlWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizType)) {
            query["bizType"] = request.bizType;
        }
        if (!tea_util_1.default.isUnset(request.recorderUnionId)) {
            query["recorderUnionId"] = request.recorderUnionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryRecordMinutesUrl",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/flashMinutes/recordUrls`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryRecordMinutesUrlResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryRecordMinutesUrlRequest
     * @returns QueryRecordMinutesUrlResponse
     */
    async queryRecordMinutesUrl(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryRecordMinutesUrlHeaders({});
        return await this.queryRecordMinutesUrlWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryScheduleConfSettingsRequest
     * @param headers - QueryScheduleConfSettingsHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryScheduleConfSettingsResponse
     */
    async queryScheduleConfSettingsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.scheduleConferenceId)) {
            query["scheduleConferenceId"] = request.scheduleConferenceId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryScheduleConfSettings",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/scheduleConferences/settings`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryScheduleConfSettingsResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryScheduleConfSettingsRequest
     * @returns QueryScheduleConfSettingsResponse
     */
    async queryScheduleConfSettings(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryScheduleConfSettingsHeaders({});
        return await this.queryScheduleConfSettingsWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryScheduleConferenceRequest
     * @param headers - QueryScheduleConferenceHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryScheduleConferenceResponse
     */
    async queryScheduleConferenceWithOptions(scheduleConferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.requestUnionId)) {
            query["requestUnionId"] = request.requestUnionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryScheduleConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/scheduleConferences/${scheduleConferenceId}/infos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryScheduleConferenceResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryScheduleConferenceRequest
     * @returns QueryScheduleConferenceResponse
     */
    async queryScheduleConference(scheduleConferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryScheduleConferenceHeaders({});
        return await this.queryScheduleConferenceWithOptions(scheduleConferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryScheduleConferenceInfoRequest
     * @param headers - QueryScheduleConferenceInfoHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryScheduleConferenceInfoResponse
     */
    async queryScheduleConferenceInfoWithOptions(scheduleConferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryScheduleConferenceInfo",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/scheduleConferences/${scheduleConferenceId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryScheduleConferenceInfoResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryScheduleConferenceInfoRequest
     * @returns QueryScheduleConferenceInfoResponse
     */
    async queryScheduleConferenceInfo(scheduleConferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryScheduleConferenceInfoHeaders({});
        return await this.queryScheduleConferenceInfoWithOptions(scheduleConferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - QueryUserOnGoingConferenceRequest
     * @param headers - QueryUserOnGoingConferenceHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns QueryUserOnGoingConferenceResponse
     */
    async queryUserOnGoingConferenceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryUserOnGoingConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/users/lists`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryUserOnGoingConferenceResponse({}));
    }
    /**
     * 
     *
     * @param request - QueryUserOnGoingConferenceRequest
     * @returns QueryUserOnGoingConferenceResponse
     */
    async queryUserOnGoingConference(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryUserOnGoingConferenceHeaders({});
        return await this.queryUserOnGoingConferenceWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - StartCloudRecordRequest
     * @param headers - StartCloudRecordHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns StartCloudRecordResponse
     */
    async startCloudRecordWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.mode)) {
            body["mode"] = request.mode;
        }
        if (!tea_util_1.default.isUnset(request.smallWindowPosition)) {
            body["smallWindowPosition"] = request.smallWindowPosition;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "StartCloudRecord",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/start`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new StartCloudRecordResponse({}));
    }
    /**
     * 
     *
     * @param request - StartCloudRecordRequest
     * @returns StartCloudRecordResponse
     */
    async startCloudRecord(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StartCloudRecordHeaders({});
        return await this.startCloudRecordWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - StartMinutesRequest
     * @param headers - StartMinutesHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns StartMinutesResponse
     */
    async startMinutesWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.ownerUnionId)) {
            body["ownerUnionId"] = request.ownerUnionId;
        }
        if (!tea_util_1.default.isUnset(request.recordAudio)) {
            body["recordAudio"] = request.recordAudio;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "StartMinutes",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/minutes/start`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new StartMinutesResponse({}));
    }
    /**
     * 
     *
     * @param request - StartMinutesRequest
     * @returns StartMinutesResponse
     */
    async startMinutes(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StartMinutesHeaders({});
        return await this.startMinutesWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - StartStreamOutRequest
     * @param headers - StartStreamOutHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns StartStreamOutResponse
     */
    async startStreamOutWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.mode)) {
            body["mode"] = request.mode;
        }
        if (!tea_util_1.default.isUnset(request.needHostJoin)) {
            body["needHostJoin"] = request.needHostJoin;
        }
        if (!tea_util_1.default.isUnset(request.smallWindowPosition)) {
            body["smallWindowPosition"] = request.smallWindowPosition;
        }
        if (!tea_util_1.default.isUnset(request.streamName)) {
            body["streamName"] = request.streamName;
        }
        if (!tea_util_1.default.isUnset(request.streamUrlList)) {
            body["streamUrlList"] = request.streamUrlList;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "StartStreamOut",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/streamOuts/start`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new StartStreamOutResponse({}));
    }
    /**
     * 
     *
     * @param request - StartStreamOutRequest
     * @returns StartStreamOutResponse
     */
    async startStreamOut(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StartStreamOutHeaders({});
        return await this.startStreamOutWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - StopCloudRecordRequest
     * @param headers - StopCloudRecordHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns StopCloudRecordResponse
     */
    async stopCloudRecordWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "StopCloudRecord",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/stop`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new StopCloudRecordResponse({}));
    }
    /**
     * 
     *
     * @param request - StopCloudRecordRequest
     * @returns StopCloudRecordResponse
     */
    async stopCloudRecord(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StopCloudRecordHeaders({});
        return await this.stopCloudRecordWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - StopMinutesRequest
     * @param headers - StopMinutesHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns StopMinutesResponse
     */
    async stopMinutesWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "StopMinutes",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/minutes/pause`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new StopMinutesResponse({}));
    }
    /**
     * 
     *
     * @param request - StopMinutesRequest
     * @returns StopMinutesResponse
     */
    async stopMinutes(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StopMinutesHeaders({});
        return await this.stopMinutesWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - StopStreamOutRequest
     * @param headers - StopStreamOutHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns StopStreamOutResponse
     */
    async stopStreamOutWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.stopAllStream)) {
            body["stopAllStream"] = request.stopAllStream;
        }
        if (!tea_util_1.default.isUnset(request.streamId)) {
            body["streamId"] = request.streamId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "StopStreamOut",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/streamOuts/stop`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new StopStreamOutResponse({}));
    }
    /**
     * 
     *
     * @param request - StopStreamOutRequest
     * @returns StopStreamOutResponse
     */
    async stopStreamOut(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StopStreamOutHeaders({});
        return await this.stopStreamOutWithOptions(conferenceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - UpdateScheduleConfSettingsRequest
     * @param headers - UpdateScheduleConfSettingsHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateScheduleConfSettingsResponse
     */
    async updateScheduleConfSettingsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.creatorUnionId)) {
            body["creatorUnionId"] = request.creatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.scheduleConfSettingModel)) {
            body["scheduleConfSettingModel"] = request.scheduleConfSettingModel;
        }
        if (!tea_util_1.default.isUnset(request.scheduleConferenceId)) {
            body["scheduleConferenceId"] = request.scheduleConferenceId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateScheduleConfSettings",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/scheduleConferences/settings`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateScheduleConfSettingsResponse({}));
    }
    /**
     * 
     *
     * @param request - UpdateScheduleConfSettingsRequest
     * @returns UpdateScheduleConfSettingsResponse
     */
    async updateScheduleConfSettings(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateScheduleConfSettingsHeaders({});
        return await this.updateScheduleConfSettingsWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - UpdateScheduleConferenceRequest
     * @param headers - UpdateScheduleConferenceHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateScheduleConferenceResponse
     */
    async updateScheduleConferenceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.creatorUnionId)) {
            body["creatorUnionId"] = request.creatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            body["endTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.scheduleConferenceId)) {
            body["scheduleConferenceId"] = request.scheduleConferenceId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            body["startTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateScheduleConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/scheduleConferences`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateScheduleConferenceResponse({}));
    }
    /**
     * 
     *
     * @param request - UpdateScheduleConferenceRequest
     * @returns UpdateScheduleConferenceResponse
     */
    async updateScheduleConference(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateScheduleConferenceHeaders({});
        return await this.updateScheduleConferenceWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param headers - UpdateVideoConferenceExtInfoHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateVideoConferenceExtInfoResponse
     */
    async updateVideoConferenceExtInfoWithOptions(conferenceId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "UpdateVideoConferenceExtInfo",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/extInfo`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateVideoConferenceExtInfoResponse({}));
    }
    /**
     * 
     * @returns UpdateVideoConferenceExtInfoResponse
     */
    async updateVideoConferenceExtInfo(conferenceId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateVideoConferenceExtInfoHeaders({});
        return await this.updateVideoConferenceExtInfoWithOptions(conferenceId, headers, runtime);
    }
    /**
     * 
     *
     * @param request - UpdateVideoConferenceSettingRequest
     * @param headers - UpdateVideoConferenceSettingHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateVideoConferenceSettingResponse
     */
    async updateVideoConferenceSettingWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.allowUnmuteSelf)) {
            body["allowUnmuteSelf"] = request.allowUnmuteSelf;
        }
        if (!tea_util_1.default.isUnset(request.autoTransferHost)) {
            body["autoTransferHost"] = request.autoTransferHost;
        }
        if (!tea_util_1.default.isUnset(request.forbiddenShareScreen)) {
            body["forbiddenShareScreen"] = request.forbiddenShareScreen;
        }
        if (!tea_util_1.default.isUnset(request.lockConference)) {
            body["lockConference"] = request.lockConference;
        }
        if (!tea_util_1.default.isUnset(request.muteAll)) {
            body["muteAll"] = request.muteAll;
        }
        if (!tea_util_1.default.isUnset(request.onlyInternalEmployeesJoin)) {
            body["onlyInternalEmployeesJoin"] = request.onlyInternalEmployeesJoin;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateVideoConferenceSetting",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateVideoConferenceSettingResponse({}));
    }
    /**
     * 
     *
     * @param request - UpdateVideoConferenceSettingRequest
     * @returns UpdateVideoConferenceSettingResponse
     */
    async updateVideoConferenceSetting(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateVideoConferenceSettingHeaders({});
        return await this.updateVideoConferenceSettingWithOptions(conferenceId, request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map