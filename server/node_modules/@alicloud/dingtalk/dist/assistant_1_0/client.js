"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetKnowledgeListResponse = exports.GetKnowledgeListResponseBody = exports.GetKnowledgeListRequest = exports.GetKnowledgeListHeaders = exports.GetDomainWordsResponse = exports.GetDomainWordsResponseBody = exports.GetDomainWordsRequest = exports.GetDomainWordsHeaders = exports.GetAskDetailResponse = exports.GetAskDetailResponseBody = exports.GetAskDetailRequest = exports.GetAskDetailHeaders = exports.DeleteKnowledgeResponse = exports.DeleteKnowledgeResponseBody = exports.DeleteKnowledgeRequest = exports.DeleteKnowledgeHeaders = exports.DeleteDomainWordsResponse = exports.DeleteDomainWordsResponseBody = exports.DeleteDomainWordsRequest = exports.DeleteDomainWordsHeaders = exports.DeleteAssistantThreadResponse = exports.DeleteAssistantThreadResponseBody = exports.DeleteAssistantThreadHeaders = exports.DeleteAssistantMessageResponse = exports.DeleteAssistantMessageResponseBody = exports.DeleteAssistantMessageHeaders = exports.DeleteAssistantResponse = exports.DeleteAssistantResponseBody = exports.DeleteAssistantRequest = exports.DeleteAssistantHeaders = exports.CreateAssistantThreadResponse = exports.CreateAssistantThreadResponseBody = exports.CreateAssistantThreadRequest = exports.CreateAssistantThreadHeaders = exports.CreateAssistantRunResponse = exports.CreateAssistantRunResponseBody = exports.CreateAssistantRunRequest = exports.CreateAssistantRunHeaders = exports.CreateAssistantMessageResponse = exports.CreateAssistantMessageResponseBody = exports.CreateAssistantMessageRequest = exports.CreateAssistantMessageHeaders = exports.CreateAssistantResponse = exports.CreateAssistantResponseBody = exports.CreateAssistantRequest = exports.CreateAssistantHeaders = exports.AddDomainWordsResponse = exports.AddDomainWordsResponseBody = exports.AddDomainWordsRequest = exports.AddDomainWordsHeaders = void 0;
exports.RetrieveAssistantScopeResponse = exports.RetrieveAssistantScopeResponseBody = exports.RetrieveAssistantScopeRequest = exports.RetrieveAssistantScopeHeaders = exports.RetrieveAssistantRunResponse = exports.RetrieveAssistantRunResponseBody = exports.RetrieveAssistantRunHeaders = exports.RetrieveAssistantMessageResponse = exports.RetrieveAssistantMessageResponseBody = exports.RetrieveAssistantMessageHeaders = exports.RetrieveAssistantBasicInfoResponse = exports.RetrieveAssistantBasicInfoResponseBody = exports.RetrieveAssistantBasicInfoRequest = exports.RetrieveAssistantBasicInfoHeaders = exports.RemoveAssistantResponse = exports.RemoveAssistantResponseBody = exports.RemoveAssistantRequest = exports.RemoveAssistantHeaders = exports.RelearnKnowledgeResponse = exports.RelearnKnowledgeResponseBody = exports.RelearnKnowledgeRequest = exports.RelearnKnowledgeHeaders = exports.LogListResponse = exports.LogListResponseBody = exports.LogListRequest = exports.LogListHeaders = exports.ListVisibleAssistantResponse = exports.ListVisibleAssistantResponseBody = exports.ListVisibleAssistantRequest = exports.ListVisibleAssistantHeaders = exports.ListAssistantRunResponse = exports.ListAssistantRunResponseBody = exports.ListAssistantRunRequest = exports.ListAssistantRunHeaders = exports.ListAssistantMessageResponse = exports.ListAssistantMessageResponseBody = exports.ListAssistantMessageRequest = exports.ListAssistantMessageHeaders = exports.ListAssistantResponse = exports.ListAssistantResponseBody = exports.ListAssistantRequest = exports.ListAssistantHeaders = exports.LearnKnowledgeResponse = exports.LearnKnowledgeResponseBody = exports.LearnKnowledgeRequest = exports.LearnKnowledgeHeaders = exports.InstallAssistantResponse = exports.InstallAssistantResponseBody = exports.InstallAssistantRequest = exports.InstallAssistantHeaders = void 0;
exports.UpdateAssistantScopeRequestScopes = exports.RetrieveAssistantScopeResponseBodyResult = exports.RetrieveAssistantScopeResponseBodyResultScopes = exports.LogListResponseBodyResult = exports.LogListResponseBodyResultList = exports.ListVisibleAssistantResponseBodyList = exports.ListAssistantRunResponseBodyData = exports.ListAssistantMessageResponseBodyData = exports.ListAssistantResponseBodyList = exports.GetKnowledgeListResponseBodyResult = exports.GetAskDetailResponseBodyResult = exports.GetAskDetailResponseBodyResultList = exports.GetAskDetailResponseBodyResultListReferences = exports.DeleteDomainWordsRequestDomainWords = exports.AddDomainWordsRequestDomainWords = exports.UpdateAssistantScopeResponse = exports.UpdateAssistantScopeRequest = exports.UpdateAssistantScopeHeaders = exports.UpdateAssistantBasicInfoResponse = exports.UpdateAssistantBasicInfoResponseBody = exports.UpdateAssistantBasicInfoRequest = exports.UpdateAssistantBasicInfoHeaders = exports.RetrieveAssistantThreadResponse = exports.RetrieveAssistantThreadResponseBody = exports.RetrieveAssistantThreadHeaders = void 0;
// This file is auto-generated, don't edit it
/**
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AddDomainWordsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddDomainWordsHeaders = AddDomainWordsHeaders;
class AddDomainWordsRequest extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            domainWords: 'domainWords',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            domainWords: { 'type': 'array', 'itemType': AddDomainWordsRequestDomainWords },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddDomainWordsRequest = AddDomainWordsRequest;
class AddDomainWordsResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddDomainWordsResponseBody = AddDomainWordsResponseBody;
class AddDomainWordsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddDomainWordsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddDomainWordsResponse = AddDomainWordsResponse;
class CreateAssistantHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAssistantHeaders = CreateAssistantHeaders;
class CreateAssistantRequest extends $tea.Model {
    static names() {
        return {
            description: 'description',
            icon: 'icon',
            instructions: 'instructions',
            name: 'name',
            operatorUnionId: 'operatorUnionId',
            recommendPrompts: 'recommendPrompts',
            welcomeContent: 'welcomeContent',
        };
    }
    static types() {
        return {
            description: 'string',
            icon: 'string',
            instructions: 'string',
            name: 'string',
            operatorUnionId: 'string',
            recommendPrompts: { 'type': 'array', 'itemType': 'string' },
            welcomeContent: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAssistantRequest = CreateAssistantRequest;
class CreateAssistantResponseBody extends $tea.Model {
    static names() {
        return {
            actionNames: 'actionNames',
            assistantId: 'assistantId',
            assistantUnionId: 'assistantUnionId',
            createdAt: 'createdAt',
            creatorUnionId: 'creatorUnionId',
            description: 'description',
            fallbackContent: 'fallbackContent',
            icon: 'icon',
            instructions: 'instructions',
            knowledgeFileNames: 'knowledgeFileNames',
            model: 'model',
            name: 'name',
            recommendPrompts: 'recommendPrompts',
            unifiedAppId: 'unifiedAppId',
            welcomeContent: 'welcomeContent',
        };
    }
    static types() {
        return {
            actionNames: { 'type': 'array', 'itemType': 'string' },
            assistantId: 'string',
            assistantUnionId: 'string',
            createdAt: 'number',
            creatorUnionId: 'string',
            description: 'string',
            fallbackContent: 'string',
            icon: 'string',
            instructions: 'string',
            knowledgeFileNames: { 'type': 'array', 'itemType': 'string' },
            model: 'string',
            name: 'string',
            recommendPrompts: { 'type': 'array', 'itemType': 'string' },
            unifiedAppId: 'string',
            welcomeContent: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAssistantResponseBody = CreateAssistantResponseBody;
class CreateAssistantResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateAssistantResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAssistantResponse = CreateAssistantResponse;
class CreateAssistantMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAssistantMessageHeaders = CreateAssistantMessageHeaders;
class CreateAssistantMessageRequest extends $tea.Model {
    static names() {
        return {
            content: 'content',
            extension: 'extension',
            metadata: 'metadata',
            role: 'role',
        };
    }
    static types() {
        return {
            content: 'string',
            extension: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            metadata: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            role: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAssistantMessageRequest = CreateAssistantMessageRequest;
class CreateAssistantMessageResponseBody extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            content: 'content',
            createdAt: 'createdAt',
            id: 'id',
            metadata: 'metadata',
            object: 'object',
            role: 'role',
            runId: 'runId',
            threadId: 'threadId',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            content: { 'type': 'array', 'itemType': 'any' },
            createdAt: 'number',
            id: 'string',
            metadata: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            object: 'string',
            role: 'string',
            runId: 'string',
            threadId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAssistantMessageResponseBody = CreateAssistantMessageResponseBody;
class CreateAssistantMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateAssistantMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAssistantMessageResponse = CreateAssistantMessageResponse;
class CreateAssistantRunHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAssistantRunHeaders = CreateAssistantRunHeaders;
class CreateAssistantRunRequest extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            instructions: 'instructions',
            metadata: 'metadata',
            stream: 'stream',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            instructions: 'string',
            metadata: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            stream: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAssistantRunRequest = CreateAssistantRunRequest;
class CreateAssistantRunResponseBody extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            cancelledAt: 'cancelledAt',
            completedAt: 'completedAt',
            createdAt: 'createdAt',
            expiresAt: 'expiresAt',
            failedAt: 'failedAt',
            id: 'id',
            lastErrorMsg: 'lastErrorMsg',
            metadata: 'metadata',
            object: 'object',
            startedAt: 'startedAt',
            status: 'status',
            threadId: 'threadId',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            cancelledAt: 'number',
            completedAt: 'number',
            createdAt: 'number',
            expiresAt: 'number',
            failedAt: 'number',
            id: 'string',
            lastErrorMsg: 'string',
            metadata: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            object: 'string',
            startedAt: 'number',
            status: 'string',
            threadId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAssistantRunResponseBody = CreateAssistantRunResponseBody;
class CreateAssistantRunResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateAssistantRunResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAssistantRunResponse = CreateAssistantRunResponse;
class CreateAssistantThreadHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAssistantThreadHeaders = CreateAssistantThreadHeaders;
class CreateAssistantThreadRequest extends $tea.Model {
    static names() {
        return {
            metadata: 'metadata',
        };
    }
    static types() {
        return {
            metadata: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAssistantThreadRequest = CreateAssistantThreadRequest;
class CreateAssistantThreadResponseBody extends $tea.Model {
    static names() {
        return {
            createdAt: 'createdAt',
            id: 'id',
            metadata: 'metadata',
            object: 'object',
        };
    }
    static types() {
        return {
            createdAt: 'number',
            id: 'string',
            metadata: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            object: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAssistantThreadResponseBody = CreateAssistantThreadResponseBody;
class CreateAssistantThreadResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateAssistantThreadResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAssistantThreadResponse = CreateAssistantThreadResponse;
class DeleteAssistantHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteAssistantHeaders = DeleteAssistantHeaders;
class DeleteAssistantRequest extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            operatorUnionId: 'operatorUnionId',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            operatorUnionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteAssistantRequest = DeleteAssistantRequest;
class DeleteAssistantResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteAssistantResponseBody = DeleteAssistantResponseBody;
class DeleteAssistantResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteAssistantResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteAssistantResponse = DeleteAssistantResponse;
class DeleteAssistantMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteAssistantMessageHeaders = DeleteAssistantMessageHeaders;
class DeleteAssistantMessageResponseBody extends $tea.Model {
    static names() {
        return {
            deleted: 'deleted',
            id: 'id',
            object: 'object',
        };
    }
    static types() {
        return {
            deleted: 'boolean',
            id: 'string',
            object: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteAssistantMessageResponseBody = DeleteAssistantMessageResponseBody;
class DeleteAssistantMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteAssistantMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteAssistantMessageResponse = DeleteAssistantMessageResponse;
class DeleteAssistantThreadHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteAssistantThreadHeaders = DeleteAssistantThreadHeaders;
class DeleteAssistantThreadResponseBody extends $tea.Model {
    static names() {
        return {
            deleted: 'deleted',
            id: 'id',
            object: 'object',
        };
    }
    static types() {
        return {
            deleted: 'boolean',
            id: 'string',
            object: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteAssistantThreadResponseBody = DeleteAssistantThreadResponseBody;
class DeleteAssistantThreadResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteAssistantThreadResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteAssistantThreadResponse = DeleteAssistantThreadResponse;
class DeleteDomainWordsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteDomainWordsHeaders = DeleteDomainWordsHeaders;
class DeleteDomainWordsRequest extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            domainWords: 'domainWords',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            domainWords: { 'type': 'array', 'itemType': DeleteDomainWordsRequestDomainWords },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteDomainWordsRequest = DeleteDomainWordsRequest;
class DeleteDomainWordsResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteDomainWordsResponseBody = DeleteDomainWordsResponseBody;
class DeleteDomainWordsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDomainWordsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteDomainWordsResponse = DeleteDomainWordsResponse;
class DeleteKnowledgeHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteKnowledgeHeaders = DeleteKnowledgeHeaders;
class DeleteKnowledgeRequest extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            studyId: 'studyId',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            studyId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteKnowledgeRequest = DeleteKnowledgeRequest;
class DeleteKnowledgeResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteKnowledgeResponseBody = DeleteKnowledgeResponseBody;
class DeleteKnowledgeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteKnowledgeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteKnowledgeResponse = DeleteKnowledgeResponse;
class GetAskDetailHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAskDetailHeaders = GetAskDetailHeaders;
class GetAskDetailRequest extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            endTime: 'endTime',
            offset: 'offset',
            pageSize: 'pageSize',
            startTime: 'startTime',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            endTime: 'number',
            offset: 'number',
            pageSize: 'number',
            startTime: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAskDetailRequest = GetAskDetailRequest;
class GetAskDetailResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: GetAskDetailResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAskDetailResponseBody = GetAskDetailResponseBody;
class GetAskDetailResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetAskDetailResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAskDetailResponse = GetAskDetailResponse;
class GetDomainWordsHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetDomainWordsHeaders = GetDomainWordsHeaders;
class GetDomainWordsRequest extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
        };
    }
    static types() {
        return {
            assistantId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetDomainWordsRequest = GetDomainWordsRequest;
class GetDomainWordsResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': 'string' },
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetDomainWordsResponseBody = GetDomainWordsResponseBody;
class GetDomainWordsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetDomainWordsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetDomainWordsResponse = GetDomainWordsResponse;
class GetKnowledgeListHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetKnowledgeListHeaders = GetKnowledgeListHeaders;
class GetKnowledgeListRequest extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
        };
    }
    static types() {
        return {
            assistantId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetKnowledgeListRequest = GetKnowledgeListRequest;
class GetKnowledgeListResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': GetKnowledgeListResponseBodyResult },
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetKnowledgeListResponseBody = GetKnowledgeListResponseBody;
class GetKnowledgeListResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetKnowledgeListResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetKnowledgeListResponse = GetKnowledgeListResponse;
class InstallAssistantHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InstallAssistantHeaders = InstallAssistantHeaders;
class InstallAssistantRequest extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            isAllOrgMemberVisible: 'isAllOrgMemberVisible',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            isAllOrgMemberVisible: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InstallAssistantRequest = InstallAssistantRequest;
class InstallAssistantResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InstallAssistantResponseBody = InstallAssistantResponseBody;
class InstallAssistantResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: InstallAssistantResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.InstallAssistantResponse = InstallAssistantResponse;
class LearnKnowledgeHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.LearnKnowledgeHeaders = LearnKnowledgeHeaders;
class LearnKnowledgeRequest extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            docUrl: 'docUrl',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            docUrl: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.LearnKnowledgeRequest = LearnKnowledgeRequest;
class LearnKnowledgeResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.LearnKnowledgeResponseBody = LearnKnowledgeResponseBody;
class LearnKnowledgeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: LearnKnowledgeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.LearnKnowledgeResponse = LearnKnowledgeResponse;
class ListAssistantHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAssistantHeaders = ListAssistantHeaders;
class ListAssistantRequest extends $tea.Model {
    static names() {
        return {
            cursor: 'cursor',
            pageSize: 'pageSize',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            cursor: 'number',
            pageSize: 'number',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAssistantRequest = ListAssistantRequest;
class ListAssistantResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            list: 'list',
            nextCursor: 'nextCursor',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            list: { 'type': 'array', 'itemType': ListAssistantResponseBodyList },
            nextCursor: 'number',
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAssistantResponseBody = ListAssistantResponseBody;
class ListAssistantResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListAssistantResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAssistantResponse = ListAssistantResponse;
class ListAssistantMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAssistantMessageHeaders = ListAssistantMessageHeaders;
class ListAssistantMessageRequest extends $tea.Model {
    static names() {
        return {
            limit: 'limit',
            order: 'order',
            runId: 'runId',
        };
    }
    static types() {
        return {
            limit: 'number',
            order: 'string',
            runId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAssistantMessageRequest = ListAssistantMessageRequest;
class ListAssistantMessageResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            object: 'object',
        };
    }
    static types() {
        return {
            data: { 'type': 'array', 'itemType': ListAssistantMessageResponseBodyData },
            object: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAssistantMessageResponseBody = ListAssistantMessageResponseBody;
class ListAssistantMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListAssistantMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAssistantMessageResponse = ListAssistantMessageResponse;
class ListAssistantRunHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAssistantRunHeaders = ListAssistantRunHeaders;
class ListAssistantRunRequest extends $tea.Model {
    static names() {
        return {
            limit: 'limit',
            order: 'order',
        };
    }
    static types() {
        return {
            limit: 'number',
            order: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAssistantRunRequest = ListAssistantRunRequest;
class ListAssistantRunResponseBody extends $tea.Model {
    static names() {
        return {
            data: 'data',
            object: 'object',
        };
    }
    static types() {
        return {
            data: { 'type': 'array', 'itemType': ListAssistantRunResponseBodyData },
            object: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAssistantRunResponseBody = ListAssistantRunResponseBody;
class ListAssistantRunResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListAssistantRunResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAssistantRunResponse = ListAssistantRunResponse;
class ListVisibleAssistantHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListVisibleAssistantHeaders = ListVisibleAssistantHeaders;
class ListVisibleAssistantRequest extends $tea.Model {
    static names() {
        return {
            cursor: 'cursor',
            name: 'name',
            pageSize: 'pageSize',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            cursor: 'number',
            name: 'string',
            pageSize: 'number',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListVisibleAssistantRequest = ListVisibleAssistantRequest;
class ListVisibleAssistantResponseBody extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            list: 'list',
            nextCursor: 'nextCursor',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            list: { 'type': 'array', 'itemType': ListVisibleAssistantResponseBodyList },
            nextCursor: 'number',
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListVisibleAssistantResponseBody = ListVisibleAssistantResponseBody;
class ListVisibleAssistantResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListVisibleAssistantResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListVisibleAssistantResponse = ListVisibleAssistantResponse;
class LogListHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.LogListHeaders = LogListHeaders;
class LogListRequest extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            endTime: 'endTime',
            pageNumber: 'pageNumber',
            pageSize: 'pageSize',
            startTime: 'startTime',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            endTime: 'number',
            pageNumber: 'number',
            pageSize: 'number',
            startTime: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.LogListRequest = LogListRequest;
class LogListResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: LogListResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.LogListResponseBody = LogListResponseBody;
class LogListResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: LogListResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.LogListResponse = LogListResponse;
class RelearnKnowledgeHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RelearnKnowledgeHeaders = RelearnKnowledgeHeaders;
class RelearnKnowledgeRequest extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
        };
    }
    static types() {
        return {
            assistantId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RelearnKnowledgeRequest = RelearnKnowledgeRequest;
class RelearnKnowledgeResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RelearnKnowledgeResponseBody = RelearnKnowledgeResponseBody;
class RelearnKnowledgeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RelearnKnowledgeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RelearnKnowledgeResponse = RelearnKnowledgeResponse;
class RemoveAssistantHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RemoveAssistantHeaders = RemoveAssistantHeaders;
class RemoveAssistantRequest extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            operatorUnionId: 'operatorUnionId',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            operatorUnionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RemoveAssistantRequest = RemoveAssistantRequest;
class RemoveAssistantResponseBody extends $tea.Model {
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RemoveAssistantResponseBody = RemoveAssistantResponseBody;
class RemoveAssistantResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RemoveAssistantResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RemoveAssistantResponse = RemoveAssistantResponse;
class RetrieveAssistantBasicInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveAssistantBasicInfoHeaders = RetrieveAssistantBasicInfoHeaders;
class RetrieveAssistantBasicInfoRequest extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            unionId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveAssistantBasicInfoRequest = RetrieveAssistantBasicInfoRequest;
class RetrieveAssistantBasicInfoResponseBody extends $tea.Model {
    static names() {
        return {
            actionNames: 'actionNames',
            assistantId: 'assistantId',
            assistantUnionId: 'assistantUnionId',
            createdAt: 'createdAt',
            creatorUnionId: 'creatorUnionId',
            description: 'description',
            fallbackContent: 'fallbackContent',
            icon: 'icon',
            instructions: 'instructions',
            knowledgeFileNames: 'knowledgeFileNames',
            model: 'model',
            name: 'name',
            recommendPrompts: 'recommendPrompts',
            unifiedAppId: 'unifiedAppId',
            welcomeContent: 'welcomeContent',
        };
    }
    static types() {
        return {
            actionNames: { 'type': 'array', 'itemType': 'string' },
            assistantId: 'string',
            assistantUnionId: 'string',
            createdAt: 'number',
            creatorUnionId: 'string',
            description: 'string',
            fallbackContent: 'string',
            icon: 'string',
            instructions: 'string',
            knowledgeFileNames: { 'type': 'array', 'itemType': 'string' },
            model: 'string',
            name: 'string',
            recommendPrompts: { 'type': 'array', 'itemType': 'string' },
            unifiedAppId: 'string',
            welcomeContent: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveAssistantBasicInfoResponseBody = RetrieveAssistantBasicInfoResponseBody;
class RetrieveAssistantBasicInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RetrieveAssistantBasicInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveAssistantBasicInfoResponse = RetrieveAssistantBasicInfoResponse;
class RetrieveAssistantMessageHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveAssistantMessageHeaders = RetrieveAssistantMessageHeaders;
class RetrieveAssistantMessageResponseBody extends $tea.Model {
    static names() {
        return {
            assisantId: 'assisantId',
            content: 'content',
            createdAt: 'createdAt',
            id: 'id',
            metadata: 'metadata',
            object: 'object',
            role: 'role',
            runId: 'runId',
            threadId: 'threadId',
        };
    }
    static types() {
        return {
            assisantId: 'string',
            content: { 'type': 'array', 'itemType': 'any' },
            createdAt: 'number',
            id: 'string',
            metadata: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            object: 'string',
            role: 'string',
            runId: 'string',
            threadId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveAssistantMessageResponseBody = RetrieveAssistantMessageResponseBody;
class RetrieveAssistantMessageResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RetrieveAssistantMessageResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveAssistantMessageResponse = RetrieveAssistantMessageResponse;
class RetrieveAssistantRunHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveAssistantRunHeaders = RetrieveAssistantRunHeaders;
class RetrieveAssistantRunResponseBody extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            cancelledAt: 'cancelledAt',
            completedAt: 'completedAt',
            createdAt: 'createdAt',
            expiresAt: 'expiresAt',
            failedAt: 'failedAt',
            id: 'id',
            lastErrorMsg: 'lastErrorMsg',
            metadata: 'metadata',
            object: 'object',
            startedAt: 'startedAt',
            status: 'status',
            threadId: 'threadId',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            cancelledAt: 'number',
            completedAt: 'number',
            createdAt: 'number',
            expiresAt: 'number',
            failedAt: 'number',
            id: 'string',
            lastErrorMsg: 'string',
            metadata: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            object: 'string',
            startedAt: 'number',
            status: 'string',
            threadId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveAssistantRunResponseBody = RetrieveAssistantRunResponseBody;
class RetrieveAssistantRunResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RetrieveAssistantRunResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveAssistantRunResponse = RetrieveAssistantRunResponse;
class RetrieveAssistantScopeHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveAssistantScopeHeaders = RetrieveAssistantScopeHeaders;
class RetrieveAssistantScopeRequest extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
        };
    }
    static types() {
        return {
            assistantId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveAssistantScopeRequest = RetrieveAssistantScopeRequest;
class RetrieveAssistantScopeResponseBody extends $tea.Model {
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: RetrieveAssistantScopeResponseBodyResult,
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveAssistantScopeResponseBody = RetrieveAssistantScopeResponseBody;
class RetrieveAssistantScopeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RetrieveAssistantScopeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveAssistantScopeResponse = RetrieveAssistantScopeResponse;
class RetrieveAssistantThreadHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveAssistantThreadHeaders = RetrieveAssistantThreadHeaders;
class RetrieveAssistantThreadResponseBody extends $tea.Model {
    static names() {
        return {
            createdAt: 'createdAt',
            id: 'id',
            metadata: 'metadata',
            object: 'object',
        };
    }
    static types() {
        return {
            createdAt: 'number',
            id: 'string',
            metadata: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            object: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveAssistantThreadResponseBody = RetrieveAssistantThreadResponseBody;
class RetrieveAssistantThreadResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RetrieveAssistantThreadResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveAssistantThreadResponse = RetrieveAssistantThreadResponse;
class UpdateAssistantBasicInfoHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAssistantBasicInfoHeaders = UpdateAssistantBasicInfoHeaders;
class UpdateAssistantBasicInfoRequest extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            description: 'description',
            fallbackContent: 'fallbackContent',
            icon: 'icon',
            instructions: 'instructions',
            name: 'name',
            operatorUnionId: 'operatorUnionId',
            recommendPrompts: 'recommendPrompts',
            welcomeContent: 'welcomeContent',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            description: 'string',
            fallbackContent: 'string',
            icon: 'string',
            instructions: 'string',
            name: 'string',
            operatorUnionId: 'string',
            recommendPrompts: { 'type': 'array', 'itemType': 'string' },
            welcomeContent: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAssistantBasicInfoRequest = UpdateAssistantBasicInfoRequest;
class UpdateAssistantBasicInfoResponseBody extends $tea.Model {
    static names() {
        return {
            actionNames: 'actionNames',
            assistantId: 'assistantId',
            assistantUnionId: 'assistantUnionId',
            createdAt: 'createdAt',
            creatorUnionId: 'creatorUnionId',
            description: 'description',
            fallbackContent: 'fallbackContent',
            icon: 'icon',
            instructions: 'instructions',
            knowledgeFileNames: 'knowledgeFileNames',
            model: 'model',
            name: 'name',
            recommendPrompts: 'recommendPrompts',
            unifiedAppId: 'unifiedAppId',
            welcomeContent: 'welcomeContent',
        };
    }
    static types() {
        return {
            actionNames: { 'type': 'array', 'itemType': 'string' },
            assistantId: 'string',
            assistantUnionId: 'string',
            createdAt: 'number',
            creatorUnionId: 'string',
            description: 'string',
            fallbackContent: 'string',
            icon: 'string',
            instructions: 'string',
            knowledgeFileNames: { 'type': 'array', 'itemType': 'string' },
            model: 'string',
            name: 'string',
            recommendPrompts: { 'type': 'array', 'itemType': 'string' },
            unifiedAppId: 'string',
            welcomeContent: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAssistantBasicInfoResponseBody = UpdateAssistantBasicInfoResponseBody;
class UpdateAssistantBasicInfoResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateAssistantBasicInfoResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAssistantBasicInfoResponse = UpdateAssistantBasicInfoResponse;
class UpdateAssistantScopeHeaders extends $tea.Model {
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAssistantScopeHeaders = UpdateAssistantScopeHeaders;
class UpdateAssistantScopeRequest extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            operatorUnionId: 'operatorUnionId',
            scopes: 'scopes',
            sharing: 'sharing',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            operatorUnionId: 'string',
            scopes: UpdateAssistantScopeRequestScopes,
            sharing: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAssistantScopeRequest = UpdateAssistantScopeRequest;
class UpdateAssistantScopeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: 'any',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAssistantScopeResponse = UpdateAssistantScopeResponse;
class AddDomainWordsRequestDomainWords extends $tea.Model {
    static names() {
        return {
            description: 'description',
            domainWord: 'domainWord',
            formalWords: 'formalWords',
        };
    }
    static types() {
        return {
            description: 'string',
            domainWord: 'string',
            formalWords: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddDomainWordsRequestDomainWords = AddDomainWordsRequestDomainWords;
class DeleteDomainWordsRequestDomainWords extends $tea.Model {
    static names() {
        return {
            description: 'description',
            domainWord: 'domainWord',
            formalWords: 'formalWords',
        };
    }
    static types() {
        return {
            description: 'string',
            domainWord: 'string',
            formalWords: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteDomainWordsRequestDomainWords = DeleteDomainWordsRequestDomainWords;
class GetAskDetailResponseBodyResultListReferences extends $tea.Model {
    static names() {
        return {
            name: 'name',
            url: 'url',
        };
    }
    static types() {
        return {
            name: 'string',
            url: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAskDetailResponseBodyResultListReferences = GetAskDetailResponseBodyResultListReferences;
class GetAskDetailResponseBodyResultList extends $tea.Model {
    static names() {
        return {
            answer: 'answer',
            answerResult: 'answerResult',
            commentTags: 'commentTags',
            isMarkResolved: 'isMarkResolved',
            nick: 'nick',
            question: 'question',
            references: 'references',
            time: 'time',
        };
    }
    static types() {
        return {
            answer: 'string',
            answerResult: 'string',
            commentTags: { 'type': 'array', 'itemType': 'string' },
            isMarkResolved: 'boolean',
            nick: 'string',
            question: 'string',
            references: { 'type': 'array', 'itemType': GetAskDetailResponseBodyResultListReferences },
            time: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAskDetailResponseBodyResultList = GetAskDetailResponseBodyResultList;
class GetAskDetailResponseBodyResult extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            list: 'list',
            nextCursor: 'nextCursor',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            list: { 'type': 'array', 'itemType': GetAskDetailResponseBodyResultList },
            nextCursor: 'number',
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetAskDetailResponseBodyResult = GetAskDetailResponseBodyResult;
class GetKnowledgeListResponseBodyResult extends $tea.Model {
    static names() {
        return {
            docFormat: 'docFormat',
            docName: 'docName',
            docUrl: 'docUrl',
            status: 'status',
            studyId: 'studyId',
        };
    }
    static types() {
        return {
            docFormat: 'string',
            docName: 'string',
            docUrl: 'string',
            status: 'string',
            studyId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetKnowledgeListResponseBodyResult = GetKnowledgeListResponseBodyResult;
class ListAssistantResponseBodyList extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            createdAt: 'createdAt',
            creatorUnionId: 'creatorUnionId',
            description: 'description',
            icon: 'icon',
            name: 'name',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            createdAt: 'number',
            creatorUnionId: 'string',
            description: 'string',
            icon: 'string',
            name: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAssistantResponseBodyList = ListAssistantResponseBodyList;
class ListAssistantMessageResponseBodyData extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            content: 'content',
            createdAt: 'createdAt',
            id: 'id',
            metadata: 'metadata',
            object: 'object',
            role: 'role',
            runId: 'runId',
            threadId: 'threadId',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            content: { 'type': 'array', 'itemType': 'any' },
            createdAt: 'number',
            id: 'string',
            metadata: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            object: 'string',
            role: 'string',
            runId: 'string',
            threadId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAssistantMessageResponseBodyData = ListAssistantMessageResponseBodyData;
class ListAssistantRunResponseBodyData extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            cancelledAt: 'cancelledAt',
            completedAt: 'completedAt',
            createdAt: 'createdAt',
            expiresAt: 'expiresAt',
            failedAt: 'failedAt',
            id: 'id',
            lastErrorMsg: 'lastErrorMsg',
            metadata: 'metadata',
            object: 'object',
            startedAt: 'startedAt',
            status: 'status',
            threadId: 'threadId',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            cancelledAt: 'number',
            completedAt: 'number',
            createdAt: 'number',
            expiresAt: 'number',
            failedAt: 'number',
            id: 'string',
            lastErrorMsg: 'string',
            metadata: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            object: 'string',
            startedAt: 'number',
            status: 'string',
            threadId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListAssistantRunResponseBodyData = ListAssistantRunResponseBodyData;
class ListVisibleAssistantResponseBodyList extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            createdAt: 'createdAt',
            creatorUnionId: 'creatorUnionId',
            description: 'description',
            icon: 'icon',
            name: 'name',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            createdAt: 'number',
            creatorUnionId: 'string',
            description: 'string',
            icon: 'string',
            name: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListVisibleAssistantResponseBodyList = ListVisibleAssistantResponseBodyList;
class LogListResponseBodyResultList extends $tea.Model {
    static names() {
        return {
            actionNames: 'actionNames',
            customChannel: 'customChannel',
            input: 'input',
            name: 'name',
            output: 'output',
            result: 'result',
            scene: 'scene',
            time: 'time',
            unionId: 'unionId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            actionNames: 'string',
            customChannel: 'string',
            input: 'string',
            name: 'string',
            output: 'string',
            result: 'string',
            scene: 'string',
            time: 'number',
            unionId: 'string',
            userId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.LogListResponseBodyResultList = LogListResponseBodyResultList;
class LogListResponseBodyResult extends $tea.Model {
    static names() {
        return {
            hasMore: 'hasMore',
            list: 'list',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            list: { 'type': 'array', 'itemType': LogListResponseBodyResultList },
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.LogListResponseBodyResult = LogListResponseBodyResult;
class RetrieveAssistantScopeResponseBodyResultScopes extends $tea.Model {
    static names() {
        return {
            deptVisibleScopes: 'deptVisibleScopes',
            dynamicGroupScopes: 'dynamicGroupScopes',
            isAdmin: 'isAdmin',
            roleVisibleScopes: 'roleVisibleScopes',
            userVisibleScopes: 'userVisibleScopes',
        };
    }
    static types() {
        return {
            deptVisibleScopes: { 'type': 'array', 'itemType': 'string' },
            dynamicGroupScopes: { 'type': 'array', 'itemType': 'string' },
            isAdmin: 'boolean',
            roleVisibleScopes: { 'type': 'array', 'itemType': 'string' },
            userVisibleScopes: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveAssistantScopeResponseBodyResultScopes = RetrieveAssistantScopeResponseBodyResultScopes;
class RetrieveAssistantScopeResponseBodyResult extends $tea.Model {
    static names() {
        return {
            assistantId: 'assistantId',
            scopes: 'scopes',
            sharing: 'sharing',
        };
    }
    static types() {
        return {
            assistantId: 'string',
            scopes: RetrieveAssistantScopeResponseBodyResultScopes,
            sharing: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveAssistantScopeResponseBodyResult = RetrieveAssistantScopeResponseBodyResult;
class UpdateAssistantScopeRequestScopes extends $tea.Model {
    static names() {
        return {
            deptVisibleScopes: 'deptVisibleScopes',
            dynamicGroupScopes: 'dynamicGroupScopes',
            isAdmin: 'isAdmin',
            roleVisibleScopes: 'roleVisibleScopes',
            userVisibleScopes: 'userVisibleScopes',
        };
    }
    static types() {
        return {
            deptVisibleScopes: { 'type': 'array', 'itemType': 'string' },
            dynamicGroupScopes: { 'type': 'array', 'itemType': 'string' },
            isAdmin: 'boolean',
            roleVisibleScopes: { 'type': 'array', 'itemType': 'string' },
            userVisibleScopes: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAssistantScopeRequestScopes = UpdateAssistantScopeRequestScopes;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        let gatewayClient = new gateway_dingtalk_1.default();
        this._spi = gatewayClient;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    /**
     * 
     *
     * @param request - AddDomainWordsRequest
     * @param headers - AddDomainWordsHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns AddDomainWordsResponse
     */
    async addDomainWordsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.assistantId)) {
            body["assistantId"] = request.assistantId;
        }
        if (!tea_util_1.default.isUnset(request.domainWords)) {
            body["domainWords"] = request.domainWords;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddDomainWords",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/domainWords`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddDomainWordsResponse({}));
    }
    /**
     * 
     *
     * @param request - AddDomainWordsRequest
     * @returns AddDomainWordsResponse
     */
    async addDomainWords(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddDomainWordsHeaders({});
        return await this.addDomainWordsWithOptions(request, headers, runtime);
    }
    /**
     * AI
     *
     * @param request - CreateAssistantRequest
     * @param headers - CreateAssistantHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateAssistantResponse
     */
    async createAssistantWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.icon)) {
            body["icon"] = request.icon;
        }
        if (!tea_util_1.default.isUnset(request.instructions)) {
            body["instructions"] = request.instructions;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.operatorUnionId)) {
            body["operatorUnionId"] = request.operatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.recommendPrompts)) {
            body["recommendPrompts"] = request.recommendPrompts;
        }
        if (!tea_util_1.default.isUnset(request.welcomeContent)) {
            body["welcomeContent"] = request.welcomeContent;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateAssistant",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/basicInfo`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateAssistantResponse({}));
    }
    /**
     * AI
     *
     * @param request - CreateAssistantRequest
     * @returns CreateAssistantResponse
     */
    async createAssistant(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateAssistantHeaders({});
        return await this.createAssistantWithOptions(request, headers, runtime);
    }
    /**
     * AI
     *
     * @param request - CreateAssistantMessageRequest
     * @param headers - CreateAssistantMessageHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateAssistantMessageResponse
     */
    async createAssistantMessageWithOptions(threadId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.extension)) {
            body["extension"] = request.extension;
        }
        if (!tea_util_1.default.isUnset(request.metadata)) {
            body["metadata"] = request.metadata;
        }
        if (!tea_util_1.default.isUnset(request.role)) {
            body["role"] = request.role;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateAssistantMessage",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/threads/${threadId}/messages`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateAssistantMessageResponse({}));
    }
    /**
     * AI
     *
     * @param request - CreateAssistantMessageRequest
     * @returns CreateAssistantMessageResponse
     */
    async createAssistantMessage(threadId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateAssistantMessageHeaders({});
        return await this.createAssistantMessageWithOptions(threadId, request, headers, runtime);
    }
    /**
     * AI
     *
     * @param request - CreateAssistantRunRequest
     * @param headers - CreateAssistantRunHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateAssistantRunResponse
     */
    async createAssistantRunWithOptions(threadId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.assistantId)) {
            body["assistantId"] = request.assistantId;
        }
        if (!tea_util_1.default.isUnset(request.instructions)) {
            body["instructions"] = request.instructions;
        }
        if (!tea_util_1.default.isUnset(request.metadata)) {
            body["metadata"] = request.metadata;
        }
        if (!tea_util_1.default.isUnset(request.stream)) {
            body["stream"] = request.stream;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateAssistantRun",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/threads/${threadId}/runs`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateAssistantRunResponse({}));
    }
    /**
     * AI
     *
     * @param request - CreateAssistantRunRequest
     * @returns CreateAssistantRunResponse
     */
    async createAssistantRun(threadId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateAssistantRunHeaders({});
        return await this.createAssistantRunWithOptions(threadId, request, headers, runtime);
    }
    /**
     * AI
     *
     * @param request - CreateAssistantThreadRequest
     * @param headers - CreateAssistantThreadHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateAssistantThreadResponse
     */
    async createAssistantThreadWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.metadata)) {
            body["metadata"] = request.metadata;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateAssistantThread",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/threads`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateAssistantThreadResponse({}));
    }
    /**
     * AI
     *
     * @param request - CreateAssistantThreadRequest
     * @returns CreateAssistantThreadResponse
     */
    async createAssistantThread(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateAssistantThreadHeaders({});
        return await this.createAssistantThreadWithOptions(request, headers, runtime);
    }
    /**
     * AI
     *
     * @param request - DeleteAssistantRequest
     * @param headers - DeleteAssistantHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeleteAssistantResponse
     */
    async deleteAssistantWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.assistantId)) {
            query["assistantId"] = request.assistantId;
        }
        if (!tea_util_1.default.isUnset(request.operatorUnionId)) {
            query["operatorUnionId"] = request.operatorUnionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteAssistant",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/basicInfo`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteAssistantResponse({}));
    }
    /**
     * AI
     *
     * @param request - DeleteAssistantRequest
     * @returns DeleteAssistantResponse
     */
    async deleteAssistant(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteAssistantHeaders({});
        return await this.deleteAssistantWithOptions(request, headers, runtime);
    }
    /**
     * AI
     *
     * @param headers - DeleteAssistantMessageHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeleteAssistantMessageResponse
     */
    async deleteAssistantMessageWithOptions(threadId, messageId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "DeleteAssistantMessage",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/threads/${threadId}/messages/${messageId}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteAssistantMessageResponse({}));
    }
    /**
     * AI
     * @returns DeleteAssistantMessageResponse
     */
    async deleteAssistantMessage(threadId, messageId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteAssistantMessageHeaders({});
        return await this.deleteAssistantMessageWithOptions(threadId, messageId, headers, runtime);
    }
    /**
     * AI
     *
     * @param headers - DeleteAssistantThreadHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeleteAssistantThreadResponse
     */
    async deleteAssistantThreadWithOptions(threadId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "DeleteAssistantThread",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/threads/${threadId}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteAssistantThreadResponse({}));
    }
    /**
     * AI
     * @returns DeleteAssistantThreadResponse
     */
    async deleteAssistantThread(threadId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteAssistantThreadHeaders({});
        return await this.deleteAssistantThreadWithOptions(threadId, headers, runtime);
    }
    /**
     * 
     *
     * @param request - DeleteDomainWordsRequest
     * @param headers - DeleteDomainWordsHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeleteDomainWordsResponse
     */
    async deleteDomainWordsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.assistantId)) {
            body["assistantId"] = request.assistantId;
        }
        if (!tea_util_1.default.isUnset(request.domainWords)) {
            body["domainWords"] = request.domainWords;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDomainWords",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/domainWords/remove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteDomainWordsResponse({}));
    }
    /**
     * 
     *
     * @param request - DeleteDomainWordsRequest
     * @returns DeleteDomainWordsResponse
     */
    async deleteDomainWords(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteDomainWordsHeaders({});
        return await this.deleteDomainWordsWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - DeleteKnowledgeRequest
     * @param headers - DeleteKnowledgeHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeleteKnowledgeResponse
     */
    async deleteKnowledgeWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.assistantId)) {
            query["assistantId"] = request.assistantId;
        }
        if (!tea_util_1.default.isUnset(request.studyId)) {
            query["studyId"] = request.studyId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteKnowledge",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/knowledges/items`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteKnowledgeResponse({}));
    }
    /**
     * 
     *
     * @param request - DeleteKnowledgeRequest
     * @returns DeleteKnowledgeResponse
     */
    async deleteKnowledge(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteKnowledgeHeaders({});
        return await this.deleteKnowledgeWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - GetAskDetailRequest
     * @param headers - GetAskDetailHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetAskDetailResponse
     */
    async getAskDetailWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.assistantId)) {
            query["assistantId"] = request.assistantId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["endTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.offset)) {
            query["offset"] = request.offset;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["pageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["startTime"] = request.startTime;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetAskDetail",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/askDetails`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetAskDetailResponse({}));
    }
    /**
     * 
     *
     * @param request - GetAskDetailRequest
     * @returns GetAskDetailResponse
     */
    async getAskDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetAskDetailHeaders({});
        return await this.getAskDetailWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - GetDomainWordsRequest
     * @param headers - GetDomainWordsHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetDomainWordsResponse
     */
    async getDomainWordsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.assistantId)) {
            query["assistantId"] = request.assistantId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetDomainWords",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/domainWords`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetDomainWordsResponse({}));
    }
    /**
     * 
     *
     * @param request - GetDomainWordsRequest
     * @returns GetDomainWordsResponse
     */
    async getDomainWords(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetDomainWordsHeaders({});
        return await this.getDomainWordsWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - GetKnowledgeListRequest
     * @param headers - GetKnowledgeListHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetKnowledgeListResponse
     */
    async getKnowledgeListWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.assistantId)) {
            query["assistantId"] = request.assistantId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetKnowledgeList",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/knowledges/items`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetKnowledgeListResponse({}));
    }
    /**
     * 
     *
     * @param request - GetKnowledgeListRequest
     * @returns GetKnowledgeListResponse
     */
    async getKnowledgeList(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetKnowledgeListHeaders({});
        return await this.getKnowledgeListWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - InstallAssistantRequest
     * @param headers - InstallAssistantHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns InstallAssistantResponse
     */
    async installAssistantWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.assistantId)) {
            body["assistantId"] = request.assistantId;
        }
        if (!tea_util_1.default.isUnset(request.isAllOrgMemberVisible)) {
            body["isAllOrgMemberVisible"] = request.isAllOrgMemberVisible;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "InstallAssistant",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/install`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new InstallAssistantResponse({}));
    }
    /**
     * 
     *
     * @param request - InstallAssistantRequest
     * @returns InstallAssistantResponse
     */
    async installAssistant(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new InstallAssistantHeaders({});
        return await this.installAssistantWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - LearnKnowledgeRequest
     * @param headers - LearnKnowledgeHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns LearnKnowledgeResponse
     */
    async learnKnowledgeWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.assistantId)) {
            body["assistantId"] = request.assistantId;
        }
        if (!tea_util_1.default.isUnset(request.docUrl)) {
            body["docUrl"] = request.docUrl;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "LearnKnowledge",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/knowledges/items`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new LearnKnowledgeResponse({}));
    }
    /**
     * 
     *
     * @param request - LearnKnowledgeRequest
     * @returns LearnKnowledgeResponse
     */
    async learnKnowledge(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new LearnKnowledgeHeaders({});
        return await this.learnKnowledgeWithOptions(request, headers, runtime);
    }
    /**
     * AI
     *
     * @param request - ListAssistantRequest
     * @param headers - ListAssistantHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ListAssistantResponse
     */
    async listAssistantWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.cursor)) {
            query["cursor"] = request.cursor;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["pageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListAssistant",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/list`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListAssistantResponse({}));
    }
    /**
     * AI
     *
     * @param request - ListAssistantRequest
     * @returns ListAssistantResponse
     */
    async listAssistant(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListAssistantHeaders({});
        return await this.listAssistantWithOptions(request, headers, runtime);
    }
    /**
     * AI
     *
     * @param request - ListAssistantMessageRequest
     * @param headers - ListAssistantMessageHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ListAssistantMessageResponse
     */
    async listAssistantMessageWithOptions(threadId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.order)) {
            query["order"] = request.order;
        }
        if (!tea_util_1.default.isUnset(request.runId)) {
            query["runId"] = request.runId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListAssistantMessage",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/threads/${threadId}/messages`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListAssistantMessageResponse({}));
    }
    /**
     * AI
     *
     * @param request - ListAssistantMessageRequest
     * @returns ListAssistantMessageResponse
     */
    async listAssistantMessage(threadId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListAssistantMessageHeaders({});
        return await this.listAssistantMessageWithOptions(threadId, request, headers, runtime);
    }
    /**
     * AI
     *
     * @param request - ListAssistantRunRequest
     * @param headers - ListAssistantRunHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ListAssistantRunResponse
     */
    async listAssistantRunWithOptions(threadId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.limit)) {
            query["limit"] = request.limit;
        }
        if (!tea_util_1.default.isUnset(request.order)) {
            query["order"] = request.order;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListAssistantRun",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/threads/${threadId}/runs`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListAssistantRunResponse({}));
    }
    /**
     * AI
     *
     * @param request - ListAssistantRunRequest
     * @returns ListAssistantRunResponse
     */
    async listAssistantRun(threadId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListAssistantRunHeaders({});
        return await this.listAssistantRunWithOptions(threadId, request, headers, runtime);
    }
    /**
     * AI
     *
     * @param request - ListVisibleAssistantRequest
     * @param headers - ListVisibleAssistantHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ListVisibleAssistantResponse
     */
    async listVisibleAssistantWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.cursor)) {
            query["cursor"] = request.cursor;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["pageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListVisibleAssistant",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/visibleList`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListVisibleAssistantResponse({}));
    }
    /**
     * AI
     *
     * @param request - ListVisibleAssistantRequest
     * @returns ListVisibleAssistantResponse
     */
    async listVisibleAssistant(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListVisibleAssistantHeaders({});
        return await this.listVisibleAssistantWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - LogListRequest
     * @param headers - LogListHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns LogListResponse
     */
    async logListWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.assistantId)) {
            query["assistantId"] = request.assistantId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["endTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["pageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["pageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["startTime"] = request.startTime;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "LogList",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/logs/list`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new LogListResponse({}));
    }
    /**
     * 
     *
     * @param request - LogListRequest
     * @returns LogListResponse
     */
    async logList(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new LogListHeaders({});
        return await this.logListWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - RelearnKnowledgeRequest
     * @param headers - RelearnKnowledgeHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns RelearnKnowledgeResponse
     */
    async relearnKnowledgeWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.assistantId)) {
            body["assistantId"] = request.assistantId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RelearnKnowledge",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/knowledges/incrLearning`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RelearnKnowledgeResponse({}));
    }
    /**
     * 
     *
     * @param request - RelearnKnowledgeRequest
     * @returns RelearnKnowledgeResponse
     */
    async relearnKnowledge(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RelearnKnowledgeHeaders({});
        return await this.relearnKnowledgeWithOptions(request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - RemoveAssistantRequest
     * @param headers - RemoveAssistantHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns RemoveAssistantResponse
     */
    async removeAssistantWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.assistantId)) {
            body["assistantId"] = request.assistantId;
        }
        if (!tea_util_1.default.isUnset(request.operatorUnionId)) {
            body["operatorUnionId"] = request.operatorUnionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RemoveAssistant",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/uninstall`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RemoveAssistantResponse({}));
    }
    /**
     * 
     *
     * @param request - RemoveAssistantRequest
     * @returns RemoveAssistantResponse
     */
    async removeAssistant(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RemoveAssistantHeaders({});
        return await this.removeAssistantWithOptions(request, headers, runtime);
    }
    /**
     *  AI 
     *
     * @param request - RetrieveAssistantBasicInfoRequest
     * @param headers - RetrieveAssistantBasicInfoHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns RetrieveAssistantBasicInfoResponse
     */
    async retrieveAssistantBasicInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.assistantId)) {
            query["assistantId"] = request.assistantId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RetrieveAssistantBasicInfo",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/basicInfo`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RetrieveAssistantBasicInfoResponse({}));
    }
    /**
     *  AI 
     *
     * @param request - RetrieveAssistantBasicInfoRequest
     * @returns RetrieveAssistantBasicInfoResponse
     */
    async retrieveAssistantBasicInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RetrieveAssistantBasicInfoHeaders({});
        return await this.retrieveAssistantBasicInfoWithOptions(request, headers, runtime);
    }
    /**
     * AI
     *
     * @param headers - RetrieveAssistantMessageHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns RetrieveAssistantMessageResponse
     */
    async retrieveAssistantMessageWithOptions(threadId, messageId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "RetrieveAssistantMessage",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/threads/${threadId}/messages/${messageId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RetrieveAssistantMessageResponse({}));
    }
    /**
     * AI
     * @returns RetrieveAssistantMessageResponse
     */
    async retrieveAssistantMessage(threadId, messageId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RetrieveAssistantMessageHeaders({});
        return await this.retrieveAssistantMessageWithOptions(threadId, messageId, headers, runtime);
    }
    /**
     * AI
     *
     * @param headers - RetrieveAssistantRunHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns RetrieveAssistantRunResponse
     */
    async retrieveAssistantRunWithOptions(threadId, runId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "RetrieveAssistantRun",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/threads/${threadId}/runs/${runId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RetrieveAssistantRunResponse({}));
    }
    /**
     * AI
     * @returns RetrieveAssistantRunResponse
     */
    async retrieveAssistantRun(threadId, runId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RetrieveAssistantRunHeaders({});
        return await this.retrieveAssistantRunWithOptions(threadId, runId, headers, runtime);
    }
    /**
     * 
     *
     * @param request - RetrieveAssistantScopeRequest
     * @param headers - RetrieveAssistantScopeHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns RetrieveAssistantScopeResponse
     */
    async retrieveAssistantScopeWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.assistantId)) {
            query["assistantId"] = request.assistantId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RetrieveAssistantScope",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/scope`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RetrieveAssistantScopeResponse({}));
    }
    /**
     * 
     *
     * @param request - RetrieveAssistantScopeRequest
     * @returns RetrieveAssistantScopeResponse
     */
    async retrieveAssistantScope(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RetrieveAssistantScopeHeaders({});
        return await this.retrieveAssistantScopeWithOptions(request, headers, runtime);
    }
    /**
     * AI
     *
     * @param headers - RetrieveAssistantThreadHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns RetrieveAssistantThreadResponse
     */
    async retrieveAssistantThreadWithOptions(threadId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "RetrieveAssistantThread",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/threads/${threadId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RetrieveAssistantThreadResponse({}));
    }
    /**
     * AI
     * @returns RetrieveAssistantThreadResponse
     */
    async retrieveAssistantThread(threadId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RetrieveAssistantThreadHeaders({});
        return await this.retrieveAssistantThreadWithOptions(threadId, headers, runtime);
    }
    /**
     * AI
     *
     * @param request - UpdateAssistantBasicInfoRequest
     * @param headers - UpdateAssistantBasicInfoHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateAssistantBasicInfoResponse
     */
    async updateAssistantBasicInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.assistantId)) {
            body["assistantId"] = request.assistantId;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.fallbackContent)) {
            body["fallbackContent"] = request.fallbackContent;
        }
        if (!tea_util_1.default.isUnset(request.icon)) {
            body["icon"] = request.icon;
        }
        if (!tea_util_1.default.isUnset(request.instructions)) {
            body["instructions"] = request.instructions;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.operatorUnionId)) {
            body["operatorUnionId"] = request.operatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.recommendPrompts)) {
            body["recommendPrompts"] = request.recommendPrompts;
        }
        if (!tea_util_1.default.isUnset(request.welcomeContent)) {
            body["welcomeContent"] = request.welcomeContent;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateAssistantBasicInfo",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/basicInfo`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateAssistantBasicInfoResponse({}));
    }
    /**
     * AI
     *
     * @param request - UpdateAssistantBasicInfoRequest
     * @returns UpdateAssistantBasicInfoResponse
     */
    async updateAssistantBasicInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateAssistantBasicInfoHeaders({});
        return await this.updateAssistantBasicInfoWithOptions(request, headers, runtime);
    }
    /**
     *  AI 
     *
     * @param request - UpdateAssistantScopeRequest
     * @param headers - UpdateAssistantScopeHeaders
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateAssistantScopeResponse
     */
    async updateAssistantScopeWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.assistantId)) {
            body["assistantId"] = request.assistantId;
        }
        if (!tea_util_1.default.isUnset(request.operatorUnionId)) {
            body["operatorUnionId"] = request.operatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.scopes)) {
            body["scopes"] = request.scopes;
        }
        if (!tea_util_1.default.isUnset(request.sharing)) {
            body["sharing"] = request.sharing;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateAssistantScope",
            version: "assistant_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/assistant/scope`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "any",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateAssistantScopeResponse({}));
    }
    /**
     *  AI 
     *
     * @param request - UpdateAssistantScopeRequest
     * @returns UpdateAssistantScopeResponse
     */
    async updateAssistantScope(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateAssistantScopeHeaders({});
        return await this.updateAssistantScopeWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map